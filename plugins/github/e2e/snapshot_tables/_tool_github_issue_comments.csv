github_id,issue_id,body,author_username,author_user_id,github_created_at,github_updated_at,_raw_data_params,_raw_data_table,_raw_data_id,_raw_data_remark
546927657,513276141,"""为什么递归会用完 worker ？你是每一层递归都会调用 `pool.Submit` ？""",panjf2000,7496278,2019-10-28T12:38:47.000+00:00,2019-10-28T12:40:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3376,
546929401,513276141,"""对，就是我遍历目录的时候，每一个子目录就再`pool.Submit`，就像这样子\r\n``` go\r\n               if !cextinfo.IsDir() {\r\n\t\t\t// ...\r\n\t\t} else {\r\n\t\t\twg.Add(1)\r\n\t\t\terr = p.Submit(func() {\r\n\t\t\t\tbuildTree(&cextinfo, errs, wg, p)\r\n\t\t\t\twg.Done()\r\n\t\t\t})\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs <- err\r\n\t\t}\r\n```\r\n@panjf2000 """,HaoKunT,16379361,2019-10-28T12:44:31.000+00:00,2019-10-28T12:55:25.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3377,
546948340,513276141,"""你这个需求和 #55 大同小异，都是想把业务特性加到 `ants` 里，不太妥当。是不是你的 pool size 设置得太小了？设置个几十万难道还不能满足？遍历的目录是有多大？\r\n\r\n再说了，这个需求也不合理，加入一个等待队列，这个队列长度又要怎么设置，超过了长度要怎么办？阻塞？丢弃？这不又和现在的情况一样了吗？\r\n\r\n如果是长度无限制的话，那你完全可以直接使用 `ants` 的默认 pool，它的 size 是 `math.MaxInt32`，我相信足够大了，个人觉得加一个等待队列没什么意义了，因为你完全可以把 pool size 设置得足够大。""",panjf2000,7496278,2019-10-28T13:35:15.000+00:00,2019-10-28T13:44:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3378,
546966600,513276141,"""你说的有道理，但是如果长度无限制的话，那和自带的go关键字似乎没有区别？实际上我使用ants的原因就是在遍历很大的目录的时候，会出现内存占用过多的情况，因此希望能复用go程，那个`ExpiryDuration`配置项具体起到什么作用啊？是不是这个会隔一段时间就清理一次？是什么原理？""",HaoKunT,16379361,2019-10-28T14:16:54.000+00:00,2019-10-28T14:16:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3379,
546973940,513276141,"""> 但是如果长度无限制的话，那和自带的go关键字似乎没有区别？实际上我使用ants的原因就是在遍历很大的目录的时候，会出现内存占用过多的情况，因此希望能复用go程\r\n\r\n有区别啊，`ants` 虽然长度无限，但是会有复用，一旦 worker 完成任务就可以给下一个任务用，所以虽然你设置的是很大的 size，但是实际上整个流程跑完，最终创建的 go 程的数量可能是很少的，你可以试试。\r\n\r\n> 那个ExpiryDuration配置项具体起到什么作用啊？是不是这个会隔一段时间就清理一次？是什么原理？\r\n\r\n`ExpiryDuration` 就是一个定时的周期，就表示每隔 `ExpiryDuration` 时长执行一次清理，清理掉那些放置在队列里超过 `ExpiryDuration` 时长没有被使用过的 worker，以此类推，这个特性同样是为了节省资源。\r\n""",panjf2000,7496278,2019-10-28T14:33:25.000+00:00,2019-10-28T14:36:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3380,
547001585,513276141,"""OK懂了，谢谢""",HaoKunT,16379361,2019-10-28T15:29:12.000+00:00,2019-10-28T15:29:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3381,
548644518,515876300,"""我看你之前说在线上使用了 `ants`，我还以为是贵司在用，是我误会了？😂""",panjf2000,7496278,2019-11-01T02:42:37.000+00:00,2019-11-01T02:42:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3382,
548666345,515876300,"""我并没有说过 bytedance 线上在用 ants。。。""",choleraehyq,8923413,2019-11-01T04:56:17.000+00:00,2019-11-01T04:56:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3383,
548666641,515876300,"""哦哦，那是我误会了，等会儿我更新一下 README，移掉 logo，抱歉！\n\nOn Fri, Nov 1, 2019 at 12:56 Cholerae Hu <notifications@github.com> wrote:\n\n> 我并没有说过 bytedance 线上在用 ants。。。\n>\n> —\n> You are receiving this because you commented.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/panjf2000/ants/issues/57?email_source=notifications&email_token=ABZGEVT5EY3LNJKLSWUF4XDQROZHJA5CNFSM4JHVKSZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECZ7X2I#issuecomment-548666345>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABZGEVRZWCWMK27X2LGYOX3QROZHJANCNFSM4JHVKSZA>\n> .\n>\n""",panjf2000,7496278,2019-11-01T04:58:18.000+00:00,2019-11-01T04:58:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3384,
551366581,519634014,"""代码用 md 语法格式化一下。。。这样很乱""",panjf2000,7496278,2019-11-08T03:15:46.000+00:00,2019-11-08T03:15:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3385,
551367875,519634014,"""而且看错误信息，crash 是因为你自己的函数: doPortScan panic 了，你没有设置 PanicHandler，当然会 crash 了，这个和 ants 没有关系。""",panjf2000,7496278,2019-11-08T03:22:33.000+00:00,2019-11-08T03:22:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3386,
551373824,519634014,"""当添加完panic处理后，依然报错。\r\n```\r\nfunc doPortScan(i interface{}) {\r\n\tdefer func() {\r\n\t\tif p := recover(); p != nil {\r\n\r\n\t\t\tfmt.Errorf(\""internal error: %v\"", p)\r\n\t\t}\r\n\t}()\r\n\tport := i.(int32)\r\n\tatomic.AddInt32(&sum, port)\r\n\r\n\t_, err := net.DialTimeout(\""tcp\"", fmt.Sprintf(\""192.168.20.1:%d\"", port), time.Second*1)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tfmt.Printf(\""Port  %d is open\\n\"", port)\r\n\r\n\r\n}\r\n```\r\n报错内容\r\n\r\n```\r\ngoroutine 2790 [chan receive]:\r\ngithub.com/panjf2000/ants/v2.(*goWorkerWithFunc).run.func1(0xc000fdc510)\r\n\t/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:65 +0x85\r\ncreated by github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run\r\n\t/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:49 +0x4c\r\n\r\ngoroutine 2791 [chan receive]:\r\ngithub.com/panjf2000/ants/v2.(*goWorkerWithFunc).run.func1(0xc000fdc540)\r\n\t/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:65 +0x85\r\ncreated by github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run\r\n\t/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:49 +0x4c\r\n\r\ngoroutine 244 [chan receive]:\r\ngithub.com/panjf2000/ants/v2.(*goWorkerWithFunc).run.func1(0xc00170f0b0)\r\n\t/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:65 +0x85\r\ncreated by github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run\r\n\t/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:49 +0x4c\r\nexit status 2\r\n```""",pwnfun,36106762,2019-11-08T03:55:03.000+00:00,2019-11-08T03:55:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3387,
551375401,519634014,"""ants 是哪个版本？业务的 panic 报错信息是什么？就是这个 `fmt.Errorf(\""internal error: %v\"", p)` 打印的。""",panjf2000,7496278,2019-11-08T04:03:47.000+00:00,2019-11-08T04:04:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3388,
551375799,519634014,"""还有，下次提 issue 的时候按照我设置的模板填，不然现在我什么上下文信息都不知道，只能靠猜，很浪费大家的时间。""",panjf2000,7496278,2019-11-08T04:06:20.000+00:00,2019-11-08T04:07:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3389,
551376478,519634014,"""而且你 dial 之后怎么不关闭连接？是不是打开的连接数过多导致的 panic ？""",panjf2000,7496278,2019-11-08T04:10:19.000+00:00,2019-11-08T04:10:19.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3390,
553207087,519634014,"""Hello，我看你一直没回复，而且前面我分析了一下业务逻辑的问题而不是 ants 的问题，所以我先关掉这个 issue，有需要你再打开吧。""",panjf2000,7496278,2019-11-13T02:19:02.000+00:00,2019-11-13T02:19:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3391,
554839729,524118492,"""/cc @panjf2000 """,choleraehyq,8923413,2019-11-18T03:49:29.000+00:00,2019-11-18T03:49:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3392,
554881175,524118492,"""有点像 #55 #56 ，按你的设想，优先队列无非就是每次先尝试从高优先队列取 worker，没有的话是等待还是降级到低一级队列去取？按照 ants 现在的架构，引入优先队列没有意义，因为不管是从高优先队列还是普通队列里取出 worker，都是直接去提交运行了，并没有优先的概念。\r\n\r\n还有，为什么你说的用多个 pool 满足不了你的需求？为什么一定要在一个 pool 里实现优先调度？""",panjf2000,7496278,2019-11-18T07:06:09.000+00:00,2019-11-18T07:06:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3393,
554882114,524118492,"""我猜你想说的是在 worker struct 里加优先的队列吧？worker 每次先尝试从优先 channel 里取任务执行？""",panjf2000,7496278,2019-11-18T07:09:33.000+00:00,2019-11-18T07:09:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3394,
554886140,524118492,"""你说的这些都是实现问题了。从功能上来说，就是希望当池子被用满的时候，高优先级队列可以被确保插队来执行。现在我理解是不能的吧。现在如果池子已经满了，有一些请求阻塞在 Submit 这里，怎么保证高优任务优先执行呢""",choleraehyq,8923413,2019-11-18T07:22:59.000+00:00,2019-11-18T07:22:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3395,
554886574,524118492,"""多个 pool 就有很多管理难度，我就需要监控多个 pool，参数里也要调整多个 pool 的大小，而且高优队列可能处于长期闲置状态，在平时浪费资源。""",choleraehyq,8923413,2019-11-18T07:24:29.000+00:00,2019-11-18T07:24:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3396,
555056685,524118492,"""1. 关于优先级任务的性质：我还是觉得这个和 #55 #56 一样偏向于业务需求，本质上来讲不属于 goroutine pool 的职责范围；\r\n2. 关于优先级任务的实现：就算最后要做这个功能，我也不赞同通过引入多个队列来实现，这种做法太粗糙且会极大增加代码复杂度（多个队列多个锁），我目前想到的比较合理的方案是利用 `Priority Queue` 来实现，现在 ants 的 workers 已经抽象成接口了，可以通过实现这个[接口](https://github.com/panjf2000/ants/blob/master/worker_array.go#L16-L23)来完成。""",panjf2000,7496278,2019-11-18T15:09:31.000+00:00,2019-11-18T15:09:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3397,
555350931,524118492,"""1. 在外部实现，这很难。一个比较好的优先级调度功能，肯定是侵入里面的。试想一下，你想基于 go scheduler 实现一个自己的优先级调度功能，怎么实现？很难实现，只能侵入进去。\r\n    至于说业务逻辑不业务逻辑，linux 调度器是有优先级调度的，erlang 调度器也是有优先级调度的，可能他们都是为了实现一些业务逻辑罢。\r\n2. 实现上可以再考虑，我说的多个队列这种只是借用了 deadline 调度算法的实现，实际上可以开一个接口出来，比如 linux io 调度器的接口是 https://elixir.bootlin.com/linux/latest/source/kernel/sched/sched.h#L1684，仅供参考。""",choleraehyq,8923413,2019-11-19T06:15:02.000+00:00,2019-11-19T06:15:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3398,
555351732,524118492,"""priority queue 太简单了，很容易就饿死了。""",choleraehyq,8923413,2019-11-19T06:18:02.000+00:00,2019-11-19T06:18:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3399,
841988512,890078421,"""loopQueue 是环形队列，和栈是两回事，默认的实现是栈，你不要指定 loopQueue 就行了。""",panjf2000,7496278,2021-05-17T05:07:37.000+00:00,2021-05-17T05:07:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3653,
843937616,892678963,"""理解了，thx""",chenbyby,30179199,2021-05-19T09:47:39.000+00:00,2021-05-19T09:47:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3654,
846514022,864353725,"""Closing this issue for inactivity.""",panjf2000,7496278,2021-05-23T06:50:27.000+00:00,2021-05-23T06:50:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3655,
846531288,898973379,"""目的是确保输出持续平滑的情况下，排队数据可观察，不被太长时间延时或被丢弃，或动态 `p.Tune(newSize)`\r\n如果已有现成的方案，请指点。\r\n谢谢 ants, gnet 很棒！""",fufuok,4979407,2021-05-23T09:18:34.000+00:00,2021-05-23T09:18:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3656,
846562785,898973379,"""我理解可以用一个计数器实现你的需求？在每个任务的入口处对计数器加一，然后你用任务总数减去计数器数量应该就可以了吧。""",panjf2000,7496278,2021-05-23T13:23:26.000+00:00,2021-05-23T13:23:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3657,
846563466,802177721,"""I believe `ants` is a crucial library with concise APIs, besides we do have documentation: https://pkg.go.dev/github.com/panjf2000/ants/v2""",panjf2000,7496278,2021-05-23T13:28:20.000+00:00,2021-05-23T13:34:47.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3658,
846564325,802177721,"""As for the users of `ants`： https://github.com/panjf2000/ants#-user-cases""",panjf2000,7496278,2021-05-23T13:34:56.000+00:00,2021-05-23T13:34:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3659,
846572606,898973379,"""谢谢回复.\r\n嗯, 是的, 现在是用计数器这么做的. \r\n我是看 ants 已经提供了 3 个指标数据方法, 如果能加上就更好了, 毕竟 blockingNum 到 MaxBlockingTasks 这一段目前对用户是黑盒.""",fufuok,4979407,2021-05-23T14:32:58.000+00:00,2021-05-23T14:32:58.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3660,
846572688,898973379,"""若没有太大实现意义, 请关闭它.""",fufuok,4979407,2021-05-23T14:33:34.000+00:00,2021-05-23T14:33:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3661,
846580304,898973379,"""`blockingNum` 一开始只是个内部使用的变量，以前倒是没想到用户会希望拿到这个值，因为一开始考虑的是排队等待的数量应该是很小的，所以不需要持续去监控这个值。`blockingNum` 暴露出来倒不是不行，只是我不太清楚有多少用户有和你同样的需求，所以就先暂时不改吧，然后这个 issue 也暂时不关闭，如果有更多的用户提出需要拿到 `blockingNum`，那我再考虑去做。""",panjf2000,7496278,2021-05-23T15:24:07.000+00:00,2021-05-23T15:24:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3662,
851227834,907118378,"""抱歉，我之前没有打开这个仓库的 discussion，现在打开了，麻烦移步 https://github.com/panjf2000/ants/discussions\r\n\r\nissue 一般是用来提 bug 或者 feature 的。""",panjf2000,7496278,2021-05-31T06:35:13.000+00:00,2021-05-31T06:35:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3666,
851234440,907118378,"""> 抱歉，我之前没有打开这个仓库的 discussion，现在打开了，麻烦移步 https://github.com/panjf2000/ants/discussions\r\n> \r\n> issue 一般是用来提 bug 或者 feature 的。\r\n\r\n已经在discussion提问了""",guoxinyu-shopee,53163548,2021-05-31T06:44:53.000+00:00,2021-05-31T06:44:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3667,
851546317,907293042,"""> 我自己的理解，默认1s过期的情况下，可能会导致有些worker的回收时间延迟1s\r\n\r\n这个结论你是怎么得出来的？""",panjf2000,7496278,2021-05-31T15:02:25.000+00:00,2021-05-31T15:02:25.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3668,
851548328,907293042,"""5ms 的误差看起来不算很大（不过如果你的 worker 数量很大就另当别论了），但是要保证队列里的时间是单调递增的，不然就可能有潜在问题。""",panjf2000,7496278,2021-05-31T15:06:00.000+00:00,2021-05-31T15:06:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3669,
856822037,913065024,"""> ants version: latest\r\n\r\n你这不是最新的代码吧？行数对不上，拉一下最新代码再试试有没有问题。""",panjf2000,7496278,2021-06-08T14:33:57.000+00:00,2021-06-08T14:33:57.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3670,
856838479,913065024,"""![image](https://user-images.githubusercontent.com/30179199/121207440-dd23b600-c8ab-11eb-8d77-ac1e6c162377.png)\r\n![image](https://user-images.githubusercontent.com/30179199/121207611-017f9280-c8ac-11eb-9b21-08ed21b6912e.png)\r\n\r\n行数对不上是因为参考ants，本地重新写了遍。上面截图是ants的代码""",chenbyby,30179199,2021-06-08T14:53:34.000+00:00,2021-06-08T14:53:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3671,
857365294,913065024,"""重新写了什么？""",panjf2000,7496278,2021-06-09T04:35:40.000+00:00,2021-06-09T04:35:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3672,
857441693,913065024,"""自己练手写的routine pool。\r\nants这个test case，偶尔成功偶尔失败，原因还未知。""",chenbyby,30179199,2021-06-09T07:02:50.000+00:00,2021-06-09T07:02:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3673,
857708468,913065024,"""你这是在测自己写的库？那你不应该来这提 issue 啊！这又不是 `ants` 的 bug。""",panjf2000,7496278,2021-06-09T13:46:27.000+00:00,2021-06-09T13:46:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3674,
858415502,913065024,"""ants_test 438行：p.Invoke(nil)\r\nworker_func 67行：if args == nil { return }\r\n由于go函数滞后于go语句执行，如果还没来得及运行go函数，即：worker遍历chan，执行到ants_test 443行，判断err为ErrPoolOverload成立。\r\n如果已经运行了部分go函数，那么运行的那部分worker判断args==nil，执行defer操作，running--，导致ants_test 443行断言ErrPoolOverload失败，打印msg""",chenbyby,30179199,2021-06-10T08:17:16.000+00:00,2021-06-10T08:17:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3675,
859684491,918864340,"""Duplicate #123 """,panjf2000,7496278,2021-06-11T16:05:34.000+00:00,2021-06-11T16:05:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3676,
859687846,918864340,"""参考 #144 \r\n压测代码使用 time.Sleep 现在看来太简单了，可能也不能反映出真实的场景，你要是有兴趣可以放到一些实际的场景压一下看看实际的数据，`ants` 现在主要是能节省大量的系统资源，至于性能，现在也有很多公司在线上使用，在复杂的生产环境启用大规模 goroutines 做网络服务的时候对性能应该是有不少提升的。""",panjf2000,7496278,2021-06-11T16:10:46.000+00:00,2021-06-11T16:11:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3677,
976733458,1058613251,"""另外，你这种用法的确不是很好，其实你可以在调用 `NewPool(capacity)` 时就指定很大的 capacity，ants 是按需扩容的，直到达到预设的 capacity，不需要频繁地调用 `Tune()` 函数去调整 capacity。""",panjf2000,7496278,2021-11-23T15:37:22.000+00:00,2021-11-23T15:37:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3757,
418297020,356703393,"""// Submit submits a task to this pool.\r\nfunc (p *Pool) Submit(task f) error {\r\n\tif len(p.release) > 0 {\r\n\t\treturn ErrPoolClosed\r\n\t}\r\n\tp.getWorker().task <- task\r\n\treturn nil\r\n}\r\n我是觉得p.getWorker()  阻塞不太好 ，这样主任务和pool没有彻底隔离""",Moonlight-Zhao,11763614,2018-09-04T09:11:37.000+00:00,2018-09-04T09:11:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3187,
425014962,364361014,"""我晚上回去就打一下新的tag，完了我再给你回一个邮件\r\n\r\nedcismybrother <notifications@github.com> 于2018年9月27日周四 下午4:32写道：\r\n\r\n> 鄙人现在在弄dep依赖管理，有用到你写的ants项目，可是你好像忘记打最新的tag了。最新的tag\r\n> 3.6是指向ed55924这个提交，git上的最新代码是af376f1b这次提交，两次提交都隔了快5个月了，看到的话，麻烦打一个最新的tag吧。（手动可怜）\r\n>\r\n> —\r\n> You are receiving this because you are subscribed to this thread.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/panjf2000/ants/issues/12>, or mute the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AHJiVu1xmx5uoFGBcSu6te_iHFwf7IPEks5ufI0egaJpZM4W8KCS>\r\n> .\r\n>\r\n""",panjf2000,7496278,2018-09-27T09:00:40.000+00:00,2018-09-27T09:00:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3189,
425018770,356703393,"""我觉得这个会导致cpu上升。调用Submit时，如果没有多余的worker，会一直进入这个死循环\r\n```\t\t\r\nfor {\r\n\t\t\tp.lock.Lock()\r\n\t\t\tidleWorkers = p.workers\r\n\t\t\tl := len(idleWorkers) - 1\r\n\t\t\tif l < 0 {\r\n\t\t\t\tp.lock.Unlock()\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tw = idleWorkers[l]\r\n\t\t\tidleWorkers[l] = nil\r\n\t\t\tp.workers = idleWorkers[:l]\r\n\t\t\tp.lock.Unlock()\r\n\t\t\tbreak\r\n\t\t}\r\n```\r\n一直会continue，直到有空闲的worker，这样会阻塞调用Submit的goroutine.""",liyonglion,12890888,2018-09-27T09:13:01.000+00:00,2018-09-27T09:13:49.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3190,
425061837,356703393,"""![snip20180927_3](https://user-images.githubusercontent.com/12890888/46144182-c4efe200-c28e-11e8-8e69-ffd4502e3b9e.png)\r\n\r\ncpu占用率一直接近100%\r\n\r\n![snip20180927_4](https://user-images.githubusercontent.com/12890888/46144221-ddf89300-c28e-11e8-985b-48437eb20cdc.png)\r\n""",liyonglion,12890888,2018-09-27T11:53:26.000+00:00,2018-09-27T11:53:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3191,
425062926,364361014,"""tag更新了，v3.7\r\n\r\nAndy Pan <panjf2000@gmail.com> 于2018年9月27日周四 下午5:00写道：\r\n\r\n> 我晚上回去就打一下新的tag，完了我再给你回一个邮件\r\n>\r\n> edcismybrother <notifications@github.com> 于2018年9月27日周四 下午4:32写道：\r\n>\r\n>> 鄙人现在在弄dep依赖管理，有用到你写的ants项目，可是你好像忘记打最新的tag了。最新的tag\r\n>> 3.6是指向ed55924这个提交，git上的最新代码是af376f1b这次提交，两次提交都隔了快5个月了，看到的话，麻烦打一个最新的tag吧。（手动可怜）\r\n>>\r\n>> —\r\n>> You are receiving this because you are subscribed to this thread.\r\n>> Reply to this email directly, view it on GitHub\r\n>> <https://github.com/panjf2000/ants/issues/12>, or mute the thread\r\n>> <https://github.com/notifications/unsubscribe-auth/AHJiVu1xmx5uoFGBcSu6te_iHFwf7IPEks5ufI0egaJpZM4W8KCS>\r\n>> .\r\n>>\r\n>\r\n""",panjf2000,7496278,2018-09-27T11:57:31.000+00:00,2018-09-27T11:57:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3192,
425066089,356703393,"""@liyonglion 这个例子看起来有点极端，因为只有两个任务，pool容量是1，所以剩下那个不断在自己加锁解锁导致cpu忙，如果是多个竞争的大部分是block状态，应该不会出现这种cpu满的情况，不然你把例子改改？增加提交的任务数再看看，看看还会不会出现这种情况。""",panjf2000,7496278,2018-09-27T12:07:30.000+00:00,2018-09-27T12:07:30.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3193,
425288734,356703393,"""@panjf2000  ants比较适合做“短期”任务，如果存在大量的“长期”任务，很有可能导致死循环。为什么不block当前Submit的“线程”？""",liyonglion,12890888,2018-09-28T01:09:40.000+00:00,2018-09-28T01:09:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3194,
425293042,356703393,"""@liyonglion 之前有用过chan阻塞等待，但是导致了一个死锁问题：#6，后来才改成这种形式。所以我说的增加submit的任务数再测试之后也是cpu 100%吗？这个问题我现在暂时没想到比较好的解决办法，我再想想，或者你有没有比较好的想法？可以提个pr。""",panjf2000,7496278,2018-09-28T01:37:17.000+00:00,2018-09-28T01:37:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3195,
425331360,364361014,"""@panjf2000 可以的，谢谢啦""",edcismybrother,29452204,2018-09-28T06:05:58.000+00:00,2018-09-28T06:05:58.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3196,
425409255,356703393,"""@panjf2000  我提交了一个pr，你看下是否合理？我自己跑了上面的用例，没有问题。效率方面我还没有具体测试。""",liyonglion,12890888,2018-09-28T11:41:08.000+00:00,2018-09-28T11:41:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3197,
425423023,356703393,"""@liyonglion 我看修改的代码应该是正确的，但是有两个问题：\r\n1. 要正确测试你pr，你要把ants_test.go里import ants的路径改成你自己的路径；\r\n2.你现在只修改了pool.go的代码，麻烦把pool_func.go里相应的地方也优化一下。""",panjf2000,7496278,2018-09-28T12:41:27.000+00:00,2018-09-28T12:43:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3198,
439792581,382039050,"""GOMAXPROCS你可以理解成是G-P-M模型中的M的数量，也就是最大并行数。""",panjf2000,7496278,2018-11-19T07:10:47.000+00:00,2018-11-19T07:10:47.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3229,
439793939,381941219,"""release的确有这个问题，目前还没有比较好的办法，只是等待定时销毁的那个goroutine去释放内存，你要是有兴趣可以再想想有没有更好的办法，可以提个pr""",panjf2000,7496278,2018-11-19T07:18:05.000+00:00,2018-11-19T07:18:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3231,
440207809,382574800,"""https://github.com/panjf2000/ants/blob/711dbdb7a222771ce15aaee1bb7b7c6e9731f208/pool.go#L119""",kklinan,5668717,2018-11-20T09:41:24.000+00:00,2018-11-20T09:41:24.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3232,
440263871,382574800,"""这里可以讨论下，是否可以在任务函数里通过闭包的形式，将结果存入channel，满足你的需求？""",panjf2000,7496278,2018-11-20T12:56:13.000+00:00,2018-11-20T12:56:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3233,
440500490,382574800,"""> 这里可以讨论下，是否可以在任务函数里通过闭包的形式，将结果存入channel，满足你的需求？\r\n\r\n可以的。但不仅仅如此，最重要的是想得到哪条消息失败了，方便进行下次延时处理或丢回队列。""",kklinan,5668717,2018-11-21T02:00:22.000+00:00,2018-11-21T02:00:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3234,
948219802,1028877423,"""总的来说，指数退避对自旋锁还有一点性能提升的，至少也不会是什么负担。""",panjf2000,7496278,2021-10-21T03:10:12.000+00:00,2021-10-21T03:10:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3737,
948311558,1028877423,"""嗯嗯，通过调整 SleepTime 的时间和 RunTimes次数的测试，得到的结果也都差不多，总体上比Mutex要好不少，采用指数退避 的运行runtime.Gosched()仅仅是在BenchmarkOriginSpinLockWithGoroutineLock 和 BenchmarkBackOffSpinLockWithGoroutineLock的情况下稍微大一点，感觉还是可以在一定程度上模拟出真实情景下的情况。我添加的测试用例可以pr进去补充一下？""",liu-song,22676124,2021-10-21T06:55:08.000+00:00,2021-10-21T06:55:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3738,
948585262,1028877423,"""可以，你提个 PR。""",panjf2000,7496278,2021-10-21T12:52:53.000+00:00,2021-10-21T12:52:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3739,
964431848,1047896477,"""@kiranupadhyak Can you share more details about your use case, eg: why you want to use ant for db inserts ? In ant order of function invocation by worker is not deterministic. Can it cause problems if you are expecting some order during insert ?\r\n\r\nMay be you can use `ants.NewPoolWithFunc`\r\n""",abhipranay,3060920,2021-11-09T18:44:31.000+00:00,2021-11-09T18:44:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3740,
971562231,1054484973,"""I don't find it is hard to understand: every `goWorker` belongs to a pool, which makes it rational to put a `Pool` field in `goWorker`.""",panjf2000,7496278,2021-11-17T13:07:29.000+00:00,2021-11-17T13:07:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3743,
975045406,1058613251,"""贴一下测试代码？""",panjf2000,7496278,2021-11-22T03:46:50.000+00:00,2021-11-22T03:46:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3747,
976099345,1058613251,"""```go\r\npackage main\r\n\r\nimport (\r\n\t\""github.com/panjf2000/ants/v2\""\r\n\t\""log\""\r\n\t\""math/rand\""\r\n\t\""time\""\r\n)\r\nvar taskchannel = make(chan int64, 200)\r\nfunc main() {\r\n\tpool, _ := ants.NewPool(10)\r\n\tgo func() {\r\n\t\tfor true {\r\n\t\t\tcap := pool.Cap()\r\n\t\t\trfee := pool.Free()\r\n\t\t\trunn := pool.Running()\r\n\t\t\tlegtask := len(taskchannel)\r\n\t\t\tlog.Println(\""-------------------------------------------\"")\r\n\t\t\tlog.Println(\""协程池容量\"", cap)\r\n\t\t\tlog.Println(\""可用协程\"", rfee)\r\n\t\t\tlog.Println(\""正在运行协程\"", runn)\r\n\t\t\tlog.Println(\""任务池数量\"", legtask)\r\n\t\t\tif legtask <= 10 && legtask >=0 {\r\n\t\t\t\tpool.Tune(10)\r\n\t\t\t}\r\n\t\t\tif legtask <= 50 && legtask > 10 {\r\n\t\t\t\tpool.Tune(50)\r\n\t\t\t}\r\n\t\t\tif legtask <= 100 && legtask >= 50 {\r\n\t\t\t\tpool.Tune(100)\r\n\t\t\t}\r\n\t\t\tif legtask <= 200 && legtask > 100 {\r\n\t\t\t\tpool.Tune(200)\r\n\t\t\t}\r\n\t\t\ttime.Sleep(time.Second * 1)\r\n\t\t}\r\n\t}()\r\n\tgo func() {\r\n\t\tfor true {\r\n\t\t\ttaskchannel <- time.Now().UnixNano()\r\n\t\t\trand.Seed(time.Now().UnixNano())\r\n\t\t\ttime.Sleep(time.Duration(rand.Intn(50)) * time.Millisecond)\r\n\t\t}\r\n\t}()\r\n\tfor true {\r\n\t\tselect {\r\n\t\tcase data := <-taskchannel:\r\n\t\t\tpool.Submit(func() {\r\n\t\t\t\ttask(data)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n}\r\nfunc task(i int64) {\r\n\trand.Seed(time.Now().UnixNano())\r\n\ttime.Sleep(time.Duration(rand.Intn(3)) * time.Second)\r\n\t//log.Println(\""----\"", i)\r\n}\r\n\r\n```\r\n\r\n进过一段时间 可以看到类似下面的结果,假如按照上面的代码动态调整协程池,是否会出现不可预估的问题\r\n打印结果:可用协程 -23\r\n2021/11/23 09:58:26 -------------------------------------------\r\n2021/11/23 09:58:26 协程池容量 10\r\n2021/11/23 09:58:26 可用协程 -23\r\n2021/11/23 09:58:26 正在运行协程 33\r\n2021/11/23 09:58:26 任务池数量 2\r\n2021/11/23 09:58:27 -------------------------------------------""",longrbl,19727273,2021-11-23T02:00:56.000+00:00,2021-11-23T15:17:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3751,
976133093,1060770678,"""100个worker都在调用submit，但是pool已经满了，要等worker释放，但是所有的worker都在等运行完自己的工作然后释放掉，但是自己的工作因为pool满了被阻塞了，一只无法释放掉。\r\n所以应该是建议在提交的任务之中不要涉及对pool的操作之类的动作。""",mogakun,29850480,2021-11-23T03:32:01.000+00:00,2021-11-23T03:32:01.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3752,
976183082,1060770678,"""事实上 ants 并不禁止 Submit() 里再调用同一个 Pool 的 Submit()。\r\n\r\n> 另外初步分析了一下，Submit的task会被分配给pool中的worker。如果某个worker1执行task1，而task1又调用Submit task2，但task2恰好又被分给worker1，这样就锁住了。\r\n\r\n其实这里的分析不正确，worker 如果正在执行任务是不会分配给其他任务的，这里之所以会阻塞是 @mogakun 所说那样，所以只需要设置一下 Pool 无可用 worker 时不阻塞即可：\r\n```go\r\np, _ := ants.NewPool(1, ants.WithNonblocking(true))\r\n```""",panjf2000,7496278,2021-11-23T05:45:15.000+00:00,2021-11-23T05:45:15.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3753,
976191730,1060770678,"""> 事实上 ants 并不禁止 Submit() 里再调用同一个 Pool 的 Submit()。\r\n> \r\n> > 另外初步分析了一下，Submit的task会被分配给pool中的worker。如果某个worker1执行task1，而task1又调用Submit task2，但task2恰好又被分给worker1，这样就锁住了。\r\n> \r\n> 其实这里的分析不正确，worker 如果正在执行任务是不会分配给其他任务的，这里之所以会阻塞是 @mogakun 所说那样，所以只需要设置一下 Pool 无可用 worker 时不阻塞即可：\r\n> \r\n> ```go\r\n> p, _ := ants.NewPool(1, ants.WithNonblocking(true))\r\n> ```\r\n\r\n这块感觉其实还是有些问题的。如果不设置ants.WithNonblocking(true)，我就是要阻塞。但这种阻塞应该是可以解开的。当task执行完毕后，自然可以空闲出一个goroutine来接新task。但问题就在于：如果我在Submit() 里再调用同一个 Pool 的 Submit()，一旦所有task都是这种情况，这个阻塞可能是无法解开的。\r\n\r\n因此，是不是需要在ants文档中明确一下：如果要在submit再调用同一个pool的submit，需要设置ants.WithNonblocking(true)，并注意Submit可能返回的错误并适当处理这个错误。\r\n""",bigwhite,419088,2021-11-23T06:11:54.000+00:00,2021-11-23T06:11:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3754,
976691772,1060770678,"""> > 事实上 ants 并不禁止 Submit() 里再调用同一个 Pool 的 Submit()。\r\n> > > 另外初步分析了一下，Submit的task会被分配给pool中的worker。如果某个worker1执行task1，而task1又调用Submit task2，但task2恰好又被分给worker1，这样就锁住了。\r\n> > \r\n> > \r\n> > 其实这里的分析不正确，worker 如果正在执行任务是不会分配给其他任务的，这里之所以会阻塞是 @mogakun 所说那样，所以只需要设置一下 Pool 无可用 worker 时不阻塞即可：\r\n> > ```go\r\n> > p, _ := ants.NewPool(1, ants.WithNonblocking(true))\r\n> > ```\r\n> \r\n> 这块感觉其实还是有些问题的。如果不设置ants.WithNonblocking(true)，我就是要阻塞。但这种阻塞应该是可以解开的。当task执行完毕后，自然可以空闲出一个goroutine来接新task。但问题就在于：如果我在Submit() 里再调用同一个 Pool 的 Submit()，一旦所有task都是这种情况，这个阻塞可能是无法解开的。\r\n> \r\n> 因此，是不是需要在ants文档中明确一下：如果要在submit再调用同一个pool的submit，需要设置ants.WithNonblocking(true)，并注意Submit可能返回的错误并适当处理这个错误。\r\n\r\n我在文档里说明下。""",panjf2000,7496278,2021-11-23T15:13:03.000+00:00,2021-11-23T15:13:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3755,
976729945,1058613251,"""这种情况是有可能的，因为 `Tune()` 函数只是原子地修改了内部的 `capacity` 变量，`Free()` 是通过计算 `capacity` - `Running()`，有可能你调用 `Tune()` 之后还有很多正在运行的 worker 没有退出，此时调用 `Free()` 就有可能返回负数，等到那些的 worker 执行完任务之后放回 pool，超出当前 `capacity` 的 worker 们将会自动退出，此时的 `Free()` 才是正确的数值。""",panjf2000,7496278,2021-11-23T15:35:10.000+00:00,2021-11-23T15:35:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3756,
1013246236,624854806,"""@1046102779 老哥，你是不是想让`ants`根据当前系统负载，自适应动态调节协程池的大小？\r\n顺便问下是否支持？@panjf2000""",dragon-zhang,38336731,2022-01-14T15:56:12.000+00:00,2022-01-14T15:57:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3785,
1019050551,1103820475,"""额，放着不管？@panjf2000""",dragon-zhang,38336731,2022-01-22T04:49:33.000+00:00,2022-01-22T04:49:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3786,
440541883,382574800,"""目前可以通过参数来传入处理失败的chan\r\n\r\ntype msg struct {\r\n……\r\nFailed chan<- *msg\r\n}\r\n\r\n// payload == &msg\r\npool,_:= NewPoolWithFunc(10,func(payload interface{}) error{\r\n……\r\n// 失败的话payload 发送到 Failed chan\r\n})\r\n\r\npool.Serve(msg)""",zplzpl,7931755,2018-11-21T05:57:51.000+00:00,2018-11-21T06:06:47.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3235,
440605531,382574800,"""> 目前可以通过参数来传入处理失败的chan\r\n> \r\n> type msg struct {\r\n> ……\r\n> Failed chan<- *msg\r\n> }\r\n> \r\n> // payload == &msg\r\n> pool,_:= NewPoolWithFunc(10,func(payload interface{}) error{\r\n> ……\r\n> // 失败的话payload 发送到 Failed chan\r\n> })\r\n> \r\n> pool.Serve(msg)\r\n\r\n我目前的做法是没有用 `NewPoolWithFunc()`，而是用的 `ants.NewPool()`，控制整个服务只有一个`pool`，所有的任务都是从大`pool`里取：\r\n\r\n```\r\nfunc (w *Worker) Register(fn func() error, opts ...Option) error {\r\n\t// w.Workers = append(w.Workers, runtime.FuncForPC(reflect.ValueOf(fn).Pointer()).Name())\r\n\top := Op{}\r\n\top.applyOpts(opts)\r\n\r\n\tif op.GoroutineSize <= 1 {\r\n\t\treturn w.Pool.Submit(fn)\r\n\t}\r\n\r\n\tfor i := 0; i < op.GoroutineSize; i++ {\r\n\t\tw.Pool.Submit(fn)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n```\r\n想基于这种方式来处理失败任务的逻辑。可有方式实现？\r\n\r\n还有任务依赖也是我面临的问题，比如A任务依赖其它N个任务执行完成或者必须执行成功/失败后，触发A任务。当然解决这个问题并非必须靠`ants`框架层面实现，也可以业务实现，如果`ants`框架层面能解决是最完美的。\r\n\r\n不知道你怎么认为。\r\n""",kklinan,5668717,2018-11-21T10:01:45.000+00:00,2018-11-21T10:24:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3236,
440876192,382574800,"""错误返回，按照ants的设计，其实应该是异步的，目前没办法直接return error到调用的函数里，所以我觉得就算是处理也应该是异步的方式；至于任务依赖，目前想到的有两种办法：1.回调函数；2.消息通知(通过channel或消息队列)，至于是不是要把这些复杂的逻辑加到ants里，有待商榷，或者你也可以推一个pr，大家一起探讨下~~""",panjf2000,7496278,2018-11-22T01:09:56.000+00:00,2018-11-22T01:09:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3237,
442366878,381941219,"""在 pool里面加上一个 waitgroup，每次 启动一个 work，调用 waitgroup.Add()，协程执行完了就执行waitgroup.Done()。在release时候调用waitgroup.Wait()。最后再回收空闲 worker。不过b如果 worker 对于的 func 执行时间过长，会导致release一直等待。""",hawklin2017,32898629,2018-11-28T08:48:17.000+00:00,2018-11-28T08:48:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3238,
445462719,388907811,"""你的go版本是多少？""",panjf2000,7496278,2018-12-08T14:20:26.000+00:00,2018-12-08T14:20:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3239,
445496131,388907811,"""go version go1.11.1 darwin/amd64\r\n\r\n我也尝试了将几个参数调小一点，结果都是 Semaphore 和 AntsPool 量级上都是差不多的""",huangjunwen,720086,2018-12-08T22:56:54.000+00:00,2018-12-08T22:56:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3240,
445815378,388907811,"""嗯，的确是一个量级。\r\nants的优势是：\r\n1. 内存消耗会小(并发量大的时候几乎可以节省一半的内存量)；\r\n2. goroutine常驻内存（定时清理长时间空置的goroutine，按最后使用时间排序，最久未使用的goroutine最先被清理，进一步降低资源消耗）；\r\n3. ants pool更加灵活可控，可动态调整pool size、手动销毁pool；\r\n4. 还有各类方法获取正在运行的goroutine数量、可用的goroutine数量，使并发程序更精确可控；\r\n......""",panjf2000,7496278,2018-12-10T13:30:04.000+00:00,2018-12-11T02:52:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3241,
446447291,388907811,"""好的，怎么样测试内存消耗呢？按我理解大家活跃的 go routines 是一样的数目，为什么 ants 的内存消耗会小呢？""",huangjunwen,720086,2018-12-12T03:18:44.000+00:00,2018-12-12T03:18:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3242,
446453643,388907811,"""加上benchmem=true参数；至于为什么内存会更小，是因为在pool里的goroutines是常驻内存的，新的任务是复用goroutine的，而用sema的话只是限制了活跃的goroutine数量，并没有复用，新的任务还是会生成新的goroutine。""",panjf2000,7496278,2018-12-12T03:58:29.000+00:00,2018-12-12T03:58:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3243,
456022133,401277739,"""合理的需求，可以加。我这两天加下。""",panjf2000,7496278,2019-01-21T10:21:24.000+00:00,2019-01-21T10:22:58.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3244,
456022560,401277739,"""你要有兴趣也可以自己做，然后提个PR。""",panjf2000,7496278,2019-01-21T10:22:39.000+00:00,2019-01-21T10:22:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3245,
459948887,405951301,"""@jiashiwen \r\nIt works on my side, pls make sure that you run the example on top of the latest ants code, thanks.""",panjf2000,7496278,2019-02-02T09:03:51.000+00:00,2019-02-02T09:04:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3252,
468919580,413968505,"""不会的，incRunning操作总是在比较大小之后才发生的。""",panjf2000,7496278,2019-03-02T13:14:05.000+00:00,2019-03-02T13:14:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3253,
471299071,419183961,"""server接收的并发请求量有多大？""",panjf2000,7496278,2019-03-10T13:18:01.000+00:00,2019-03-10T13:18:01.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3254,
471869506,419268851,"""加锁后资源消耗会增加，性能会下降很多，所以是加锁确保池数量还是不加锁保证性能呢？""",naiba,29243953,2019-03-12T06:06:39.000+00:00,2019-03-12T06:06:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3255,
1019052639,1103820475,"""ants 是一个用户态 goroutine pool，仅仅是做 goroutine 的复用，它不是调度器，这点先搞清楚，goroutine 的运行调度是由底层的 go runtime 做的，所以你这个问题本身就不成立。""",panjf2000,7496278,2022-01-22T04:58:08.000+00:00,2022-01-22T04:58:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3256,
1019053050,1108986026,"""用 channel 不就可以了？""",panjf2000,7496278,2022-01-22T04:59:36.000+00:00,2022-01-22T04:59:36.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3257,
1019278904,1103820475,"""感谢解答。根据`GMP模型`，调度时可能会重组`G和M的关系`，此时就会进行`协程上下文的重加载`(我把`协程上下文的重加载`称为`打断并恢复CPU计算`)，当执行`CPU密集型任务`时，`协程上下文的重加载`发生的次数应当`越少越好`(最好1次都没有)，`协程上下文的重加载`这个动作是`go runtime`做的，不是`ants`做的。这么理解，ok的吧""",dragon-zhang,38336731,2022-01-22T14:18:04.000+00:00,2022-01-22T14:18:04.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3258,
1019283076,1103820475,"""对""",panjf2000,7496278,2022-01-22T14:39:51.000+00:00,2022-01-22T14:39:51.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3259,
1032195630,1078047238,"""change wg.Add(2) to wg.Add(1) ,the program can shutdown when finished. i dont know how?\r\nwhen use wg.Add(i) i>1 then program hang forever!!!!!""",Phuong39,84000895,2022-02-08T04:12:40.000+00:00,2022-02-08T04:12:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3261,
1032238515,1078047238,"""实在抱歉，这个 issue 提出来的时候我比较忙，想着过几天再处理，然后就忘了这个事，今天有新评论我才看到消息提醒，等下我提一个修复，目前的版本要避免这个问题可以设置 [ants.WithNonblocking(true)](https://pkg.go.dev/github.com/panjf2000/ants/v2#WithNonblocking)。""",panjf2000,7496278,2022-02-08T05:50:28.000+00:00,2022-02-08T05:50:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3262,
1050746576,1142268611,"""Could you describe the process of this bug step by step?""",panjf2000,7496278,2022-02-25T10:50:44.000+00:00,2022-02-25T10:50:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3266,
1063743490,1047896477,"""u can try this：\r\nfirst u can declare a func() chan:\r\n\r\n> task:=make(chan func())\r\n\r\nthen use for range receive the task ：\r\n\r\n> go func() {\r\n>   for t:=range task {\r\n>      ants.Submit(t)\r\n>   }\r\n> }\r\n\r\n\r\nlast：\r\n\r\n> for _, row := range rows {\r\n>    f:=func() {\r\n>       user := User{}\r\n>       user.Name = row.Name\r\n>       user.Email = row.Email\r\n>       err := dm.Insert(&user)\r\n>       if err != nil {\r\n>          panic(err)\r\n>       }\r\n>       address := Address{}\r\n>       address.Address1 = row.Address1\r\n>       address.Address2 = row.Address2\r\n>       address.PinCode = row.PinCode\r\n>       address.City = row.City\r\n>       err := dm.Insert(&address)\r\n>       if err != nil {\r\n>         panic(err)\r\n>       }\r\n>      }\r\n>      task<- f\r\n>   }""",yunduansing,11469334,2022-03-10T07:27:10.000+00:00,2022-03-10T07:27:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3267,
1075721987,1174907155,"""Could you please provide a little bit more context to your question?""",timo-klarshift,1379383,2022-03-22T22:39:56.000+00:00,2022-03-22T22:39:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3268,
1075723836,1025263959,"""You can simply implement Pause() and Resume() in some wrapping code. Just keep track of the state (running & paused) and if paused stop submitting new tasks to the pool (or stop reading tasks from a channel). And after resuming continue to submit tasks to the pool...\r\nIMO this is userland logic and there is no need for this library to handle such things.""",timo-klarshift,1379383,2022-03-22T22:43:23.000+00:00,2022-03-22T22:43:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3269,
1092848029,1196996550,"""你这个写法就有问题，Submit 之后任务函数有可能马上就执行完成并调用 Done() 了，此时还没有 Add(1)，当然就会触发这个 panic，WaitGroup 的正确用法是提前 Add() 然后再启动 goroutine 去执行。""",panjf2000,7496278,2022-04-08T13:15:20.000+00:00,2022-04-08T13:16:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3270,
1092850392,1196996550,"""改成这样：\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\""fmt\""\r\n\t\""github.com/panjf2000/ants/v2\""\r\n\t\""sync\""\r\n)\r\n\r\nfunc main() {\r\n\tres := make([]string, 20)\r\n\tfor i := 0; i < 20; i++ {\r\n\t\tres[i] = \""a\""\r\n\t}\r\n\tids := make([]string, 0)\r\n\ttmp := make([]string, 0)\r\n\tvar w sync.WaitGroup\r\n\tvar mu sync.Mutex\r\n\tfor i, r := range res {\r\n\t\tids = append(ids, r)\r\n\t\tif len(ids) == 2 || i == len(res)-1 {\r\n\t\t\ttt := ids\r\n                         w.Add(1)\r\n\t\t\tif err := ants.Submit(func() {\r\n\t\t\t\tdefer w.Done()\r\n\r\n\t\t\t\tmu.Lock()\r\n\t\t\t\tdefer mu.Unlock()\r\n\t\t\t\ttmp = append(tmp, tt...)\r\n\t\t\t});err != nil {\r\n                                 w.Add(-1)\r\n\t\t\t\tfmt.Printf(\""err occur %v\\n\"", err.Error())\r\n\t\t\t}\r\n\t\t\r\n\t\t\tids = make([]string, 0)\r\n\t\t}\r\n\t}\r\n\tw.Wait()\r\n\tfmt.Println(\""finish\"")\r\n}\r\n\r\n```""",panjf2000,7496278,2022-04-08T13:17:44.000+00:00,2022-04-08T13:17:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3271,
1096091498,1201065478,"""My understanding from the docs is that, I need to set ants.WithExpiryDuration() to make sure that those finished routines are cleared out? """,FeurJak,77963837,2022-04-12T05:37:41.000+00:00,2022-04-12T05:37:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3272,
1096104522,1201065478,"""> My understanding from the docs is that, I need to set ants.WithExpiryDuration() to make sure that those finished routines are cleared out?\r\n\r\nYes, let's say you call WithExpiryDuration(500ms), then ants will check and find all those idle workers that haven't processed tasks in 500ms periodically (every 500ms).""",panjf2000,7496278,2022-04-12T05:48:20.000+00:00,2022-04-12T05:48:20.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3273,
1096107325,1201065478,"""@panjf2000  thank you!""",FeurJak,77963837,2022-04-12T05:50:28.000+00:00,2022-04-12T05:50:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3274,
1107862025,1210377843,"""There is no way to re-invoke a failed task, you can only call pool.Invoke() again.\r\nPanicHandler prevents the process from crashing from one panic in a task.""",panjf2000,7496278,2022-04-24T15:18:59.000+00:00,2022-04-24T15:18:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3275,
1114897184,1215362122,"""我正准备开源一个已经在公司项目上运行的worker，每秒钟处理 300k 的任务，起初尝试过 ants，不幸的是没能解决我们的问题，近期准备参考 ants 的性能测试，我使用了他们的 bench，在我的电脑上实测性能远不如原生goroutine\r\n\r\n```\r\ngoos: darwin\r\ngoarch: amd64\r\npkg: github.com/panjf2000/ants/v2\r\ncpu: Intel(R) Core(TM) i7-10700K CPU @ 3.80GHz\r\nBenchmarkGoroutines-16              \t       4\t 254623557 ns/op\t96722636 B/op\t 2006602 allocs/op\r\nBenchmarkSemaphore-16               \t       3\t 421790971 ns/op\t104132400 B/op\t 2001117 allocs/op\r\nBenchmarkAntsPool-16                \t       3\t 490805168 ns/op\t21124885 B/op\t 1074014 allocs/op\r\nBenchmarkGoroutinesThroughput-16    \t       6\t 224249557 ns/op\t78317890 B/op\t  977427 allocs/op\r\nBenchmarkSemaphoreThroughput-16     \t       3\t 357162050 ns/op\t95999589 B/op\t 1999994 allocs/op\r\nBenchmarkAntsPoolThroughput-16      \t       3\t 458327268 ns/op\t 3302698 B/op\t   51776 allocs/op\r\nPASS\r\nok  \tgithub.com/panjf2000/ants/v2\t15.715s\r\n```\r\n<img width=\""667\"" alt=\""image\"" src=\""https://user-images.githubusercontent.com/12491807/166241956-be48e4ec-8427-47a0-b70f-24d6e357269e.png\"">\r\n\r\n""",thinkeridea,12491807,2022-05-02T13:40:53.000+00:00,2022-05-02T13:40:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3276,
1118129709,1215362122,"""Duplicate with #166 """,panjf2000,7496278,2022-05-05T03:25:13.000+00:00,2022-05-05T03:25:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3277,
1118129889,1206125988,"""压测代码一直在 https://github.com/panjf2000/ants/blob/master/ants_benchmark_test.go""",panjf2000,7496278,2022-05-05T03:25:43.000+00:00,2022-05-05T03:25:43.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3278,
1118361972,898973379,"""期望可以暴露出来+1""",JasonJunjian,17464482,2022-05-05T09:40:28.000+00:00,2022-05-05T09:40:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3279,
1133593027,1243368453,"""代码贴一下。""",panjf2000,7496278,2022-05-21T10:05:48.000+00:00,2022-05-21T10:05:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3280,
1133846842,1244030382,"""为什么要这个东西，最大阻塞任务数量应该是要在一开始就确定好的，如果你想要运行新的任务，那再新建一个pool不就行了。""",panjf2000,7496278,2022-05-22T08:47:22.000+00:00,2022-05-22T08:47:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3281,
1133867882,1244030382,"""好吧. p.Tune(capSize) 的意义是?""",fufuok,4979407,2022-05-22T10:46:11.000+00:00,2022-05-22T10:46:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3282,
1139520237,1243368453,"""> \r\n抱歉 代码不方便贴出来\r\n相同代码 降了版本 是没有问题的""",zqlpaopao,43371021,2022-05-27T11:11:23.000+00:00,2022-05-27T11:11:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3283,
1149808788,1264107782,"""If you want to get the result from task that is submitted to pool, you can use `chan`.""",panjf2000,7496278,2022-06-08T11:43:42.000+00:00,2022-06-08T11:43:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3284,
1149810784,1262980710,"""https://pkg.go.dev/github.com/panjf2000/ants/v2#Pool.Running\r\nhttps://pkg.go.dev/github.com/panjf2000/ants/v2#Pool.Waiting""",panjf2000,7496278,2022-06-08T11:46:06.000+00:00,2022-06-08T11:46:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3285,
1149811404,1257847610,"""https://github.com/panjf2000/ants/actions/runs/2286692492\r\n\r\n测试到最新的 1.17 和 1.18，只是 README 没有更新而已。""",panjf2000,7496278,2022-06-08T11:46:51.000+00:00,2022-06-08T11:46:51.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3286,
471964821,419268851,"""并发量不大的情况下还是建议直接用goroutine，不然池化未必比裸用goroutine性能好，甚至会下降。""",panjf2000,7496278,2019-03-12T11:37:04.000+00:00,2019-03-12T11:37:04.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3287,
471966187,419268851,"""上面关于比较池容量跟运行中worker数量的问题怎么看 @panjf20002019年3月12日 19:37，Andy Pan <notifications@github.com>写道：并发量不大的情况下还是建议直接用goroutine，不然池化未必比裸用goroutine性能好，甚至会下降。\r\r\n\r\r\n—You are receiving this because you authored the thread.Reply to this email directly, view it on GitHub, or mute the thread.""",naiba,29243953,2019-03-12T11:42:03.000+00:00,2019-03-12T11:42:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3288,
471971816,419268851,"""那个compare操作的确不是原子操作，一种潜在的可能是：在比较过程中，某个worker结束任务了，把running数减一了，这可能导致pool有轻微的goroutine数量溢出。但是，\r\n\r\n第一，发生的概率很小而且也只会是轻微溢出，我觉得在容忍限度以内；\r\n\r\n第二， 如果要完全保证数据强正确的话，得再加锁，但这样不仅会让代码更加复杂，而且性能也会有比较大的下降，我觉得有点舍本逐末了。\r\n\r\n目前我没想到既能保证性能又能保证数值绝对正确的实现方法，这个我后续有空再思考下，要是你有好的方法的话也欢迎提个PR我们一起讨论下😀，我先把issue设置成enhancement，以后慢慢优化。""",panjf2000,7496278,2019-03-12T12:01:32.000+00:00,2019-08-19T09:03:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3289,
471971935,413968505,"""合并到#28""",panjf2000,7496278,2019-03-12T12:01:57.000+00:00,2019-03-12T12:01:57.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3290,
471982716,419268851,"""@panjf2000  我也没想到，哈哈，我试过了，加了锁内存跟时间都快赶上直接用原生了。我感觉这个也是可以接受的，发出来看你做的时候怎么想的2019年3月12日 20:01，Andy Pan <notifications@github.com>写道：那个compare操作的确不是原子操作，一种潜在的可能是：在比较过程中，某个worker结束任务了，把running数减一了，这可能导致pool有轻微的goroutine数量溢出。但是，第一，发生的可能性比较小而且也只会是轻微溢出，我觉得在容忍限度以内；第二， 如果要精确保证数据正确的话，得再加锁，这样不仅会让代码更加复杂，而且性能也会有比较大的下降，我觉得有点舍本逐末了。\r\n目前我没想到既能保证性能又能保证数值绝对正确的实现方法，这个我后续有空再思考下，要是你有好的方法的话也欢迎提个PR我们一起讨论下😀，我先把issue设置成enhancement，以后慢慢优化。\r\n\r\n—You are receiving this because you authored the thread.Reply to this email directly, view it on GitHub, or mute the thread.""",naiba,29243953,2019-03-12T12:37:59.000+00:00,2019-03-12T12:37:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3291,
473232809,419183961,"""我在本地测试  使用池比原生协程  内存占用低了 执行时间相对原生协程较慢""",jeevic,12953391,2019-03-15T10:20:44.000+00:00,2019-03-15T10:20:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3292,
476075983,424634533,"""@prprprus \r\nhttps://github.com/panjf2000/ants/blob/master/pool_func.go#L103, 是支持传参的。""",panjf2000,7496278,2019-03-25T06:53:00.000+00:00,2019-03-25T06:53:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3293,
476117883,424634533,"""好的, 一个参数, 了解""",prprprus,8509898,2019-03-25T09:32:02.000+00:00,2019-03-25T09:45:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3294,
480462070,429972115,"""`ants` is a pure lib of golang which didn't rely on any third-party libraries, so no need to use the go modules.""",panjf2000,7496278,2019-04-06T01:12:52.000+00:00,2019-04-06T01:14:01.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3296,
483496714,433564955,"""之前的tag的确不规范，以后我会尽量mini version里修改一些小问题，在major version里才会进行比较大的重构和变更，谢谢指出！""",panjf2000,7496278,2019-04-16T03:25:03.000+00:00,2019-04-16T03:25:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3297,
483919757,434069015,"""好的，我这两天弄下，谢谢！""",panjf2000,7496278,2019-04-17T03:07:16.000+00:00,2019-04-17T03:07:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3298,
485233937,435486645,"""Well done! Thanks~ 👏""",jjeffcaii,1284892,2019-04-21T08:17:12.000+00:00,2019-04-21T08:17:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3299,
485234062,364361014,"""@edcismybrother \r\nHello, 我需要清理下一个`ants`的tags, 不知道对你有没有影响，如果有的话请知悉，抱歉。具体细节可以看这里：#34""",panjf2000,7496278,2019-04-21T08:19:38.000+00:00,2019-04-21T08:19:58.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3300,
507207672,462631417,"""我现在随便运行什么 module 相关的命令都会报\r\n```\r\n➜  proxybase git:(master) ✗ go mod tidy\r\nverifying github.com/panjf2000/ants@v3.9.9+incompatible/go.mod: github.com/panjf2000/ants@v3.9.9+incompatible/go.mod: reading https://sum.golang.org/lookup/github.com/panjf2000/ants@v3.9.9+incompatible: 410 Gone\r\n```""",choleraehyq,8923413,2019-07-01T10:24:23.000+00:00,2019-07-01T10:24:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3301,
507213884,462631417,"""不知道什么地方的缓存缓存了个 3.9.9，我把 pkg/mod 都删了，还是会找到 3.9.9""",choleraehyq,8923413,2019-07-01T10:45:56.000+00:00,2019-07-01T10:45:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3302,
555435000,524906588,"""> go get -u github.com/panjf2000/ants/v2\r\n> \r\n> ```\r\n> package github.com/panjf2000/ants/v2: cannot find package \""github.com/panjf2000/ants/v2\"" in any of:\r\n>         /usr/local/go/src/github.com/panjf2000/ants/v2 (from $GOROOT)\r\n>         /Users/xxx/Desktop/go/gin/src/github.com/panjf2000/ants/v2 (from $GOPATH)\r\n> ```\r\n\r\n""",chinawangyu,10721527,2019-11-19T10:16:01.000+00:00,2019-11-19T10:16:01.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3400,
555562741,524907361,"""go modules 没打开吧？""",panjf2000,7496278,2019-11-19T15:35:40.000+00:00,2019-11-19T15:35:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3401,
555576387,524800426,"""首先谢谢提醒，其次，我知道 goroutine 并不是协程，从 goroutine 支持并行的就可以明确它不是协程了，只是当初在推广的时候为了让那些不熟悉 go 的人能有个粗浅的轮廓才这么写的，毕竟直接说 goroutine 很多人不熟悉，说实话的确是一种挺懒的做法。。。\r\n不过我最早的关于 `ants` 的博客已经写得很清楚了，goroutine 不是传统意义上的协程。\r\n\r\n不过你倒是提醒我了，README 里的这部分用语的确得更新一下了，到时候修正了之后我再 close 掉这个 issue。""",panjf2000,7496278,2019-11-19T16:04:17.000+00:00,2020-04-06T12:05:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3402,
556914736,524907361,"""看报错信息应该是 go mod 没打开，麻烦打开之后再试试，如果还有问题再 reopen 这个 issue，谢谢。""",panjf2000,7496278,2019-11-21T04:28:17.000+00:00,2019-11-21T04:28:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3403,
557487172,526983024,"""那你就把 import path 里的 v2 去掉就好了""",panjf2000,7496278,2019-11-22T10:54:21.000+00:00,2019-11-22T10:55:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3404,
559499531,529770094,"""The reason why I chose spinlock over mutex is that the goroutine would be put into wait queue and awaked when the mutex lock is released by another goroutine, but most of the cases using `ants` won't hold the lock for a long time, which makes all those actions of mutex worthless, so there will be a higher performance using spinlock.""",panjf2000,7496278,2019-11-28T13:43:35.000+00:00,2020-10-18T14:46:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3405,
560090835,530708513,"""@runner-mei \r\n1. taskinfo 完全可以你自己包在你的 func 里吧？我不觉得一定要让 `ants` 来做这件事的必要性；\r\n2. 就算有了 taskinfo，又要怎么才能知道是哪些 func 阻塞了？关于这一块的具体实现，你的想法是什么？""",panjf2000,7496278,2019-12-01T10:46:49.000+00:00,2019-12-01T10:46:49.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3407,
560092449,530708513,"""看了一下代码， 确实不需要, 你这个不是 job queue。\r\n你这个 submit 应该改个名， 叫 run 更好。 """,runner-mei,1052632,2019-12-01T11:01:12.000+00:00,2019-12-01T11:01:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3408,
560111615,530708513,"""取名字是个人风格的问题了，何况现在改名字会造成 API 向后不兼容，没必要。""",panjf2000,7496278,2019-12-01T13:59:08.000+00:00,2019-12-01T13:59:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3409,
560111792,529770094,"""@jjshi \r\nDo you still have questions about this? or other questions? If not, please close this issue, thanks!""",panjf2000,7496278,2019-12-01T14:00:41.000+00:00,2019-12-01T14:01:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3410,
560250020,524118492,"""也许这个对你有帮助：https://pkg.go.dev/github.com/changkun/sched/simsched?tab=doc#Trigger""",changkun,5498964,2019-12-02T06:19:07.000+00:00,2019-12-02T06:19:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3411,
561544474,529770094,"""thanks @panjf2000 """,jjshi,16028668,2019-12-04T09:05:31.000+00:00,2019-12-04T09:05:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3412,
565679559,537859668,"""首先，每个任务抢占的不是 w.task 这个 chan，抢占的是 w，每一个 w 只会处理一个 task；其次，`ants` 并不保证提交的任务的顺序，README里说明了：\r\n[about sequence](https://github.com/panjf2000/ants#%EF%B8%8F-about-sequence)""",panjf2000,7496278,2019-12-14T03:56:15.000+00:00,2019-12-14T06:05:43.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3413,
565685941,537859668,"""ok...没看readme""",nagasawaja,11144120,2019-12-14T05:32:52.000+00:00,2019-12-14T05:32:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3414,
565685947,537859668,"""thx""",nagasawaja,11144120,2019-12-14T05:33:00.000+00:00,2019-12-14T05:33:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3415,
566540312,538994753,"""NewPoolWithFunc()里的func，只能一个参数吗？""",bglmmz,9315278,2019-12-17T13:25:52.000+00:00,2019-12-17T13:25:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3416,
566855965,538994753,"""那个参数是 interface, 你要是想传多个参数的话，直接传一个 array 或者 slice 进去，然后在函数里还原一下不就行了吗？""",panjf2000,7496278,2019-12-18T03:53:06.000+00:00,2019-12-18T03:54:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3417,
566856147,538994753,"""> 在批量提交任务后，获取每个任务对应的返回值.\r\n\r\n提交任务之后是异步执行的，没法同步返回。""",panjf2000,7496278,2019-12-18T03:54:16.000+00:00,2019-12-18T03:54:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3418,
566856243,538994753,"""> 那个参数是 interface, 你要是想带多个的话，直接传一个 array 或者 slice 进去，然后在函数里还原一下不就行了吗？\r\n\r\n明白""",bglmmz,9315278,2019-12-18T03:54:53.000+00:00,2019-12-18T03:54:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3419,
566856493,538994753,"""还有关于多个参数的问题，其实也可以直接用那个无参的方法，然后你通过闭包引用的方式操作多个参数，还省去了转换的操作。""",panjf2000,7496278,2019-12-18T03:56:11.000+00:00,2019-12-18T03:56:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3420,
566856628,538994753,"""> 交任务之后是异步执行的，没法同步返回。\r\n\r\n现在这个工具把执行线程池化了，但是任务没有队列化吗？""",bglmmz,9315278,2019-12-18T03:56:56.000+00:00,2019-12-18T03:56:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3421,
566856963,538994753,"""如果我有100万个任务，如何用10个线程的线程池来异步执行呢？用ants.WithMaxBlockingTasks这参数？此参数设置100万？""",bglmmz,9315278,2019-12-18T03:58:54.000+00:00,2019-12-18T03:58:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3422,
566857287,538994753,"""你就直接设置 size=10 就行了。""",panjf2000,7496278,2019-12-18T04:00:42.000+00:00,2019-12-18T04:00:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3423,
566859694,538994753,"""> 你就直接设置 size=10 就行了。\r\n那剩下的任务都会阻塞着等待submit进去执行吗？""",bglmmz,9315278,2019-12-18T04:14:29.000+00:00,2019-12-18T04:14:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3424,
634689187,613752194,"""改完测试了一下，发现了还是有坑，Tune 把 unlimited pool 改成普通 pool 还好，但是反过来的话，如果当前已经有因为之前的 capacity 满了而阻塞住的 Submit，Tune 成 unlimited pool 之后，只对那些新的 Submit 生效，这些阻塞的 Submit 却还是会一直等到有空闲的 worker 才能返回，还是会有这些潜在的问题，所以暂时还是不支持了。""",panjf2000,7496278,2020-05-27T14:14:17.000+00:00,2020-05-27T14:14:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3497,
574977477,550305777,"""抱歉，我已经不在那里了。""",panjf2000,7496278,2020-01-16T04:32:10.000+00:00,2020-01-16T04:32:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3444,
575026878,524800426,"""@choleraehyq @panjf2000 请问为何说 goroutine 不是协程？如果 goroutine 不是，符合什么特征的可并发执行体可以被称之为协程？""",chengyayu,38727061,2020-01-16T07:48:42.000+00:00,2020-01-16T07:48:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3445,
576080422,551948830,"""It makes no sense to have such a queue inside `ants` cuz you were already submitting tasks to a queue in `ants` in a way so there is no need to add another queue. If you are worried about that the capacity of pool might be too small to receive your tasks, just increase the pool size and it will work.\r\n\r\nBesides, let's say we do add one more queue you are requesting, but that queue also need to set a size inside, so how much capacity do you want to set for it and what does `ants` do when you reach the capacity of the new queue again? returns nil or be blocked? Aren't we back to the original problem again?""",panjf2000,7496278,2020-01-20T02:22:17.000+00:00,2020-01-20T02:25:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3446,
576080572,551948830,"""#56 """,panjf2000,7496278,2020-01-20T02:23:17.000+00:00,2020-01-20T02:23:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3447,
576112988,551948830,"""(first post updated, template added)\r\nI saw your diagram (README) and realized how `ants` works.\r\n\r\n> If you are worried about that the capacity of pool might be too small to receive your tasks, just increase the pool size and it will work.\r\n\r\nConsider i've 20,000 heavy mathematics calculation and for a better performance, I have to do them two by two. So i should set the pool size to 2.\r\nFurthermore, As I said i've 20,000 tasks and i need to add all of them to queue at the same time.\r\nIn the current version i can't bulk add them to queue and i should wait for previous task completion to add a new task.\r\n\r\nBut about second part of your answer, You are right! `ants` doesn't have any unlimited pool with limited simultaneous process.""",ffb255,50948745,2020-01-20T05:30:19.000+00:00,2020-01-20T05:35:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3448,
576280851,551948830,"""interesting feature. so we have something like number of concurrent workers and pool size with number of items in wait state""",vtolstov,481307,2020-01-20T13:44:54.000+00:00,2020-01-20T13:44:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3449,
577711248,553711776,"""已解决。""",iiiusky,45157320,2020-01-23T14:43:32.000+00:00,2020-01-23T14:43:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3450,
596056743,576944665,"""不是很理解，能贴一下代码吗？""",panjf2000,7496278,2020-03-07T07:24:37.000+00:00,2020-03-07T07:24:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3452,
596492557,576944665,"""我自己的问题,忽略吧""",arch3754,16916249,2020-03-09T12:18:09.000+00:00,2020-03-09T12:18:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3453,
600419515,583444295,"""You can define a `struct` which contains all your args and use this struct as the single arg of `pf`, then restore it to struct from an interface in `pf` and you can get all args.\r\n\r\n@kungf """,panjf2000,7496278,2020-03-18T04:31:52.000+00:00,2020-03-18T04:31:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3454,
600445983,583444295,"""yes, this is what i first want resolution, but  the context arg was not suggested to put into struct, so a little complex \r\nhttps://groups.google.com/forum/#!topic/golang-nuts/xRbzq8yzKWI\r\n\r\n@panjf2000 """,kungf,24663329,2020-03-18T06:22:20.000+00:00,2020-03-18T06:22:20.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3455,
602373269,583444295,"""Then I'm out of solutions, maybe I should start considering refactor `pool_func` and make it accept variable arguments like `func NewPoolWithFunc(size int, pf func(...interface{}), options ...Option)`""",panjf2000,7496278,2020-03-23T04:03:17.000+00:00,2020-03-23T04:03:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3456,
606477228,590876739,"""你这个需求只能在你自己的 func 里用 timer + channel + signal 来解决了，或者利用 context 也可以做到，目前 ants 不支持这样的功能。""",panjf2000,7496278,2020-03-31T08:26:22.000+00:00,2020-03-31T10:26:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3457,
608329782,524800426,"""@choleraehyq @panjf2000   goroutine 是goroutine我知道，那么goroutine 是什么？\r\n\r\n""",kingreatwill,13087689,2020-04-03T09:21:53.000+00:00,2020-04-03T09:21:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3458,
609758185,524800426,"""![image](https://user-images.githubusercontent.com/7496278/78556577-cc0f8d00-7841-11ea-9ec4-1c5e5dc9ac25.png)\r\n\r\n最主要的区别是调度方式，一个是协作式，一个是抢占式，而且本质上协程做不到并行，只能是并发，还有就是协程并不需要同步原语：锁、信号量等这些，因为不存在临界区。\r\n\r\n至于说 goroutine 到底是什么，我个人觉得可以称之为**轻量的用户级线程**。\r\n\r\n@chengyayu @kingreatwill """,panjf2000,7496278,2020-04-06T12:16:45.000+00:00,2020-04-06T12:17:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3459,
609827621,590876739,"""查了些资料，goroutine好像是没办法中断的。""",bglmmz,9315278,2020-04-06T14:25:18.000+00:00,2020-04-06T14:25:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3460,
610121569,524800426,"""好的谢谢！官网确实明确说明了\r\n![image](https://user-images.githubusercontent.com/13087689/78620179-dd907d80-78b1-11ea-872d-8ef805f5a9fa.png)\r\n""",kingreatwill,13087689,2020-04-07T01:27:12.000+00:00,2020-04-07T01:27:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3461,
612632281,598491535,"""如果这个 option 为 true，那么当所有 workers 都在忙的时候，直接返回 `ErrPoolOverload ` 错误告诉你 pool 满了，而不是像默认的那样阻塞在 Submit 方法那里。""",panjf2000,7496278,2020-04-12T15:20:06.000+00:00,2020-04-12T15:20:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3462,
612632707,598490848,"""See #3 """,panjf2000,7496278,2020-04-12T15:23:14.000+00:00,2020-04-12T15:23:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3463,
612637181,598491535,"""我说错了，默认是的是false,为阻塞""",zjytra,21356664,2020-04-12T15:55:32.000+00:00,2020-04-12T15:55:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3464,
612852214,598516739,"""调用 Release 之后，会把当前空闲的 workers 释放掉，但是还在执行任务的则会在结束任务之后自动释放掉，我觉得这样就可以了，没必要强制结束正在运行的 workers，你的提议和目前的架构差别有点大，暂时不考虑，谢谢！""",panjf2000,7496278,2020-04-13T10:53:23.000+00:00,2020-04-13T10:53:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3465,
636458357,624852492,"""太长时间没回复，暂时关闭该 issue，如果还有问题可以重新打开。""",panjf2000,7496278,2020-05-31T11:29:10.000+00:00,2020-05-31T11:29:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3498,
636458384,624854806,"""太长时间没回复，暂时关闭该 issue，如果还有问题可以重新打开。""",panjf2000,7496278,2020-05-31T11:29:23.000+00:00,2020-05-31T11:29:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3499,
637506335,629156928,"""It's unnecessary to use `ants` in `fasthttp` because there is already a [goroutine pool](https://github.com/valyala/fasthttp/blob/master/workerpool.go) in `fasthttp` which is also the prototype of `ants`, so using `ants` with `fasthttp` makes no improvement but performance loss.""",panjf2000,7496278,2020-06-02T12:23:00.000+00:00,2020-06-02T12:52:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3500,
637648486,629156928,"""I guess the WorkerPool in fasthttp is for Server use only. So this would not help solving the task.\r\n\r\n> workerPool serves incoming connections via a pool of workers\r\n> in FILO order, i.e. the most recently stopped worker will serve the next\r\n> incoming connection.""",T200proX7,57217666,2020-06-02T16:03:33.000+00:00,2020-06-02T16:03:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3501,
638530710,629156928,"""Sorry, I didn't check out the problem carefully before and thought you were talking about the server-side, have you tried not to use `ants` pool and what's the memory usage of that kind of situation? \r\n\r\nIf the memory usage is still high, it probably has nothing to do with `ants`.""",panjf2000,7496278,2020-06-04T00:32:50.000+00:00,2020-06-04T00:32:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3502,
638631067,630445612,"""context""",chenjsa,2267537,2020-06-04T06:28:55.000+00:00,2020-06-04T06:28:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3503,
638741976,630445612,"""context是可以派生的。 父context被终止或者超时，会传导下去。""",solarhell,10279583,2020-06-04T09:44:02.000+00:00,2020-06-04T09:44:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3504,
638755992,630445612,"""自己在routine里监听呀 就是那个select case 然后对应清理 return 不就是关掉了routine吗""",solarhell,10279583,2020-06-04T10:11:17.000+00:00,2020-06-04T10:11:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3505,
638763750,630445612,"""你这个问题和 `ants` 有什么关系？\r\n@resct """,panjf2000,7496278,2020-06-04T10:27:45.000+00:00,2020-06-04T10:27:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3506,
638777956,630445612,"""> ants中有相关对groutine的API操作吗？ 有相关知识可以分享的吗？\r\n\r\n`ants` 是一个 worker 模式的 goroutine pool，适用场景是大量的一次性任务，每个任务会附到一个 worker 里去执行，你的需求和 `ants` 没啥关系，你需要在 goroutine 里监听等待主进程的信号，也就是说会长时阻塞等待，那也是类似 worker 模式了，这种任务就不适宜提交到 `ants` 里了，worker 套 worker，没有意义，利用 buffered channel 做一下简单的限制 goroutine 数量就行了。\r\n\r\n正如我前面所说，`ants` 并不是操作控制 goroutine 的库，仅仅是执行提交的任务，再说了，文档里有所有的接口，你如果看完就可以知道是没有什么控制 goroutine 的 API 的，所以你这问题的确和 `ants` 没有关系，我准备关掉了。\r\n\r\n至于你说的控制 goroutine，前面已经有同学回答你了，Context 可以做到，但是你一直说想直接 kill 掉，那你就用信号去做吧，go 也有相关的标准库可以用，直接 google 一下就行。\r\n\r\n最后，下次这种技术问题请直接到相关的论坛/社区去提问，Github issue 是用来解决开源库相关问题的，不是泛技术问题的讨论区。\r\n\r\n@resct """,panjf2000,7496278,2020-06-04T10:59:16.000+00:00,2020-06-04T11:00:20.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3507,
638785286,629156928,"""I tried now to use it without `ants` pool and yes memory was the same, maybe a little bit higher. But from the logic side it must be higher without a pool, since the pool is to manage jobs one by one for each worker (limited to the worker). Based on my code with 25 workers the memory should be very less. (One job done and canceled, worker takes next job) \r\n\r\nCalling `go processRow(current)` is like a rush without a stop or limit - its a more high concurrency than with a 25 worker pool. The job is done with `go processRow()` in 1/10 of the time of using `ants`. But on the other side i had to increase the `ulimit` very high to avoid `too many sockets open` error message. it is kind of unmanaged.\r\n\r\nSo im not sure what and why.. even with `ants` i had the `too many sockets open` error, so maybe ants did not manage the jobs correct? Im not sure, i am not a very experienced go programmer. """,T200proX7,57217666,2020-06-04T11:16:49.000+00:00,2020-06-04T11:16:49.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3508,
638792635,629156928,"""There is no way that `ants` doesn't control the concurrent amount correctly, what version of `ants` were you using? \r\n\r\nYou can add some debug code into your `ants` function and count how many sockets are opened by your program at the same time. Did you close any socket after a task is done strictly?""",panjf2000,7496278,2020-06-04T11:33:43.000+00:00,2020-06-04T11:35:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3509,
638850897,630445612,"""> > ants中有相关对groutine的API操作吗？ 有相关知识可以分享的吗？\r\n> \r\n> `ants` 是一个 worker 模式的 goroutine pool，适用场景是大量的一次性任务，每个任务会附到一个 worker 里去执行，你的需求和 `ants` 没啥关系，你需要在 goroutine 里监听等待主进程的信号，也就是说会长时阻塞等待，那也是类似 worker 模式了，这种任务就不适宜提交到 `ants` 里了，worker 套 worker，没有意义，利用 buffered channel 做一下简单的限制 goroutine 数量就行了。\r\n> \r\n> 正如我前面所说，`ants` 并不是操作控制 goroutine 的库，仅仅是执行提交的任务，再说了，文档里有所有的接口，你如果看完就可以知道是没有什么控制 goroutine 的 API 的，所以你这问题的确和 `ants` 没有关系，我准备关掉了。\r\n> \r\n> 至于你说的控制 goroutine，前面已经有同学回答你了，Context 可以做到，但是你一直说想直接 kill 掉，那你就用信号去做吧，go 也有相关的标准库可以用，直接 google 一下就行。\r\n> \r\n> 最后，下次这种技术问题请直接到相关的论坛/社区去提问，Github issue 是用来解决开源库相关问题的，不是泛技术问题的讨论区。\r\n> \r\n> @resct\r\n\r\n好的，感谢！！！""",resct,59554835,2020-06-04T13:34:28.000+00:00,2020-06-04T13:34:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3510,
793333676,823817947,"""> 这个操作只能在具体的Task里去执行done吧，如果在invoke上下文进行add和done的话，Task如果执行时间稍微长点，那wait结束的时候，并未真正执行完\r\n> \r\n> ```go\r\n> for ... {\r\n>     wg.Add(1)\r\n>     p.Invoke(args)\r\n>     wg.Done()\r\n> }\r\n> wg.Wait()\r\n> ```\r\n\r\n不是很懂你的意思""",panjf2000,7496278,2021-03-09T03:40:16.000+00:00,2021-03-09T03:40:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3612,
793333782,823817947,"""另外，把 wg.Done() 放在 Task 里有什么问题？""",panjf2000,7496278,2021-03-09T03:40:23.000+00:00,2021-03-09T03:40:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3613,
613426240,599450188,"""You should fill out the template of the bug report, now you just erase it and add your info, which puts me in the position of not knowing anything about your local environment.\r\n\r\nI don't even know what OS you were running on, what version of `ants` you were using, etc.""",panjf2000,7496278,2020-04-14T12:56:25.000+00:00,2020-04-14T12:56:25.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3466,
613558912,551948830,"""According to the author's idea, `ants` only provide a pool, the queue should be written by the user, or use another package. """,HaoKunT,16379361,2020-04-14T16:55:34.000+00:00,2020-04-14T16:55:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3467,
618783043,551948830,"""@ffb255 \r\nantspool is a goroutine worker pool, you should manage jobs by yourself, such as using queue to store them and pop them into worker pool.\r\n\r\n I think this maybe what you need.\r\nhttps://github.com/lacdon/gopool""",zichenglang,39049159,2020-04-24T03:34:50.000+00:00,2020-04-24T03:34:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3471,
619351493,551948830,"""@zichenglang After opening this issue, I wrote my own in-memory queue which works inside `ants`.""",ffb255,50948745,2020-04-25T09:38:42.000+00:00,2020-04-25T09:38:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3472,
619697493,607208427,"""Which version of `ants` were you using? There is already no `Serve` method in v2, it is `Invoke` now, please read the doc more carefully.""",panjf2000,7496278,2020-04-27T03:47:29.000+00:00,2020-04-27T03:47:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3473,
619698249,607208427,"""BTY, you are using `ants` in a wrong way, there is no need to submit a task to pool in a new goroutine, you're already using a goroutine pool, why did you still have to use `go` to submit task to pool, it makes no sense here, just call pool.Invoke directly.""",panjf2000,7496278,2020-04-27T03:50:35.000+00:00,2020-04-27T03:50:35.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3474,
619777775,607208427,"""Thanks for quick response. Ants provides a great experience when writing concurrent code. \r\nI have another question,\r\nif Myfunc has more than one parameters, how should I call `myPool, _ := ants.NewPoolWithFunc(3, Myfunc)`?\r\nI checked the declaration of NewPoolWithFunc, it seems like `pf `only accept one parameter.\r\n\r\n> func NewPoolWithFunc(size int, pf func(interface{}), options ...Option) \r\n\r\nthanks in advance\r\n\r\n```\r\nimport (\r\n\t\""fmt\""\r\n\t\""strconv\""\r\n\t\""time\""\r\n\t\""github.com/panjf2000/ants/v2\""\r\n)\r\n\r\n\r\nvar tunnel = make(chan string, 1)\r\nfunc main() {\r\n\r\n\t//push something to tunnel\r\n\r\n\tmyPool, _ := ants.NewPoolWithFunc(3, Myfunc)\r\n\tdefer myPool.Release()\r\n\r\n\tfor {\r\n\t\tselect {\r\n\t\tcase a := <-tunnel:\r\n\t\t\tmyPool.Invoke(a)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```""",huangp0600,8937150,2020-04-27T07:09:40.000+00:00,2020-04-27T07:09:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3475,
619843294,607208427,"""#81 """,panjf2000,7496278,2020-04-27T09:09:18.000+00:00,2020-04-27T09:09:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3476,
625366009,613752194,"""往 Pool 里投放任务的时候加锁也就是在获取可用 worker 的期间，获取到 worker 之后锁就释放了，任务执行期间是无锁的，所以就算是嵌套使用 Pool 也不会发生循环等待，不应该会有死锁吧？""",panjf2000,7496278,2020-05-07T16:39:40.000+00:00,2020-05-07T16:39:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3482,
625370874,613752194,"""我捋了一下，你说的应该是 worker 在执行嵌套使用 Pool 的任务之时，Pool 满了之后 worker 一直等待自身完成的死循环吧，这个的确是一个潜在的问题。\r\n\r\n不过我在想，既然 Pool 都没有限制了，那为什么不直接不用 Pool 呢？无限制的 Pool 本身的概念是有点自相矛盾的。""",panjf2000,7496278,2020-05-07T16:48:41.000+00:00,2020-05-07T16:49:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3483,
625610468,613752194,"""@panjf2000 并不矛盾，pool 是用来复用 goroutine 的，而不完全是用来控制并发的。""",choleraehyq,8923413,2020-05-08T03:29:04.000+00:00,2020-05-08T03:29:04.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3484,
625623188,613752194,"""也有道理，我找时间做一下。""",panjf2000,7496278,2020-05-08T04:27:40.000+00:00,2020-05-08T04:27:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3485,
634006925,624854806,"""`ants` 有提供动态调整 pool capacity 的接口啊：https://github.com/panjf2000/ants#tune-pool-capacity-in-runtime""",panjf2000,7496278,2020-05-26T12:55:49.000+00:00,2020-05-26T12:55:49.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3490,
634021888,624852492,"""> 1. PoolWithFunc希望能够支持任务池的名称；这样一个server存在多个任务池，方便定位问题；\r\n\r\n加名字具体怎么帮助你定位问题？你是想在 worker 发生 panic 之后打印的 log 里打印出名字？\r\n\r\n> 2. PoolWithFunc中的Invoke方法返回error，希望能区分是非阻塞队列任务池满的error msg，还是阻塞队列都满的error msg错误区分，目前笼统地称为：ErrPoolOverload, 这个不太方便定位问题。\r\n\r\n阻塞池满了是会一直阻塞的，除非你设置了 MaxBlockingTasks\r\n""",panjf2000,7496278,2020-05-26T13:23:09.000+00:00,2020-05-26T13:23:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3491,
634462653,613752194,"""@panjf2000 看了下改动，跟 Tune() 接口是不兼容的？""",choleraehyq,8923413,2020-05-27T06:44:32.000+00:00,2020-05-27T06:44:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3492,
634512157,613752194,"""什么意思？你还想通过 `Tune(int)` 把 unlimited 给 revert 了？""",panjf2000,7496278,2020-05-27T08:30:36.000+00:00,2020-05-27T08:30:36.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3493,
634536041,613752194,"""文档里并没说 Tune 跟 unlimited 怎么交互啊。没准会有人用 Tune 搞一个负数。""",choleraehyq,8923413,2020-05-27T09:16:22.000+00:00,2020-05-27T09:16:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3494,
634549674,613752194,"""哦，你是说想通过 Tune 来把一个普通的 pool 设置成 unlimited，这个我觉得还是不要支持了，unlimited 特性就只通过 NewPool 这一个唯一的入口来设置，规范一点。\r\n我等下在补充一下 Tune 的说明，把 unlimited 的设置说一下。""",panjf2000,7496278,2020-05-27T09:42:08.000+00:00,2020-05-27T09:42:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3495,
634660471,613752194,"""我又想了一下，支持通过 Tune 来设置 unlimited 似乎会灵活很多，也没我之前想的那样可能会导致很多问题，所以我决定还是支持调用 Tune(size int) 来控制 unlimited 特性，size <= 0 就把 pool 设置成 unlimited，size > 0 则把 unlimited pool 变回普通的 pool""",panjf2000,7496278,2020-05-27T13:26:44.000+00:00,2020-05-27T13:26:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3496,
639780661,629156928,"""Not just willing i would appreciate it much - so i even can learn. I will send it to you by email in a few minutes. Already now i wanna thank you.""",T200proX7,57217666,2020-06-05T20:22:07.000+00:00,2020-06-05T20:22:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3521,
643590232,638116396,"""Does #49 help?""",panjf2000,7496278,2020-06-13T08:21:02.000+00:00,2020-06-13T08:21:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3522,
643600956,638116396,"""Thank you so much.\r\n\r\n`go clean -modcache`\r\n\r\nworks nicely! :tada: """,navid-kalaei,7106251,2020-06-13T10:01:31.000+00:00,2020-06-13T10:01:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3523,
644509882,638596333,"""> Why can't we tune the pool if it is preallocated?\r\n\r\nBecause supporting `Tune(int)` under `Pre-Alloc` mode will result in allocating a vast amount of new memories and copying a large number of workers, not reusing memories like the non-preallocate mode.""",panjf2000,7496278,2020-06-16T03:29:30.000+00:00,2020-06-16T03:29:30.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3524,
649468395,524118492,"""这么复杂的场景直接用消息队列不香吗？""",tmpbook,1560985,2020-06-25T10:58:34.000+00:00,2020-06-25T10:58:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3525,
650901664,524118492,"""@tmpbook 这跟消息队列没啥关系""",choleraehyq,8923413,2020-06-29T04:45:33.000+00:00,2020-06-29T04:45:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3526,
658098646,656493889,"""1. ants.Release() 是释放内置的 pool，不需要每次都调用，你要是不想用内置 pool 直接调用一次就行；\r\n2. 每次请求都要创建 pool，goroutine 数量多也很正常吧，一般来说这种 pool 应该搞成一个全局的，所有请求共享。""",panjf2000,7496278,2020-07-14T10:17:50.000+00:00,2020-07-14T10:17:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3527,
658103867,656493889,"""全局的话 试着放到init里面 貌似不行 而且全局的话 里面需要一个func\r\n就算每次创建 不是有过期回收的机制么(本地压测貌似是这样的) 但是出问题的场景 线上 通过看grafada就是一直增长的 还有刷pprof 也是缓慢增长的 按道理夜里没请求了 也应该下降啊.""",weichangdong,2841874,2020-07-14T10:30:07.000+00:00,2020-07-14T10:32:15.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3528,
658106207,656493889,"""> 全局的话 试着放到init里面 貌似不行 而且全局的话 里面需要一个func\r\n\r\n你直接用那个不需要 func 的 pool 就行了\r\n\r\n> 就算每次创建 不是有过期回收的机制么(本地压测貌似是这样的) 但是出问题的场景 线上 通过看grafada就是一直增长的 还有刷pprof 也是缓慢增长的 按道理夜里没请求了 也应该下降啊.\r\n\r\n定时清理默认是清理超过十秒没有被使用过的 workers，还是说你自己重置了这个时间？你可以写个简单的 demo 测试一下，看看定时清理有没有生效，还是说有 bug？总之先测试一下吧。""",panjf2000,7496278,2020-07-14T10:35:48.000+00:00,2020-07-14T10:35:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3529,
658111988,656493889,"""谢谢了 我换那个不需要func的那个吧 \r\n清理的 我没有自定义时间 默认的1秒吧""",weichangdong,2841874,2020-07-14T10:50:32.000+00:00,2020-07-14T10:50:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3530,
661837752,662892614,"""把多个参数放到一个 struct 里，然后把这个 struct 转成 interface，可以解决你的需求吗？""",panjf2000,7496278,2020-07-21T12:47:17.000+00:00,2020-07-21T12:47:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3533,
662937966,662892614,"""可以的""",tsxylhs,20257788,2020-07-23T10:43:58.000+00:00,2020-07-23T10:43:58.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3534,
662937981,662892614,"""可以的""",tsxylhs,20257788,2020-07-23T10:44:00.000+00:00,2020-07-23T10:44:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3535,
663499049,662892614,"""动态化参数的需求一般是希望传递多个参数到 pool，目前这个需求可以通过上面所说的方式满足，短期内暂时不会支持动态化参数，因为这个会导致接口变更，按照开源软件版本更迭的规范，不向后兼容的接口变更需要升级到下一个大版本，目前 `ants` 并没有大的功能特性更新，所以不考虑升级到下一个大版本，这个功能等到下一个大版本升级的时候再带上。""",panjf2000,7496278,2020-07-24T11:42:48.000+00:00,2020-07-24T11:42:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3536,
667649819,671575307,"""你理解错了，只有在整个 worker goroutine 退出的时候才会放到 sync.Pool 里，而不是每次执行 task 之后都会放到 sync.Pool，看清楚，这部分逻辑是在 defer 里的。""",panjf2000,7496278,2020-08-02T09:20:20.000+00:00,2020-08-02T09:20:20.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3537,
671150816,675845276,"""@panjf2000""",Xuzan9396,24741439,2020-08-10T03:49:21.000+00:00,2020-08-10T03:49:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3539,
671186601,675845276,"""\r\n![image](https://user-images.githubusercontent.com/24741439/89756650-c25ea480-db15-11ea-9d5b-8fda4bf6dfaa.png)\r\n\r\n## 执行结果\r\n\r\n![image](https://user-images.githubusercontent.com/24741439/89756892-4add4500-db16-11ea-8718-a99e383cb9ec.png)\r\n""",Xuzan9396,24741439,2020-08-10T06:32:24.000+00:00,2020-08-10T06:32:24.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3540,
671211775,675845276,"""#96 \r\n\r\n這邊可能有你需要的""",mikeqoo1,30303712,2020-08-10T07:49:42.000+00:00,2020-08-10T07:49:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3541,
671229198,675845276,"""`ExpiryDuration` 不是你理解的意思，这个参数表示的是 `ants` 定时清理长时间未使用的 worker，比如设置 `ExpiryDuration` 为 1 0 秒，代表内部会每过 10s 清理一遍，检查每个超过 10s 没使用过的 worker，可能是注释的意思有歧义，我等会儿更新下代码注释。""",panjf2000,7496278,2020-08-10T08:33:18.000+00:00,2020-08-10T08:33:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3542,
671230783,675830456,"""http 标准库的确是每一个连接用一个 goroutine 去处理，这里使用 ants 的确没有太大的意义，README 里的例子我也在考虑移除掉，等会儿一起更新了吧。""",panjf2000,7496278,2020-08-10T08:37:13.000+00:00,2020-08-10T08:37:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3543,
671669234,675845276,"""好的 @panjf2000 """,Xuzan9396,24741439,2020-08-11T01:19:29.000+00:00,2020-08-11T01:19:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3544,
678579993,683789291,"""提问题选对模板，这是提新功能的模板。\r\n\r\n还有，问题描述得具体点。""",panjf2000,7496278,2020-08-22T02:11:27.000+00:00,2020-08-22T02:11:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3545,
680239088,583444295,"""@panjf2000 could use this method?\r\n```go\r\nfor j := 0; j < batchCount; j++ {\r\n\t\tbj:=j\r\n\t\troutinePoll.Submit(func() {\r\n\t\t\tgenBucketBatch(bj)\r\n\t\t})\r\n }\r\n```""",davidxiaozhi,6194818,2020-08-25T19:58:32.000+00:00,2020-08-29T10:56:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3546,
683274001,583444295,"""I don't quite get your point, what did you want to ask exactly? Is your question related to this issue? if not, please open your own issue.\r\n\r\n@davidxiaozhi """,panjf2000,7496278,2020-08-29T10:58:12.000+00:00,2020-08-29T10:58:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3550,
687019357,692140116,"""goroutine底层的GPM模型有没有实现多路复用的可能？""",xiangjihan,3070542,2020-09-04T08:56:12.000+00:00,2020-09-04T08:56:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3551,
691603808,700343813,"""You should call `pool.Submit` in different goroutines to get the expected result of `WithMaxBlockingTasks`, otherwise, if you call it serially as you did with a for loop in one goroutine, it just processes one by one.""",panjf2000,7496278,2020-09-13T03:37:50.000+00:00,2020-09-14T07:27:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3552,
691704609,700343813,"""Oh indeed, simply changing my example fixed it:\r\n\r\n```\r\ngo func() {\r\n  err := p.Submit(func() {\r\n   wg.Add(1)\r\n   time.Sleep(time.Second)\r\n   wg.Done()\r\n  })\r\n  if err != nil {\r\n     // I expect this to have an error if i >= 2\r\n  }\r\n}()\r\n```\r\n\r\nThank you.""",polds,2372558,2020-09-13T18:10:09.000+00:00,2020-09-13T18:10:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3553,
708564540,719788673,"""最早的时候的确是基于性能的考量而选择手动 unlock，不过正如你说的，defer 后来的版本里的性能的确有了很大的提升，现在也不是很有必要为了性能而手动 unlock 了，不过手动 unlock 有一个好处就是能够更细粒度地控制锁的范围，所以如果没有特别的必要，暂时还是保持现状吧。""",panjf2000,7496278,2020-10-14T17:56:28.000+00:00,2020-10-14T17:56:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3560,
708866178,719993557,"""#114""",Mutated1994,29589055,2020-10-15T03:06:09.000+00:00,2020-10-15T03:06:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3562,
709895821,722994544,"""Tonight.""",panjf2000,7496278,2020-10-16T08:09:10.000+00:00,2020-10-16T08:09:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3566,
709898581,722994544,"""> Tonight.\r\n\r\nThanks！""",Mutated1994,29589055,2020-10-16T08:14:43.000+00:00,2020-10-16T08:14:43.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3567,
711190470,724008505,"""#65 """,panjf2000,7496278,2020-10-18T14:46:48.000+00:00,2020-10-18T14:46:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3568,
711200320,724008505,"""thanks""",imxyb,7411249,2020-10-18T14:59:15.000+00:00,2020-10-18T14:59:15.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3569,
711256098,724008505,"""其实我还有个疑问，golang目前的互斥锁似乎有一段是代码是先自旋几次，如果依然没有抢到锁才会进行睡眠，所以其实改了影响也不大？这里是go官方增加了spin lock的commit https://github.com/golang/go/commit/edcad8639a902741dc49f77d000ed62b0cc6956f""",imxyb,7411249,2020-10-18T16:03:27.000+00:00,2020-10-18T16:03:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3571,
716578783,729205618,"""Please add more details like example code.""",panjf2000,7496278,2020-10-26T14:21:28.000+00:00,2020-10-26T14:21:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3573,
717803968,731239827,"""现在已经支持了 https://github.com/panjf2000/ants#tune-pool-capacity-in-runtime""",panjf2000,7496278,2020-10-28T09:18:39.000+00:00,2020-10-28T09:18:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3574,
717805047,730161470,"""你这是属于 GC 的范畴了，目前 go 的 GC 可调参数只有一个 GOGC 环境变量，你可以去按你的需求调节。""",panjf2000,7496278,2020-10-28T09:20:39.000+00:00,2020-10-28T09:20:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3575,
719450284,730161470,"""GC 触发条件\r\n1> 当前内存分配达到一定比例则触发\r\n2> 2 分钟没有触发过 GC 则触发 GC\r\n3> 手动触发，调用 runtime.GC()""",jiangjiali,7267234,2020-10-30T09:41:28.000+00:00,2020-10-30T09:41:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3576,
723075982,737434903,"""保存 NewPool 是什么意思？""",panjf2000,7496278,2020-11-06T13:17:45.000+00:00,2020-11-06T13:17:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3577,
723079419,737043014,"""My benchmark results are a long time ago and the `go` runtime has been evolving during all the time, `go` is getting more and more performant, also, adding more and more functionalities into `ants` might have slowed it down.""",panjf2000,7496278,2020-11-06T13:25:31.000+00:00,2020-11-06T13:25:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3578,
723080245,736200176,"""pool 的自动扩缩容？什么意思？""",panjf2000,7496278,2020-11-06T13:27:25.000+00:00,2020-11-06T13:27:25.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3579,
723110730,737434903,"""就是使用全局变量存储goroutine pool------------------&nbsp;原始邮件&nbsp;------------------\r\n发件人:&nbsp;&quot;Andy&amp;nbsp;Pan&quot;<notifications@github.com&gt;\r\n发送时间:&nbsp;2020年11月6日(星期五) 晚上9:18\r\n收件人:&nbsp;&quot;panjf2000/ants&quot;<ants@noreply.github.com&gt;;\r\n抄送:&nbsp;&quot;zsj&quot;<1043247956@qq.com&gt;;&quot;Author&quot;<author@noreply.github.com&gt;;\r\n主题:&nbsp;Re: [panjf2000/ants] 可以使用全局变量 保存 NewPool么？ (#124)""",foreverZSJ,14883130,2020-11-06T14:31:05.000+00:00,2020-11-06T14:31:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3580,
723379772,737434903,"""这个pool本来就是应该是全局变量啊，pool不就是设计来供多线程并发使用的吗？""",panjf2000,7496278,2020-11-07T02:52:49.000+00:00,2020-11-07T02:52:49.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3581,
723393271,738173237,"""Please don't put the description in the issue title directly, which makes the issue title tedious.\r\n\r\nFigure out the difference between title and description and put them in the right place separately.""",panjf2000,7496278,2020-11-07T05:10:33.000+00:00,2020-11-07T05:10:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3582,
723572473,736200176,"""pool 在特定的情况扩大池的容量，容量被扩大了之后，闲置时再又缩小池的容量。""",PPeacHH,42341553,2020-11-08T12:43:26.000+00:00,2020-11-08T12:43:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3583,
723572948,736200176,"""> pool 在特定的情况扩大池的容量，容量被扩大了之后，闲置时再又缩小池的容量。\r\n\r\npool.Tune(int) 不就是来做这样的事情的吗？我还是没搞懂你的问题到底是什么？""",panjf2000,7496278,2020-11-08T12:47:38.000+00:00,2020-11-08T12:47:38.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3584,
723793942,736200176,"""我的问题就是想确认pool.Tune(int)是不是可以做这样的事：\r\n\r\n> pool 在特定的情况扩大池的容量，容量被扩大了之后，闲置时再又缩小池的容量。\r\n\r\n你的回复已经回答了我的问题，谢谢！我当时在demo里没找到关于这个方法的使用例子，然后你的另一个开源项目gnet中也没用到它，我的同事对这个方法表示存疑，我自己是测试过了的，但我还是提出了这样一个问题🤣。""",PPeacHH,42341553,2020-11-09T06:35:00.000+00:00,2020-11-09T06:35:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3585,
725778775,737434903,"""还有问题吗？""",panjf2000,7496278,2020-11-12T02:00:29.000+00:00,2020-11-12T02:00:29.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3586,
725781467,741209727,"""@panjf2000 """,Xuzan9396,24741439,2020-11-12T02:08:33.000+00:00,2020-11-12T02:08:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3587,
725786582,737434903,"""谢谢！暂时没有了。咱们有技术交流群吗？\r\n\r\n\r\n\r\n\r\n------------------&nbsp;原始邮件&nbsp;------------------\r\n发件人: \""Andy Pan\""<notifications@github.com&gt;; \r\n发送时间: 2020年11月12日(星期四) 上午10:00\r\n收件人: \""panjf2000/ants\""<ants@noreply.github.com&gt;; \r\n抄送: \""~~\""<1043247956@qq.com&gt;; \""Author\""<author@noreply.github.com&gt;; \r\n主题: Re: [panjf2000/ants] 可以使用全局变量 保存 NewPool么？ (#124)\r\n\r\n\r\n\r\n\r\n\r\n \r\n还有问题吗？\r\n \r\n—\r\nYou are receiving this because you authored the thread.\r\nReply to this email directly, view it on GitHub, or unsubscribe.""",foreverZSJ,14883130,2020-11-12T02:24:30.000+00:00,2020-11-12T02:24:30.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3588,
726050702,737434903,"""暂时没有。\r\n可以到 https://gitter.im/gnet-io/gnet 讨论。\r\n这个 issue 我就先关掉了哈~""",panjf2000,7496278,2020-11-12T12:34:23.000+00:00,2020-11-12T12:34:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3589,
726052213,741209727,"""这是两种不同的 pool 的使用方式，前一个是不带参数的函数提交到 pool，后一个是提交带参数的函数的 pool，只不过前一个使用的 ants 默认的 pool，ants 会初始化一个默认的 pool，用户可以直接用，也可以自己调用 NewPool 初始化一个。""",panjf2000,7496278,2020-11-12T12:37:28.000+00:00,2020-11-12T12:37:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3590,
727123237,737043014,"""Although `ants` may not beat `go` anymore, I think it's still a good choice to save the system resource and who knows, maybe in the future day I would refactor `ants` to improve its performance, making `ants` reaching `go`, even beat it again, so just stay tuned haha.\r\n\r\nI am closing this issue, for now, thanks for bringing this up by the way.""",panjf2000,7496278,2020-11-14T02:23:44.000+00:00,2020-11-22T07:19:49.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3591,
729514264,741209727,"""明白""",Xuzan9396,24741439,2020-11-18T08:15:23.000+00:00,2020-11-18T08:15:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3592,
733812122,583444295,"""> @panjf2000 could use this method?\r\n> \r\n> ```go\r\n> for j := 0; j < batchCount; j++ {\r\n> \t\tbj:=j\r\n> \t\troutinePoll.Submit(func() {\r\n> \t\t\tgenBucketBatch(bj)\r\n> \t\t})\r\n>  }\r\n> ```\r\nthat works for me, thk~\r\n\r\n""",robin0323,3340345,2020-11-25T16:27:50.000+00:00,2020-11-25T16:27:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3593,
737121500,755047477,"""利用 context 机制，ants应该没有提供主动关闭协程的方法""",zu1k,42370281,2020-12-02T09:54:56.000+00:00,2020-12-02T09:55:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3594,
737126909,755047477,"""> 利用 context 机制，ants应该没有提供主动关闭协程的方法\r\n\r\n但是执行到一半的情况下，是收不到context的信号的啊，只有for循环触发select那种任务才能收到信号""",lwydyby,30611869,2020-12-02T10:04:13.000+00:00,2020-12-02T10:04:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3595,
737167574,755047477,"""> > 利用 context 机制，ants应该没有提供主动关闭协程的方法\r\n> \r\n> 但是执行到一半的情况下，是收不到context的信号的啊，只有for循环触发select那种任务才能收到信号\r\n\r\n不就是应该 for select嘛，没听说有什么外部的方法可以去干预一个goroutine""",zu1k,42370281,2020-12-02T11:20:17.000+00:00,2020-12-02T11:20:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3596,
739116562,755047477,"""你说那种场景只有操作系统和硬件中断能做，比如线程切换/信号量以及硬件中断信号，那样才可能中止任务并封存上下文，转而去执行其他任务，goroutine甚至是线程都属于用户层面的，最合理的方式就是通过 context + select，如果你非要在任意时刻结束goroutine，就用信号量吧，不过个人不推荐。""",panjf2000,7496278,2020-12-05T03:33:10.000+00:00,2020-12-05T03:33:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3597,
742601029,583444295,"""> Then I'm out of solutions, maybe I should start considering refactor `pool_func` and make it accept variable arguments like `func NewPoolWithFunc(size int, pf func(...interface{}), options ...Option)`\r\n\r\nI have the same problem with args and it would be better if it was ...interface{} instead of interface{}.\r\nAre you gonna fix it?\r\nIf not i will have to look for an alternative.\r\nthank you in advance""",mohammad-babaei,35062696,2020-12-10T15:41:37.000+00:00,2020-12-10T15:41:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3598,
749371830,772339531,""" context 可以處理 #96  #105  都有類似的需求 最近的在  #129 """,mikeqoo1,30303712,2020-12-22T06:34:37.000+00:00,2020-12-22T06:34:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3599,
757586539,738173237,"""websocket is not good use ant""",mi4tin,10191442,2021-01-11T01:50:12.000+00:00,2021-01-11T01:50:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3601,
787578554,818372401,"""https://pkg.go.dev/github.com/panjf2000/ants/v2#WithPanicHandler""",panjf2000,7496278,2021-03-01T01:43:56.000+00:00,2021-03-01T01:43:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3602,
787583209,818082145,"""先用 go mod 下载，然后用 go mod vendor""",panjf2000,7496278,2021-03-01T02:00:01.000+00:00,2021-03-01T02:00:01.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3603,
787933293,818372401,"""Possible to show example code for the usage of the function for reference? so as to get the potential of what we can do with this ants.\r\n\r\nthx for the software.""",hiqsociety,51492452,2021-03-01T13:04:09.000+00:00,2021-03-01T13:04:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3604,
787945171,818372401,"""https://github.com/panjf2000/ants/blob/94a7a7f1cb3a11fcaaf9608c94fe1dc0bcd98ab0/ants_test.go#L238-L268""",panjf2000,7496278,2021-03-01T13:22:51.000+00:00,2021-03-01T13:23:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3605,
788096235,818372401,"""ok thx!""",hiqsociety,51492452,2021-03-01T16:44:24.000+00:00,2021-03-01T16:44:24.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3606,
790201343,821650908,"""just found out there's Cap() function. Great.""",hiqsociety,51492452,2021-03-04T01:04:21.000+00:00,2021-03-04T01:04:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3608,
792758418,823817947,"""还是用 waitgroup，循环里每次 Add(1) 不就行了？""",panjf2000,7496278,2021-03-08T13:32:07.000+00:00,2021-03-08T13:32:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3609,
793296384,823817947,"""这个操作只能在具体的Task里去执行done吧，如果在invoke上下文进行add和done的话，Task如果执行时间稍微长点，那wait结束的时候，并未真正执行完\r\n\r\n```golang\r\n\r\nfor ... {\r\n    wg.Add(1)\r\n    p.Invoke(args)\r\n    wg.Done()\r\n}\r\nwg.Wait()\r\n```\r\n\r\n\r\n\r\n""",mayouzi,18528873,2021-03-09T02:49:27.000+00:00,2021-03-09T02:49:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3611,
403177663,339004478,"""你好，我刚刚在自己的机器上又试了一下，这是结果：\r\n![image](https://user-images.githubusercontent.com/7496278/42405000-08a2cc46-81c2-11e8-83e1-b17c21d7ec20.png)\r\n\r\n我设置的1000w的量。事实上这个库在100w任务量的时候速度基本是和原生并发持平的（当然ants会有比较大的内存优势），甚至多次测试可能还有落后的情况，100w以下的量就基本要落后于原生并发了，因为ants其实就是利用了超大规模的go程对Go调度器造成的调度压力过大而进行资源复用得以提高性能，如果任务量不大的话Go调度器完全可以应付得过来，相反ants还要进行一些初始化和复用就显得有点多余了，1000w的话ants的性能优势就体现出来了。\r\n\r\n另外，我记得刚开始测试的时候1000w任务量原生并发的时间基本都是往40s以上走的了，但是最近测试也有发现现在基本都在30s以下，有时候甚至在20s多，基本就比ants多几秒而已，不知道是不是和我升级了go版本有关，还有方便提供下你的机器参数和go版本吗？等我最近有时间再研究下性能测试，还有，感谢反馈哦🙂，有兴趣的随时交流哈。""",panjf2000,7496278,2018-07-07T00:55:16.000+00:00,2018-07-07T01:00:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3156,
403183446,339004478,"""![image](https://user-images.githubusercontent.com/3971390/42405792-d26453a4-81ce-11e8-9062-4ba8caae5181.png)\r\n![image](https://user-images.githubusercontent.com/3971390/42405795-d9084bac-81ce-11e8-8258-a8fa4235e82d.png)\r\ngolang版本是1.10.3 在windows上测试。\r\n````bash\r\n➜  ants git:(master) go test -v\r\n=== RUN   TestDefaultPool\r\n--- PASS: TestDefaultPool (6.79s)\r\n\tants_test.go:51: running workers number:37796\r\n\tants_test.go:54: memory usage:190 MB\r\n=== RUN   TestNoPool\r\n--- PASS: TestNoPool (5.88s)\r\n\tants_test.go:70: memory usage:832 MB\r\nPASS\r\nok  \tgithub.com/panjf2000/ants\t12.700s\r\n````\r\ngolang版本 1.10.1 在 mac上测试\r\n测试的都是1000w\r\n换到mac上依然是内存占用少，但是时间上并没有提升\r\nhttps://www.reddit.com/r/golang/comments/7p9juk/how_to_reuserepurpose_goroutines/\r\n我在reddit上看到了这个。\r\nStarting goroutines and just letting them end is generally simpler and faster than trying to do pooling yourself.\r\n\r\nUnlike GC for memory objects, where the end-of-life is only determined during a mark-and-sweep phase, the end-of-life for goroutines is obvious once the function returns. In that situation, the runtime actually puts the goroutine stack in an internal pool. New goroutines are actually sourced from that pool.\r\n\r\nWriting your own pool is likely to be slower and have edge cases that causes it to perform terribly.\r\ngoroutine 生命周期和一个对象的生命周期不同，可能不是按照CG回收规则来回收的。\r\n在golang层面已经有一个内部的回收池，新建的goroutine从内部里取。如果自己实现pool很有可能会慢一点。\r\n\r\n但是这个帖子后面也有人说复用goroutine会更快。\r\n\r\n从你的测试结果来看，pool创建了更多的goroutine。只要数量足够多，那并发计算下来时间可能会更少。我猜测，只是猜测，可能由于我CPU更快一些，所以大量复用goroutine，产生争抢情况，复用的瓶颈影响了性能。所以时间更多一些，而你也许CPU稍微慢一点，计算周期长，所以开了大量的goroutine，所以综合来看复用的更少在执行时间上，就更短了。\r\n\r\n希望和你共同讨论一下。共勉。""",ppmoon,3971390,2018-07-07T02:47:38.000+00:00,2018-07-07T02:47:38.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3157,
403184069,339004478,"""👍分析的不错，但关于复用的问题，事实上Go调度器的确有一个复用机制，每次使用`go`关键字的时候它会检查当前结构体M中的P中，是否有可用的结构体G。如果有，则直接从中取一个，否则，需要分配一个新的结构体G。如果分配了新的G，需要将它挂到runtime的相关队列中，但是调度器却没有限制goroutine的数量，这在瞬时性goroutine爆发的场景下就可能来不及复用G而依然创建了大量的goroutine，所以`ants`除了复用还做了限制goroutine数量。\r\n\r\n所以，`ants`主要是做了数量限制，没有可用的go程就等待而不是和Go调度一样直接新开一个go程，所以我觉得在超大规模下复用还是对性能有所提升的，现在看来goroutine调度这一块还是很复杂啊，看来我也得再继续研究研究看看还有啥可以挖掘的，可以keep in touch到时候有啥心得可以互通有无哈哈😆""",panjf2000,7496278,2018-07-07T03:01:52.000+00:00,2018-07-07T03:01:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3158,
404420879,340102987,"""会有这种可能，但我觉得执行保护其实更应该由具体业务自己来保证的，都丢给library不现实，代码规范还是要有。""",panjf2000,7496278,2018-07-12T07:45:53.000+00:00,2018-07-12T07:45:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3159,
407621670,344278000,"""`container/list` 这个我可以替换测试下 🛩 """,barryz,16658738,2018-07-25T03:26:00.000+00:00,2018-07-25T03:26:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3160,
407622001,344278000,"""链表的性能会比较好吗？我没测试过，你可以改一下测一下，如果性能的确有提升可以提个PR""",panjf2000,7496278,2018-07-25T03:28:15.000+00:00,2018-07-25T03:28:15.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3161,
409800144,346842831,"""这里freeSignal和idleWorkers的数量是绝对匹配的，也就是说，只要freeSignal有值那么idleWorkers里肯定有可用worker可以取出来，putWorker就是把可用worker放回idleWorkers，每次都会塞一个值进freeSignal，还有每次从idleWorkers里取一个worker都要取出freeSignal对应的一个值，不存在有可用worker却被freeSignal阻塞""",panjf2000,7496278,2018-08-02T04:13:09.000+00:00,2018-08-02T04:13:09.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3166,
410141732,347255859,"""切片如下\r\n\r\n这里等待锁\r\n9913 @ 0x42c73a 0x42c7ee 0x43cf64 0x43cc7d 0x46dfe8 0x7b28e0 0x7b2be5 0x4591f1\r\n#\t0x43cc7c\tsync.runtime_SemacquireMutex+0x3c\t\t\t\tE:/go/src/runtime/sema.go:71\r\n#\t0x46dfe7\tsync.(*Mutex).Lock+0x107\t\t\t\t\tE:/go/src/sync/mutex.go:134\r\n#\t0x7b28df\tmp/vendor/github.com/panjf2000/ants.(*Pool).putWorker+0x6f\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:229\r\n#\t0x7b2be4\tmp/vendor/github.com/panjf2000/ants.(*Worker).run.func1+0x54\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/worker.go:53\r\n\r\n\r\n//这里占用了锁无法释放\r\n1 @ 0x42c73a 0x42c7ee 0x404212 0x403ecb 0x7b27df 0x7b23e2 0x7f694a 0x7f68e1 0x4591f1\r\n#\t0x7b27de\tmp/vendor/github.com/panjf2000/ants.(*Pool).getWorker+0x22e\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:199\r\n#\t0x7b23e1\tmp/vendor/github.com/panjf2000/ants.(*Pool).Submit+0x61\t\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:125\r\n\r\n\r\n""",lovelly,13118848,2018-08-03T04:33:23.000+00:00,2018-08-03T04:35:30.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3167,
410143221,347255859,"""加了锁之后有下标溢出了。。。\r\npanic: runtime error: index out of range\r\n\r\ngoroutine 7 [running]:\r\nmp/vendor/github.com/panjf2000/ants.(*Pool).getWorker(0xc4200b6460, 0xc4202a6e01)\r\n\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:213 +0x2ce\r\nmp/vendor/github.com/panjf2000/ants.(*Pool).Submit(0xc4200b6460, 0xc4223d47d0, 0x0, 0x0)\r\n\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:125 +0x62\r\n""",lovelly,13118848,2018-08-03T04:46:13.000+00:00,2018-08-03T04:46:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3168,
410147487,347255859,"""@lovelly 我查了源码，怎么行数和你说的有点对不上，你的代码更新到最新了吗？""",panjf2000,7496278,2018-08-03T05:21:03.000+00:00,2018-08-03T05:21:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3169,
410170764,347255859,"""是最新的代码，我有添加一些print 所以行数不一样，这确实是一个bug 9913个协程阻塞在了 putWorker 很久很久。，。。。""",lovelly,13118848,2018-08-03T07:33:21.000+00:00,2018-08-03T07:33:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3170,
410173358,347255859,"""![image](https://user-images.githubusercontent.com/13118848/43630582-44f48000-9733-11e8-936d-9cb0d4145204.png)\r\n 我idleWorkers 为空的， 但是我有n个协程阻塞在了 204行的\t<-p.freeSignal， 这时候来了一个worker被放入idleWorkers， 很巧的是一个协程在putWorker结束锁后，在190行的p.lock.Lock()拿到了锁，这时候 n := len(idleWorkers) - 1 结果是0 这个协程很高兴的进入了接下来的else分支, 然而不幸发生了，p.freeSignal的信号确被早已等在 204行的若干个协程中的一个拿走了， 那么 可怜的协程拿到了锁， 确无法等到 p.freeSignal  p.freeSignal要拿到锁才能产生信号， 然后就。，。。""",lovelly,13118848,2018-08-03T07:44:32.000+00:00,2018-08-03T12:57:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3171,
410204870,347255859,"""@lovelly 检查了一下，的确可能会有这个问题，这两天我会修复；\r\n另外，我测试的时候试过1000w的量都没发现过这个问题，可能是我每个任务的执行时间太短了，所以我想问下你的任务量有多大以及每个任务的耗时大概是多少？""",panjf2000,7496278,2018-08-03T09:51:15.000+00:00,2018-08-03T09:52:04.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3172,
410205295,347255859,"""我任务耗时从0秒到60秒之间。。。""",lovelly,13118848,2018-08-03T09:53:00.000+00:00,2018-08-03T09:53:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3173,
410267195,347255859,"""@lovelly 应该已经修复了，可以再试试""",panjf2000,7496278,2018-08-03T14:15:45.000+00:00,2018-08-03T14:15:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3174,
410290418,346842831,"""具体问题可以看 #6 """,panjf2000,7496278,2018-08-03T15:32:00.000+00:00,2018-08-03T15:32:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3175,
411342200,348630179,"""@huiwq1990 谢谢指出，今天会修复这个问题。""",panjf2000,7496278,2018-08-08T09:17:30.000+00:00,2018-08-08T09:17:30.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3176,
411369513,348630179,"""@huiwq1990 应该解决了，可以再试试""",panjf2000,7496278,2018-08-08T11:06:55.000+00:00,2018-08-08T11:06:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3177,
411965696,348630179,"""嗯，解决了""",huiwq1990,4555057,2018-08-10T03:35:53.000+00:00,2018-08-10T03:35:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3178,
411969260,348630179,"""@huiwq1990 好的，那我关掉这个issue了。""",panjf2000,7496278,2018-08-10T04:06:04.000+00:00,2018-08-10T04:06:04.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3179,
418287926,356703393,"""会导致很多任务长时间在阻塞，至于cpu飙升应该不会""",panjf2000,7496278,2018-09-04T08:40:06.000+00:00,2018-09-04T08:40:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3184,
418290090,356703393,"""所以应该在goroutine中调用submit 否则会阻塞主任务""",Moonlight-Zhao,11763614,2018-09-04T08:47:39.000+00:00,2018-09-04T08:47:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3185,
418293975,356703393,"""不是的，如果每一个submit都用一个goroutine那不就违背初衷了吗，这样的话你有多少个任务还是要启动多少个原生goroutine。""",panjf2000,7496278,2018-09-04T09:00:55.000+00:00,2018-09-04T09:00:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3186,
507602622,462631417,"""真是对不起，因为初期的时候没有严格规划好版本号的迭代，导致版本号混乱，后来想规范起来，所以就清空了以前的tag，详情可以看这里#34，这是我的问题，抱歉。\r\n\r\n一开始也考虑到现有用户的影响，但是也只发了一个issue声明，因为没其他途径可以联系用户，以后会严格按照规范来迭代tag，绝对不会再发生这种事了，再次抱歉！\r\n\r\ncache的问题，试试`go clean --modcache`？""",panjf2000,7496278,2019-07-02T09:42:31.000+00:00,2019-07-02T10:17:31.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3303,
522419364,402513849,"""这个需求很痛，现在如果想做熔断、限流一类的逻辑要在 pool 外面再包一层，其实完全可以在 pool 里做。\r\n\r\n@panjf2000 我理解加个配置项，直接在 retrieveWorker 里面 reentry 那个分支判断一下然后返回 nil，Submit 里加一下对 retrieveWorker 返回值的判断就可以了？如果没什么问题我来搞一下""",choleraehyq,8923413,2019-08-19T05:35:45.000+00:00,2019-08-19T05:35:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3318,
522479163,402513849,"""大体思路应该是这样没错，我以前觉得熔断or限流这个逻辑应该在业务层实现，保持library的generality，不过好像有不少人都提出希望把这个feature加入到lib里，现在想想，熔断这个feature放到business或者放到library，貌似两个都能说得通。\r\n\r\nSo，你有时间的话提个PR吧，然后我再review一下，thanks~🤝""",panjf2000,7496278,2019-08-19T09:00:25.000+00:00,2019-08-19T11:04:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3319,
522580793,402513849,"""这里我觉得应该在 pool 里实现，主要是因为目前 pool 没有任何接口能让我了解现在的拥塞状况，调用了 Submit 之后就直接卡在里面了；Running 和 Cap 之类的也不大准确，对于瞬间的突发流量没法用 Running 来衡量压力。""",choleraehyq,8923413,2019-08-19T13:41:41.000+00:00,2019-08-19T13:41:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3320,
523268001,483164833,"""另外，按照 go module 的约定，发 v2 大版本应当直接搞一个新的包，panjf2000/ants/v2，而不是发一个 tag v2.0.0。建议改一下""",choleraehyq,8923413,2019-08-21T02:22:37.000+00:00,2019-08-21T02:22:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3325,
523271963,483164833,"""用 functional options 的话，可能就不需要发布v2了，我看下，thanks.""",panjf2000,7496278,2019-08-21T02:43:08.000+00:00,2019-08-21T02:43:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3326,
523484220,483164833,"""Resolved in [v1.3.0](https://github.com/panjf2000/ants/tree/v1.3.0)""",panjf2000,7496278,2019-08-21T14:32:48.000+00:00,2019-08-21T14:32:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3327,
523903838,483736247,"""Already released a v2 module `ants`, closing this issue.""",panjf2000,7496278,2019-08-22T13:22:10.000+00:00,2019-08-22T13:22:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3328,
524605390,484311063,"""Already resolved it.""",panjf2000,7496278,2019-08-25T06:36:14.000+00:00,2019-08-25T06:36:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3329,
524630798,484923460,"""这个看你业务场景，一般来说如果是任务数量大（频繁地使用worker）且每个任务耗时比较短的，这个值可以设置得大一些，避免过于频繁地检查和清理worker，反之则可以酌情设置得大一些。""",panjf2000,7496278,2019-08-25T13:32:28.000+00:00,2019-08-25T13:32:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3330,
525125663,485565755,"""@choleraehyq \r\n那个应该是被自动删的，之前在解决 v1.1.0 -> v1.2.0 的不兼容更新的时候对现有的 git commits 做了一些移动，alpha 那个 tag 里面的一些 commits 应该也被移动了，然后在原有的基础上新加了两个 tags：rc.1 和 rc.2，最后就 force push 了。""",panjf2000,7496278,2019-08-27T03:53:04.000+00:00,2019-08-27T04:29:20.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3331,
525126170,485565755,"""我刚才看了下，github 上的 release 好像变成 draft 了，我再给你们把 alpha 加回去吧，不过现在只能基于移动 commits 之后的某个 commit 了，和之前代码不太一样了，不过还是兼容的，你们的代码不需要改动，抱歉。""",panjf2000,7496278,2019-08-27T03:55:50.000+00:00,2019-08-27T04:30:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3332,
525139850,485565755,"""@choleraehyq \r\nResolved in [v2.0.0-alpha](https://github.com/panjf2000/ants/tree/v2.0.0-alpha)""",panjf2000,7496278,2019-08-27T05:10:32.000+00:00,2019-08-27T05:10:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3333,
530314213,492130196,"""为什么要设置`New`，我想不到有什么必要性。""",panjf2000,7496278,2019-09-11T10:07:16.000+00:00,2019-09-11T10:07:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3338,
530322641,492130196,"""这个算是个风格问题吧，设了 New 你就不需要写 \r\n```\r\nif cacheWorker := p.workerCache.Get(); cacheWorker != nil {\r\n\t\t\tw = cacheWorker.(*goWorkerWithFunc)\r\n\t\t} else {\r\n\t\t\tw = &goWorkerWithFunc{\r\n\t\t\t\tpool: p,\r\n\t\t\t\targs: make(chan interface{}, workerChanCap),\r\n\t\t\t}\r\n\t\t}\r\n```\r\n了。我是觉得既然用了 Pool，那用 New 就很自然，像现在这种代码会让人费解，会让人怀疑是不是别的地方会把 nil put 到 Pool 里。""",choleraehyq,8923413,2019-09-11T10:32:57.000+00:00,2019-09-11T10:32:57.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3339,
530350659,492130196,"""哦，你说的是这个意思啊，是这样的，设置了`New`之后，调用`workerCache.get()`无法从代码结构上知道得到的 worker 是缓存的还是新建的，这不用`New`而用 if else 之前是想着后面可能会在这个 if 判断的不同分支里做一些其他的东西（虽然到现在好像也还没想到有什么可做的东西），所以其实我倒觉得无所谓了，两种做法都 ok 😂""",panjf2000,7496278,2019-09-11T12:06:18.000+00:00,2019-09-11T12:11:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3340,
530371396,492130196,"""ok， 那我就 close""",choleraehyq,8923413,2019-09-11T13:06:46.000+00:00,2019-09-11T13:06:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3341,
530692575,491601411,"""@im-kulikov \r\nThanks for reporting this issue and providing the solution, it seems that `go clean -modcache` is the only way to resolve this issue for now, right? \r\nBut still, I don't know why this is happening, do you? by any chance?""",panjf2000,7496278,2019-09-12T06:55:30.000+00:00,2019-09-12T08:15:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3346,
546658796,491601411,"""```\r\ngo: downloading github.com/panjf2000/ants v1.2.0\r\ngo: downloading github.com/panjf2000/ants/v2 v2.2.2\r\nverifying github.com/panjf2000/ants@v1.2.0: checksum mismatch\r\n        downloaded: h1:Ufw4aDz9RqH1RVblx2W9L9Uv5vSX5apbX5+peR7LQ5k=\r\n        sum.golang.org: h1:pMQ1/XpSgnWx3ro4y1xr/uA3jXUsTuAaU3Dm0JjwggE=\r\n\r\nSECURITY ERROR\r\nThis download does NOT match the one reported by the checksum server.\r\nThe bits may have been replaced on the origin server, or an attacker may\r\nhave intercepted the download attempt.\r\n\r\nFor more information, see 'go help module-auth'.\r\n```""",r6c,45527749,2019-10-27T03:37:10.000+00:00,2019-10-27T03:37:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3374,
530695578,491601411,"""> @im-kulikov\r\n> Thanks for reporting this issue and providing the solution, it seems that `go clean -modcache` is the only way to resolve this issue, right?\r\n> But still, I don't know why this is happening, do you? by any chance?\r\n\r\n@panjf2000 yeah, this solution works for me (macOS), for Linux:\r\n- `cd /another/path`\r\n- `go clean -modcache`\r\n- `cd /project/path`\r\n- `go mod tidy`\r\n\r\n> But still, I don't know why this is happening, do you? by any chance?\r\n\r\nsomething similar has already happened with go1.10 and go1.11\r\n\r\nI attached issue from golang repo, mb someone can help with additional info""",im-kulikov,888650,2019-09-12T07:06:18.000+00:00,2019-09-12T07:06:18.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3347,
530718761,491601411,"""Got it, thanks~""",panjf2000,7496278,2019-09-12T08:17:44.000+00:00,2019-09-12T08:17:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3348,
542759198,429972115,"""I think it is better to use go mod since a user can import it directly without 'go get'.""",aetherwu,1645472,2019-10-16T15:30:45.000+00:00,2019-10-16T15:30:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3360,
542978614,429972115,"""`ants` was already available as go module, you can find the go.mod under its root.""",panjf2000,7496278,2019-10-17T03:11:29.000+00:00,2019-10-17T03:12:19.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3361,
544222997,509545524,"""> 但是有应用的情况是处理数据时有顺序关系\r\n\r\n是我理解有误吗？你这不是串行任务吗？那为什么要用并发来处理，如果是串行的用并发没意义啊，直接单线程处理。""",panjf2000,7496278,2019-10-20T05:47:41.000+00:00,2019-10-20T05:47:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3363,
544242132,509545524,"""一个例子:\r\n一个tcp server,每个socket都可以接收不同的数据包(业务/task)A1,A2,A3,A4,A5, B1,B2,B3,C1,C2,C3,\r\n但是接收并不一定是那么规则,可以是A1,A2,A3,B1,C1,B2,B3,A4,A5,C2,C3,\r\n对于同一个系列当然是串行,A2必须在A1处理完之后处理,C2必须在C1后处理,但是Ax,By,Cz之间是不冲突的,\r\n如果有SumbitQueue,则可以很简化处理.\r\n""",yangjuncode,47293522,2019-10-20T11:04:45.000+00:00,2019-10-20T11:04:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3364,
544245716,509545524,"""用户场景我了解了，但是你期待的解决方案我不是清楚，能具体描述一下吗？或者贴点伪代码看看？\r\n\r\n另外，下次提 issue 不要删掉模板自己写，麻烦按照我现在设置的模板填写，这样把需求一次性写清楚可以节省很多反复沟通的时间：\r\n\r\n```\r\n**Is your feature request related to a problem? Please describe.**\r\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\r\n\r\n**Describe the solution you'd like**\r\nA clear and concise description of what you want to happen.\r\n\r\n**Describe alternatives you've considered**\r\nA clear and concise description of any alternative solutions or features you've considered.\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.\r\n```""",panjf2000,7496278,2019-10-20T11:58:38.000+00:00,2019-10-20T12:00:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3365,
544245766,509545524,"""刚才点错了不小心关掉了，忽略。。。""",panjf2000,7496278,2019-10-20T11:59:23.000+00:00,2019-10-20T11:59:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3366,
544250144,509545524,"""目前没用ants,需要自己管理队列，需要起很多goroutine\r\n```go\r\nfor{\r\n    packet=recv(con)\r\n    switch packet.Type{\r\n    case A:\r\n           go processA(con,packet)\r\n   case B:\r\n          go processB(con,packet)\r\n   ......\r\n}\r\n\r\nfunc processA(con,packet){\r\n    queuename:=calc_queuename(con,A)\r\n   put_packet_in_queue(queuename,packet)\r\n\r\n    lock_queue(queuename)\r\n    front_packet:=pop_packet_from_queue(queuename)\r\n   actual_processingA(front_packet)\r\n   unlock_queue(queuename)\r\n}\r\n\r\nfunc processB(con,packet){\r\n    queuename:=calc_queuename(con,B)\r\n   put_packet_in_queue(queuename,packet)\r\n\r\n    lock_queue(queuename)\r\n    front_packet:=pop_packet_from_queue(queuename)\r\n   actual_processingB(front_packet)\r\n   unlock_queue(queuename)\r\n}\r\n```\r\n\r\n如果有SubmitQueue,可以简化如下：\r\n```go\r\nfor{\r\n    packet=recv(con)\r\n    switch packet.Type{\r\n    case A:\r\n           ants.SubmitQueue(calc_queuename(con,A),func(){\r\n          actual_processingA(packet)\r\n          }\r\n   case B:\r\n           ants.SubmitQueue(calc_queuename(con,B),func(){\r\n          actual_processingB(packet)\r\n          }\r\n   ......\r\n}\r\n```""",yangjuncode,47293522,2019-10-20T13:00:47.000+00:00,2019-10-20T13:00:47.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3367,
544255488,509545524,"""我看完你这代码，你是想让 `ants` 来帮你在内部维护一个保证业务顺序的队列？这个提议不太合理，`ants` 作为一个协程池，它提供的功能很简单，核心价值只有两个：复用 goroutine 和定时清理过期 goroutine，从而在大规模 goroutine 场景下节省系统资源和提升并发性能，你这个需求属于业务层面的了，这个功能不在 `ants` 的职责范围内，我对 `ants` 的定位是一个简单的 goroutine pool 库，pool 是没有顺序的，只做上面说的两件最核心的事，不能把太多复杂的业务层面的功能加到 `ants` 里面。\r\n\r\n另外，你这种需求完全可以自己封装一个带锁的队列，其实也不麻烦的，你看你贴的代码里，其实相比较起简化的版本也就多了入队和出队的操作（加锁），这个跟你用不用 `ants` 没有关系,`ants` 只是提供复用 goroutine 的功能。所以抱歉，这个功能暂不考虑加到 `ants` 里。""",panjf2000,7496278,2019-10-20T14:05:46.000+00:00,2019-10-20T14:05:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3368,
544790952,491601411,"""There is a fundamental solution to this kind of issue: \r\n```sh\r\n# Remove go.sum\r\nrm go.sum\r\n\r\n# Then re-generate go.sum\r\ngo mod tidy\r\n```""",panjf2000,7496278,2019-10-22T03:24:11.000+00:00,2019-10-22T03:24:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3369,
544792839,491601411,"""@panjf2000 but on other computers, you will receive this bug again..""",im-kulikov,888650,2019-10-22T03:36:14.000+00:00,2019-10-22T03:36:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3370,
544800938,491601411,"""@im-kulikov \r\nWhat did you mean? Removing go.sum still didn't work?""",panjf2000,7496278,2019-10-22T04:31:53.000+00:00,2019-10-22T04:31:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3371,
544805132,491601411,"""No, because problem is with go-modules..\r\nSolution:\r\n- cleanup $GOPATH/pkg/mod\r\n- cleanup $GOPATH/pkg/sumdb\r\n- go mod download\r\n- replace hash in go.sum """,im-kulikov,888650,2019-10-22T04:58:16.000+00:00,2019-10-22T04:58:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3372,
546658720,491601411,"""still not work on Windows go 1.13.3""",r6c,45527749,2019-10-27T03:35:11.000+00:00,2019-10-27T03:35:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3373,
546663007,491601411,"""It seems that you are trying to download both v1 and v2 of ants? Why did you do that?\r\nAnd removing go.sum didn't work?""",panjf2000,7496278,2019-10-27T05:18:33.000+00:00,2019-10-27T05:18:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3375,
568945411,542347075,"""@HobbyBear \r\n的确存在这种情况，偶尔会发生 running goroutines 数量轻微溢出 capacity，但是这种提前释放锁而导致的溢出并不是什么大问题：\r\n1. 首先这种情况发生的概率极小，之所以提前释放锁是为了让其他的 go 程能更快地取回 workers，提高性能，如果是整个过程都锁住的确可以保证不溢出，但是为了这种极小概率的事件而损耗大部分场景的性能有点得不偿失；\r\n2. 其次就算发生了这种情况，溢出的 goroutines 数量也只会是极小的，至少是在可接受的范围内（一般只会溢出那么几个），而且在 workers 完成任务后归还 pool 的时候也会进行[检查](https://github.com/panjf2000/ants/blob/master/pool.go#L245)，舍弃掉溢出的 goroutines，从而慢慢还原至 pool capacity，所以从局部来看，pool 里的 workers 不是严格的小于等于容量，但从整体来看是无限趋近的。""",panjf2000,7496278,2019-12-26T01:33:51.000+00:00,2019-12-26T01:37:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3425,
568948081,542347075,"""好的，感谢分享""",HobbyBear,35391181,2019-12-26T01:58:38.000+00:00,2019-12-26T01:58:38.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3426,
568950855,542347075,"""还有什么问题？""",panjf2000,7496278,2019-12-26T02:22:21.000+00:00,2019-12-26T02:22:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3427,
569465402,543230040,"""内置 http 那种每个请求一个 goroutine 的是没法从外部限制的，那是源码级别的模式了，README 上的例子只能限制一个请求的 goroutine 里再新创建的其他 goroutines。""",panjf2000,7496278,2019-12-29T01:28:45.000+00:00,2019-12-29T01:28:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3428,
569672765,543871027,"""安装 v1 可以执行 `go get -u github.com/panjf2000/ants@v1.x.x`""",panjf2000,7496278,2019-12-30T13:03:46.000+00:00,2019-12-30T13:03:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3429,
571480691,491601411,"""Important thing: Close your IDE! I had that problem with GoLand. Close IDE and repeat the steps:\r\n    `cd /another/path`\r\n    `go clean -modcache`\r\n    `cd /project/path`\r\n    `go mod tidy`\r\n""",patrick-othmer,8964313,2020-01-07T08:08:16.000+00:00,2020-01-07T08:08:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3430,
573658586,548918163,"""> i need firstly forbid new tasks\r\n\r\nUse an atomic counter to record your running tasks also block new tasks.\r\n\r\n> and second wait for completion of already running\r\n\r\nI think `WaitGroup` is the answer you were looking for.""",panjf2000,7496278,2020-01-13T13:18:00.000+00:00,2020-01-13T13:18:00.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3431,
573661908,548918163,"""did you mind to add this to \""core\"" ants? or this is user decision? I'm prefer to have this via set capacity of pool to zero. So new tasks can't be scheduled, older - continue to run""",vtolstov,481307,2020-01-13T13:25:26.000+00:00,2020-01-13T13:25:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3432,
573679396,548918163,"""The functionality of blocking new tasks could be added to `ants` but the other one of waiting for all tasks can't and shouldn't be added, because the `Submit()`/`Invoke()` of `ants` pool ought to have the same behaviors as the `go` statement. """,panjf2000,7496278,2020-01-13T14:07:59.000+00:00,2020-01-13T14:23:47.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3433,
573685136,548918163,"""Ok, thanks. May be i can add some pooling and if wait provided - recheck busy workers?\r\nDo you have some timeline for blocking adding new tasks?""",vtolstov,481307,2020-01-13T14:20:06.000+00:00,2020-01-13T14:20:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3434,
573689956,548918163,"""> Do you have some timeline for blocking adding new tasks?\r\n\r\nI think there is a quite easy way to do that for adding one more check here: [a](https://github.com/panjf2000/ants/blob/master/pool_func.go#L161) and [b](https://github.com/panjf2000/ants/blob/master/pool.go#L142), like:\r\n```go\r\nif p.Cap() == 0 {\r\n    return Errxxx\r\n}\r\n```\r\nor combining it with the `atomic.LoadInt32(&p.release) == 0` check by `||` operator also works .\r\nI will do it on my own sometime tomorrow but if you are interested in it, you are welcome to submit a PR for it.\r\n""",panjf2000,7496278,2020-01-13T14:30:06.000+00:00,2020-01-13T14:33:16.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3435,
573693269,548918163,"""BTY, releasing the pool also blocks new tasks, does that meet your requirements? if so, then it is no need to add any new functionality.""",panjf2000,7496278,2020-01-13T14:37:23.000+00:00,2020-01-13T14:39:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3436,
573716955,548918163,"""May be this is what i need. How ants works if i do Release on pool and try to add new task with Blocking/Nonblocking mode? And if some task already running and i'm run Release?""",vtolstov,481307,2020-01-13T15:24:23.000+00:00,2020-01-13T15:24:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3437,
573730817,548918163,"""Once you invoke `p.Release()`, it is going to close all idle workers while it has no impact on those workers that are running tasks. Afterwards, those running workers will exit automatically after they finish their tasks.\r\n\r\nBut you should note that the pool can't be reopened once you release it.""",panjf2000,7496278,2020-01-13T15:51:11.000+00:00,2020-01-13T15:51:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3438,
573740019,548918163,"""This is not problem. So thanks for your time, i'm try use Release.""",vtolstov,481307,2020-01-13T16:09:25.000+00:00,2020-01-13T16:11:57.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3439,
573741306,548918163,"""nothing needs to be changed. thanks for great library""",vtolstov,481307,2020-01-13T16:12:11.000+00:00,2020-01-13T16:12:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3440,
574963260,550305777,"""谢谢你的提醒，但也正像你说的，`periodicallyPurge` 发生 panic 的可能性极小，现在唯一可能导致 panic 的地方是这里：\r\nhttps://github.com/panjf2000/ants/blob/d3e44612e2420872307f1c320e15928c536db4fb/pool.go#L76\r\n这是 worker 队列的接口，留给后面添加新 worker 队列类型用的，目前来说现有的两种队列实现基本不可能导致 panic，所以我暂时不考虑加 recover，因为现在加除了导致代码测试覆盖率下降之外没有任何实际的好处，过早优化是万恶之源嘛！\r\n等以后添加新的队列类型之后且可能导致 panic了，我再慢慢考虑加这个。""",panjf2000,7496278,2020-01-16T03:19:03.000+00:00,2020-01-16T03:19:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3441,
574969396,550555088,"""> 直接 p.workers = nil 不能做到释放内存的动作吗？\r\n\r\n可以的，这一行是后来加的，之前是打算释放，加了之后忘记把上面那行删掉了，谢谢提醒。""",panjf2000,7496278,2020-01-16T03:49:27.000+00:00,2020-01-16T03:49:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3442,
574977275,550305777,"""顺便问一句，amazon招人吗?""",Andrewpqc,31125408,2020-01-16T04:31:13.000+00:00,2020-01-16T04:31:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3443,
638865318,629156928,"""I include `github.com/panjf2000/ants` - Application developed last week.\r\n\r\nYou could be right with \""close any sockets after task\""-issue. It could be the reason i have to increase the ulimit of open files (sockets in this case) before execution of the application:\r\n\r\nI use:\r\n```\r\ndefer fasthttp.ReleaseRequest(req)\r\ndefer fasthttp.ReleaseResponse(resp)\r\n```\r\n\r\nI checked the godoc https://godoc.org/github.com/valyala/fasthttp again, i dont see any other option to close the connection. In my opinion `release` should close the connection. \r\nI checked even if there is a KeepAlive Option on new instance - there is no.\r\n\r\nAny idea?""",T200proX7,57217666,2020-06-04T13:56:03.000+00:00,2020-06-04T14:12:19.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3511,
639394179,629156928,"""How are you measuring memory usage?\r\n\r\nIf you want to close keep-alive connections you should set a `Connection: close` header in your requests.\r\n\r\nOr you could set https://godoc.org/github.com/valyala/fasthttp#Client.MaxIdleConnDuration to a second for example if you want to reuse the connection shortly but don't want to keep it around for long.""",erikdubbelboer,522870,2020-06-05T10:27:55.000+00:00,2020-06-05T10:27:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3512,
639416295,629156928,"""I measure using `ps aux`, `top`, `cat /proc/*/status` and `cat /proc/*/smaps`. \r\n\r\nOk i will add the `req.Header.Add(\""Connection\"", \""close\"")` and give another try with `ants`.\r\n\r\nRegarding `MaxIdleConnDuration` thank you for the information. In my case it is not necessary, i just do one request per host and am looking to close it fast to use less system resources.""",T200proX7,57217666,2020-06-05T11:12:14.000+00:00,2020-06-05T11:12:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3513,
639436611,629156928,"""**Ants:**\r\nMy Application checked `2650 rows/urls`. Took it from the MySQL DB passed it to the `Ants Pool with 25 Workers`. Requested the HTML Code of the Page and parsed it for two strings. \r\n\r\nI added now the `Connection: close` to the request header and checked the results:\r\n\r\nThe `open sockets` are not increasing that much and that fast as before.. but they are still increasing: \r\n```\r\nroot@jdebian:~$ ls -l /proc/2865/fd | wc -l\r\n142\r\n```\r\n  \r\n```\r\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r\n2865 jonny     20   0    3,0g   2,2g   0,0g S  61,8  28,1   6:24.34 AntsgoCheckResu\r\n```\r\n\r\n```\r\nroot@jdebian:~$ cat /proc/2865/status\r\nName:   AntsgoCheckResu\r\nUmask:  0022\r\nState:  S (sleeping)\r\nTgid:   2865\r\nNgid:   0\r\nPid:    2865\r\nPPid:   2839\r\nTracerPid:      0\r\nUid:    1000    1000    1000    1000\r\nGid:    1000    1000    1000    1000\r\nFDSize: 256\r\nGroups: 24 25 27 29 30 44 46 109 112 115 1000\r\nNStgid: 2865\r\nNSpid:  2865\r\nNSpgid: 2865\r\nNSsid:  2839\r\nVmPeak:  3158000 kB\r\nVmSize:  3158000 kB\r\nVmLck:         0 kB\r\nVmPin:         0 kB\r\nVmHWM:   2301028 kB\r\nVmRSS:   2301028 kB\r\nRssAnon:         2293980 kB\r\nRssFile:            7048 kB\r\nRssShmem:              0 kB\r\nVmData:  2429984 kB\r\nVmStk:       132 kB\r\nVmExe:      3112 kB\r\nVmLib:      1500 kB\r\nVmPTE:      4648 kB\r\nVmSwap:        0 kB\r\nHugetlbPages:          0 kB\r\nCoreDumping:    0\r\nThreads:        12\r\nSigQ:   0/31255\r\nSigPnd: 0000000000000000\r\nShdPnd: 0000000000000000\r\nSigBlk: 0000000000000000\r\nSigIgn: 0000000000000000\r\nSigCgt: ffffffffffc1feff\r\nCapInh: 0000000000000000\r\nCapPrm: 0000000000000000\r\nCapEff: 0000000000000000\r\nCapBnd: 0000003fffffffff\r\nCapAmb: 0000000000000000\r\nNoNewPrivs:     0\r\nSeccomp:        0\r\nSpeculation_Store_Bypass:       vulnerable\r\nCpus_allowed:   f\r\nCpus_allowed_list:      0-3\r\nMems_allowed:   00000000,00000001\r\nMems_allowed_list:      0\r\nvoluntary_ctxt_switches:        227683\r\nnonvoluntary_ctxt_switches:     522\r\nroot@jdebian:~$\r\n```\r\n\r\nIts a lot for 25 workers checking 2650 urls. For my logical understanding 25 workers -> each one takes a URL and request the HTML from it. Then do the parsing stuff.  So even when the HTML is 1MB each URL so we are in total at 25MB, some worker is faster, some slower.. lets increase it to the double size -> 50MB. So lets say the GC is very slow and need some time to recognise the current `func()` - call is not alive anymore, so lets triple the memory consumption -> we are on 150MB. \r\n\r\nAs you see the Application use `2,2g` for sure and `3.0g` \""reserved\"".\r\nAs longer the Application run, as more resources it aquire. Around `2,2g` it stucks. \r\n\r\nI checked my code again and the only one point where is a real consumption of memory is happening is the fasthttp request while receiving the requested HTML Code from the URL.\r\n\r\n----------------\r\n**Without Ants:**\r\nThis time took 14000 rows from DB, the Application did not use workers and call `go processRow()` instead. I had to increase `ulimit -n 99999` because without it i received `udp 8.8.8.8:53 - too many open socket files` (i should have taken 2650 rows .. but in this case the Application just run some seconds).\r\n\r\n```\r\nroot@jdebian:~$ ls -l /proc/4010/fd | wc -l\r\n6048\r\n```\r\n\r\n```\r\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r\n4010 jonny     20   0    5,7g   3,6g   0,0g S  82,1  45,9   1:35.44 noAnts_CheckResu\r\n```\r\n\r\nFor my understanding the Goroutines should activate the GC after the `go processRow()` execute `return`, so every memory consumption within the `processRow()` should get released in this moment.\r\n\r\n\r\n\r\n""",T200proX7,57217666,2020-06-05T11:57:32.000+00:00,2020-06-05T12:18:57.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3514,
639446769,629156928,"""Sounds like more memory than should be required. But keep in mind that fasthttp trades more memory usage for less CPU usage by reusing buffers.\r\n\r\nWhat I would do next is use https://golang.org/pkg/net/http/pprof/ to see where the allocations are. Make sure to set [`runtime.MemProfileRate = 1`](https://golang.org/pkg/runtime/#MemProfileRate) all the way at the top of your `main` function.\r\n\r\nAlso could you try using `client.Do` instead of `client.DoTimeout`? You already set a `ReadTimeout` on the client, you should also set a `WriteTimeout` of a couple of seconds.\r\n`client.DoTimeout` will return after the timeout but won't close the connection so the request might still be running in the background. This could cause more open connections than you might expect.""",erikdubbelboer,522870,2020-06-05T12:18:48.000+00:00,2020-06-05T12:18:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3515,
639464047,629156928,"""Ok thank you for the advise, i will check it and we will see. Yes the memory consumption is abnormal huge. Good that you see it the same way. I was already worry in myself.\r\n\r\nYes i read already that fasthttp trades memory for cpu. But everything over 500MB for this task is crazy and unreal.\r\n""",T200proX7,57217666,2020-06-05T12:57:44.000+00:00,2020-06-05T12:57:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3516,
639485144,629156928,"""So i checked no the noAnts_Program with 50 rows only:\r\n`3561 root      20   0  989.1m 456.0m   9.9m S   0.0  9.2   0:38.90 noAnts_goCheckR`\r\n\r\n```\r\nShowing nodes accounting for 228502.19kB, 99.40% of 229891.07kB total\r\nDropped 423 nodes (cum <= 1149.46kB)\r\n      flat  flat%   sum%        cum   cum%\r\n  228480kB 99.39% 99.39% 228888.12kB 99.56%  github.com/valyala/fasthttp.appendBodyFixedSize\r\n   21.88kB 0.0095% 99.40% 229228.88kB 99.71%  github.com/valyala/fasthttp.(*Client).Do\r\n    0.27kB 0.00012% 99.40% 229201.64kB 99.70%  github.com/valyala/fasthttp.(*HostClient).doNonNilReqResp\r\n    0.05kB 2e-05% 99.40% 229320.91kB 99.75%  main.processRow\r\n         0     0% 99.40% 229201.64kB 99.70%  github.com/valyala/fasthttp.(*HostClient).Do\r\n         0     0% 99.40% 229201.64kB 99.70%  github.com/valyala/fasthttp.(*HostClient).do\r\n         0     0% 99.40% 229025.44kB 99.62%  github.com/valyala/fasthttp.(*Response).ReadLimitBody\r\n         0     0% 99.40% 228992.12kB 99.61%  github.com/valyala/fasthttp.readBody\r\n         0     0% 99.40% 220736.12kB 96.02%  github.com/valyala/fasthttp.readBodyChunked\r\n         0     0% 99.40% 229272.33kB 99.73%  main.fetchURL\r\n```\r\n\r\n```\r\n# runtime.MemStats\r\n# Alloc = 1279872\r\n# TotalAlloc = 886342752\r\n# Sys = 558774520\r\n# Lookups = 0\r\n# Mallocs = 165934\r\n# Frees = 161070\r\n# HeapAlloc = 1279872\r\n# HeapSys = 536051712\r\n# HeapIdle = 532905984\r\n# HeapInuse = 3145728\r\n# HeapReleased = 526229504\r\n# HeapObjects = 4864\r\n# Stack = 819200 / 819200\r\n# MSpan = 56576 / 131072\r\n# MCache = 6944 / 16384\r\n# BuckHashSys = 2305008\r\n# GCSys = 17539072\r\n# OtherSys = 1912072\r\n# NextGC = 4194304\r\n# LastGC = 1591363913647135690\r\n# PauseNs = [126260 191276 198996 71658 1093753 110912 57353 135365 73806 2873532 53722 414573 65790 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\r\n# PauseEnd = [1591363600374965583 1591363600500069755 1591363600594642301 1591363602272236950 1591363603919804979 1591363605278324163 1591363607441511578 1591363612664953655 1591363625182586297 1591363643347110310 1591363671683448609 1591363792671338235 1591363913647135690 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\r\n# NumGC = 13\r\n# NumForcedGC = 0\r\n# GCCPUFraction = 4.101210998880725e-05\r\n# DebugGC = false\r\n```\r\n\r\n```\r\nCount | Profile\r\n-- | --\r\n3273 | allocs\r\n0 | block\r\n0 | cmdline\r\n59 | goroutine\r\n3278 | heap\r\n0 | mutex\r\n0 | profile\r\n13 | threadcreate\r\n0 | trace\r\n```\r\n\r\nLooks like everything is as it should be. Hmm.\r\nLets see.. little bit later i will profile every single Goroutine to see the real consumption. I must read first how to do it. """,T200proX7,57217666,2020-06-05T13:37:43.000+00:00,2020-06-05T13:39:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3517,
639743857,629156928,"""noAnts_NetHttp_Program / 50 rows=Urls:\r\n```\r\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\r\n5760 root      20   0  655.0m 179.8m   6.5m S   1.0  3.6   0:26.33 noAntsNetHTTP_g\r\n\r\nreal    1m0.275s\r\nuser    0m22.984s\r\nsys     0m3.680s\r\n```\r\n\r\nnoAnts_FastHttp_Program / 50 rows=Urls:\r\n```\r\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\r\n 5958 root      20   0  854.5m 387.6m   6.6m S   0.0  7.8   0:24.12 noAnts_goCheckR\r\n\r\nreal    2m57.990s\r\nuser    0m24.220s\r\nsys     0m5.156s\r\n```\r\n\r\nOfc time measuring is difficult because of network latency but i took the same 50 urls.. so in one way its not 100% reliable but on the other side it is telling us something.\r\n\r\n""",T200proX7,57217666,2020-06-05T19:28:59.000+00:00,2020-06-05T19:28:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3518,
639765425,629156928,"""Ants_NetHttp_Program / 50 rows=Urls / 25 Ants Worker:\r\n```\r\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\r\n6608 root      20   0  581.0m 144.0m   6.5m S  8.7  2.9   0:27.46 AntsNetHTTPgoCh\r\n\r\nreal    0m50.328s\r\nuser    0m23.448s\r\nsys     0m3.852s\r\n```\r\n\r\nAnts_FastHttp_Program / 50 rows=Urls / 25 Ants Worker:\r\n```\r\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\r\n6517 root      20   0  782.5m 383.5m   6.0m S   0.0  7.7   0:27.60 AntsgoCheckResu\r\n\r\nreal    2m9.341s\r\nuser    0m23.172s\r\nsys     0m4.476s\r\n```\r\n\r\nIm on the end with my knowledge and really dont know how to continue this task with golang. Maybe i have some mistake in my code, but the code is 200 lines.. and Golang is very simple.. so i dont think there can be one/such a bad mistake.\r\n\r\nWith Net/Http the Memory Usage is lower than with FastHttp but even this memory consumption is high in my opinion. 50 seconds/2 minutes for 50 http requests on 25 workers? If i use the BulkOpener Extension for Chrome and Open the 50 Urls it takes same time including rendering. It is strange, i dont trust all this numbers - i have even better numbers with php+pthreads (except the crazy high cpu usage).""",T200proX7,57217666,2020-06-05T20:00:29.000+00:00,2020-06-05T20:05:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3519,
639775827,629156928,"""Would you be willing to share your code in private with me so I can see what can be improved?""",erikdubbelboer,522870,2020-06-05T20:14:48.000+00:00,2020-06-05T20:14:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3520,
793340263,823817947,"""> > 这个操作只能在具体的Task里去执行done吧，如果在invoke上下文进行add和done的话，Task如果执行时间稍微长点，那wait结束的时候，并未真正执行完\r\n> > ```go\r\n> > for ... {\r\n> >     wg.Add(1)\r\n> >     p.Invoke(args)\r\n> >     wg.Done()\r\n> > }\r\n> > wg.Wait()\r\n> > ```\r\n> \r\n> 不是很懂你的意思\r\n\r\n- 我的意思是invoke只是把task提交进pool，invoke的结束并不意味着task执行结束；\r\n- 在task里面进行done操作倒是没有什么问题，都可以实现功能，只是想请教下ants本身是否提供了更优雅的方式去监控pool的worker执行状态(是否执行完毕等)\r\n\r\n\r\n""",mayouzi,18528873,2021-03-09T03:49:11.000+00:00,2021-03-09T03:49:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3614,
793728501,823817947,"""> 在task里面进行done操作倒是没有什么问题，都可以实现功能，只是想请教下ants本身是否提供了更优雅的方式去监控pool的worker执行状态(是否执行完毕等)\r\n\r\n暂时没有提供这个内置功能。""",panjf2000,7496278,2021-03-09T11:09:48.000+00:00,2021-03-09T11:09:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3615,
794938016,823817947,"""> > 在task里面进行done操作倒是没有什么问题，都可以实现功能，只是想请教下ants本身是否提供了更优雅的方式去监控pool的worker执行状态(是否执行完毕等)\r\n> \r\n> 暂时没有提供这个内置功能。\r\n\r\n好的，多谢回复，祝好\r\n""",mayouzi,18528873,2021-03-10T06:05:27.000+00:00,2021-03-10T06:05:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3616,
795426594,824927472,"""https://github.com/panjf2000/ants/blob/94a7a7f1cb3a11fcaaf9608c94fe1dc0bcd98ab0/pool.go#L69-L93\r\n\r\nThere will be always a separate goroutine that runs periodical jobs to clean up idle worker goroutines, which may cause the CPU consumption but still, 5% is not an expected amount.\r\n\r\nIf you don't want this goroutine to occupy too many system resources, I'd suggest you tune the `ExpiryDuration` option:\r\n\r\nhttps://github.com/panjf2000/ants/blob/94a7a7f1cb3a11fcaaf9608c94fe1dc0bcd98ab0/options.go#L21""",panjf2000,7496278,2021-03-10T13:39:46.000+00:00,2021-03-10T13:39:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3617,
798425055,824927472,"""Did you try my way? did it work for you?""",panjf2000,7496278,2021-03-13T14:13:23.000+00:00,2021-03-13T14:13:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3620,
799212299,824927472,"""我也是遇到了这个问题,不过更狠 cpu直接干到了 130%  不知道是不是我用法不对，网上粘贴的，还没来得及看原因。\r\n\r\nants 版本： github.com/panjf2000/ants v1.3.0\r\n\r\n代码如下：\r\n```go\r\nconst (\r\n    goroutineCount  = 5000\r\n)\r\n\r\nvar (\r\n    AntsGoroutinePool  *ants.Pool\r\n    InitResult = false\r\n)\r\n\r\nfunc init() {\r\n   options :=  ants.Options{}\r\n   // 是否预分配内存\r\n   options.PreAlloc = false\r\n   // 工作池是否是非阻塞的，这决定了 Pool.Submit 接口在提交任务时是否会被阻塞\r\n   options.Nonblocking = true\r\n   // 清理 goroutine 的时间间隔 (秒)\r\n   options.ExpiryDuration = 5\r\n   // 允许阻塞的最大限制 仅在阻塞模式下有效\r\n   options.MaxBlockingTasks = goroutineCount\r\n   // 发生panic时执行该函数\r\n   options.PanicHandler = func(err interface{}) {\r\n       log.GetTracerLogger().Error(\""worker exits from a panic: %+v\\n\"", err)\r\n   }\r\n   var err error\r\n   AntsGoroutinePool, err = ants.NewPool(goroutineCount, ants.WithOptions(options))\r\n   if err != nil {\r\n       log.GetTracerLogger().Error(\""初始化 goroutinePool 异常 %+v\"", err)\r\n   }\r\n\r\n   log.GetTracerLogger().Info(\""初始化 goroutinePool 成功 capacity:%d, running:%d, free:%d\"", AntsGoroutinePool.Cap(), AntsGoroutinePool.Running(), AntsGoroutinePool.Free())\r\n   InitResult = true\r\n}\r\n```""",Clever-Wang,32836543,2021-03-15T08:14:59.000+00:00,2021-03-15T08:14:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3621,
799252760,824927472,"""你这个就太离谱了，不可能是 `ants` 的定时任务导致的，先定位一下具体占用 CPU 的进程看看。""",panjf2000,7496278,2021-03-15T09:14:20.000+00:00,2021-03-15T09:14:20.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3622,
799272954,824927472,"""是的 我把所有集成的服务代码全注释了  只留了这个  上面的所有代码 就在一个文件里面的 把init放开  就直接干到了 130%   除了引入了几个 dubbo go的 包 相当于是个空服务了，一点点排查的 别的注释打开都没事""",Clever-Wang,32836543,2021-03-15T09:40:34.000+00:00,2021-03-15T09:40:34.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3623,
799310459,824927472,"""那个原因 知道了 是因为 时间的问题   ExpiryDuration = 5  不对 得改成秒 才行 。""",Clever-Wang,32836543,2021-03-15T10:35:28.000+00:00,2021-03-15T10:35:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3624,
800276656,830908542,"""不是你理解的意思，这里之所以有这个判断条件是因为：\r\nhttps://github.com/panjf2000/ants/blob/fd8d670fd09489e6ea7693c0a382ba85d2694f16/pool.go#L87-L92\r\n\r\n有一种情况是调用者在等待可用的 worker，但是此时所有的 workers 都被定时任务清除掉了，那么该调用者就永远都会阻塞住，所以定时任务每当清除完所有的 workers 之后会去唤醒等待的调用者，此时调用方会判断 p.Running == 0，如果是则需要启动新的 goroutine 去工作。""",panjf2000,7496278,2021-03-16T13:54:11.000+00:00,2021-03-16T13:54:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3625,
800291515,830099075,"""That seems possible, did you write an example to verify this case?""",panjf2000,7496278,2021-03-16T14:13:12.000+00:00,2021-03-16T14:13:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3626,
800306572,830908542,"""我懂你的意思了，是唤醒等待worker的进程,我一开始以为函数会不断的在goto语句中循环运行，现在仔细看了一下，发现原来函数会被阻塞在`p.cond.Wait()` ,所有函数都在等待唤醒。设计的原则是有空闲worker就用空闲worker,除非没有了才`p.workerCache.Get().(*goWorker)`对吧。如果采用`p.Running()<capacity` 会造成浪费。  """,sirodeneko,48661001,2021-03-16T14:28:21.000+00:00,2021-03-16T14:28:21.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3627,
800317295,830908542,"""p.Running()<capacity 在这个函数的前面已经判断过了，p.Running == 0 就是为了我刚才说的目的而已。""",panjf2000,7496278,2021-03-16T14:40:39.000+00:00,2021-03-16T14:40:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3628,
801109574,807765048,"""It's up to you, if you don't want to use go modules, just download the ants v2 and use vendor for it.""",panjf2000,7496278,2021-03-17T14:06:51.000+00:00,2021-03-17T14:06:51.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3629,
833572838,869939645,"""有可能的，ants 是允许短时间内在运行的 worker 稍微超过 capacity 的，但是在任务执行完之后放回 pool 的时候会进行判断：\r\nhttps://github.com/panjf2000/ants/blob/a83f12c254ce6929a8dc556608bf6a3f4ddc1d4b/pool.go#L271-L273\r\n如果超过 capacity 的 workers 会被销毁，通过这种方式达到最终的边界。""",panjf2000,7496278,2021-05-06T14:33:55.000+00:00,2021-05-06T14:33:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3651,
801548634,830908542,"""这个问题，我想过。我觉得目前的做法不是很优雅。我之前对这段代码进行了一些推敲，我把我的理解整理如下。\r\n\r\n为什么要加这段代码呢？而且 p.lock.Unlock() 后再调用 spawnWorker()，running 个数失去了保护，这个次数就有可能超过了设定的最大值 capacity。\r\n\r\n```\r\n\t\tif p.Running() == 0 {\r\n\t\t\tp.lock.Unlock()\r\n\t\t\tspawnWorker()\r\n\t\t\treturn\r\n\t\t}\r\n```\r\n\r\n好吧，我们先忽略上面这个小问题。再来看下面这段代码，为什么不能在 w == nil 时，直接 spawnWorker() 个新的 worker?  因为有可能是收到广播信号，此时不能保证 p.Running() <= capacity 。\r\n\r\n```\r\n\t\tw = p.workers.detach()\r\n\t\tif w == nil {\r\n\t\t\tgoto Reentry\r\n\t\t}\r\n```\r\n\r\n但是，我觉得可以通过修改成下面的代码解决掉这个问题\r\n\r\n```\r\n\t\tw = p.workers.detach()\r\n\t\tif w == nil {\r\n\t\t\tif p.Running() < capacity {\r\n\t\t\t\tspawnWorker()\r\n\t\t\t\tp.lock.Unlock()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tgoto Reentry\r\n\t\t}\r\n```\r\n\r\n由于作者没有采用类似这样的写法，导致需要增加 `if p.Running() == 0` 这段代码处理广播信号。\r\n\r\n再来看广播信号，广播信号是在定时回收时，满足下面的条件触发的。\r\n\r\n```\r\n\t\t// There might be a situation that all workers have been cleaned up(no any worker is running)\r\n\t\t// while some invokers still get stuck in \""p.cond.Wait()\"",\r\n\t\t// then it ought to wakes all those invokers.\r\n\t\tif p.Running() == 0 {\r\n\t\t\tp.cond.Broadcast()\r\n\t\t}\r\n```\r\n\r\n为什么需要这段代码？原因在于需要考虑这么一种情况，当 retrieveWorker() 发现 runing() 个数超过了容量，因此在 p.cond.Wait() 中。之后 runing() 的所有 worker f() 都发生了 panic，按当前的代码逻辑，是无法正常归还到工作池中的，revertWorker 不会被调用，也就是 revertWorker 不会发出 Signal 通知。因此，如果我们检测到没有1个worker running，就 Broadcast 信号。\r\n\r\n```\r\nfor f := range w.task {\r\n\t\r\n\tif f == nil {\r\n\t\treturn\r\n\t}\r\n\t\r\n\t// 需要考虑 f() panic 的情况，此时不会归还到工作池中\r\n\tf()\r\n\t\r\n\tif ok := w.pool.revertWorker(w); !ok {\r\n\t\treturn\r\n\t}\r\n}\r\n```\r\n\r\n因此广播信号的加入，确实增加了复杂度。能不能在work run() 中包装调用 f() ，处理 panic ?""",math345,17548688,2021-03-18T01:30:05.000+00:00,2021-03-18T01:30:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3630,
804764054,834309657,"""可以尝试提个 PR。""",panjf2000,7496278,2021-03-23T09:46:52.000+00:00,2021-03-23T09:46:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3631,
806041075,834309657,"""今天刚看完这块的代码，也有疑虑，如果广播意义在于处理全部worker panic的话（没有放回池子中）。\r\n```             p.cond.Wait()\r\n\t\tif p.Running() == 0 {\r\n\t\t\tp.lock.Unlock()\r\n                        //Running()==0的判断,不是安全的\r\n                        //另外如果p.cond.Wait()的等待很多，广播唤醒时，会产生大量的worker\r\n\t\t\tif !p.IsClosed() {\r\n\t\t\t\tspawnWorker()\r\n\t\t\t}\r\n\t\t\treturn\r\n\t\t}\r\n```\r\n另外还有个疑问，如果是大部分worker发生panic，那么如果有大量的p.cond.Wait()也只能等待仅剩下的正常的worker回池，此间如果没新submit，那么worker是无法补充的。""",xuyue86,16272458,2021-03-24T18:01:31.000+00:00,2021-03-24T18:04:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3632,
807124981,840918413,"""seems same as https://github.com/panjf2000/ants/issues/147\r\n\r\nrunning bbolt using ants.Submit produce same error crash. this is production run. so it's important to fix""",hiqsociety,51492452,2021-03-25T17:16:42.000+00:00,2021-03-25T17:16:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3633,
808905912,840918413,"""Thank you for catching this issue.""",panjf2000,7496278,2021-03-28T14:39:24.000+00:00,2021-03-28T14:39:24.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3634,
809865235,844010065,"""https://github.com/golang/go/blob/go1.16.2/src/sync/cond.go#L52-L58""",panjf2000,7496278,2021-03-30T02:51:39.000+00:00,2021-03-30T02:51:39.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3635,
809866798,844010065,"""Ah, I missed the `p.lock` part. Excuse me... :(""",fangxlmr,37577088,2021-03-30T02:56:23.000+00:00,2021-03-30T02:56:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3636,
811954165,838523489,"""ants最大的优势还是节省系统资源，如果你的业务是极度性能敏感的而且 goroutine 数量并不是很大的话，不一定非要用 ants，用 channel 简单控制一下数量也可以。""",panjf2000,7496278,2021-04-01T14:39:12.000+00:00,2021-04-01T14:39:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3637,
812314217,838523489,"""我的场景， 并发大概几十到几百，所以一定需要协程池， 但是又对延迟敏感。\n\n\n| |\nchenbin200818\n|\n|\n***@***.***\n|\n签名由网易邮箱大师定制\n在2021年4月1日 22:39，Andy ***@***.***> 写道：\n\nants最大的优势还是节省系统资源，如果你的业务是极度性能敏感的而且 goroutine 数量并不是很大的话，不一定非要用 ants，用 channel 简单控制一下数量也可以。\n\n—\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or unsubscribe.""",cham-pin,75625523,2021-04-02T04:44:17.000+00:00,2021-04-02T04:44:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3641,
812323295,838523489,"""几百并发哪里需要 goroutine pool，等你成千上万 goroutine 的时候再考虑吧。""",panjf2000,7496278,2021-04-02T05:17:33.000+00:00,2021-04-02T05:17:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3642,
819584872,857977427,"""doc: https://pkg.go.dev/github.com/panjf2000/ants/v2#NewPoolWithFunc\r\n\r\ncode:\r\nhttps://github.com/panjf2000/ants/blob/dbcb6a104f23b1a6a7521796b30515230353283e/examples/main.go#L68-L77""",panjf2000,7496278,2021-04-14T14:57:13.000+00:00,2021-04-14T14:57:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3644,
820304690,834309657,"""看了下最近的提交内容，潘少已在 worker 的 derfer 中加入了，`w.pool.cond.Signal()`，这种情况下，还有必要 `p.cond.Broadcast()` 吗\r\n- https://github.com/panjf2000/ants/commit/dbcb6a104f23b1a6a7521796b30515230353283e""",SummerLius,14150935,2021-04-15T10:08:23.000+00:00,2021-04-15T10:08:23.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3645,
824071290,863400810,"""-1 表示不限制，也就没有满这个概念了。""",panjf2000,7496278,2021-04-21T13:42:26.000+00:00,2021-04-21T13:42:26.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3646,
824072829,863400810,"""Free() 返回 0 可以满足你的需求，或者你也可以直接设置：\r\nhttps://github.com/panjf2000/ants/blob/001c8b5e1b2a7c271fef351847fe1bf2caa95fc5/options.go#L33\r\n\r\n设置了之后，如果池子满了，会直接返回 nil 而不会阻塞。""",panjf2000,7496278,2021-04-21T13:44:28.000+00:00,2021-04-21T13:44:28.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3647,
824645005,863400810,"""明白了，多谢～\r\n\r\n另外有两点：\r\n1. -1 代表不限制这个很容易理解，但是此情况下 Free() 的返回值是`-1 - Pool.Running()`，感觉有点奇怪\r\n2. 对于 Nonblocking 这个参数，池子满了会直接返回 ErrPoolOverload 这个 error 吧？""",ycydsxy,34428640,2021-04-22T08:24:10.000+00:00,2021-04-22T08:24:51.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3648,
826295693,863400810,"""第一点我改一下，统一返回 -1；第二点，是的。""",panjf2000,7496278,2021-04-25T10:01:37.000+00:00,2021-04-25T10:01:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3649,
827209499,864353725,"""Could you show me your code?""",panjf2000,7496278,2021-04-26T23:42:22.000+00:00,2021-04-26T23:42:22.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3650,
841986510,892678963,"""回收 workers 的时候是挑那些已经超过 duration 时长没有被取出的，所以才是 time.Now().Add(-duration)，你对源码的理解错了。""",panjf2000,7496278,2021-05-17T05:02:33.000+00:00,2021-05-17T05:02:33.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3652,
863918126,918864340,"""```\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/panjf2000/ants/v2\r\ncpu: AMD EPYC 7K62 48-Core Processor\r\nBenchmarkGoroutines-8             \t       1\t1199162338 ns/op\t512415264 B/op\t 2000288 allocs/op\r\nBenchmarkSemaphore-8              \t       3\t 406725629 ns/op\t80012624 B/op\t 1000126 allocs/op\r\nBenchmarkAntsPool-8               \t       2\t 575347056 ns/op\t19885056 B/op\t 1052832 allocs/op\r\nBenchmarkGoroutinesThroughput-8   \t       3\t 353528828 ns/op\t79976133 B/op\t  999701 allocs/op\r\nBenchmarkSemaphoreThroughput-8    \t       3\t 367018062 ns/op\t79999285 B/op\t  999991 allocs/op\r\nBenchmarkAntsPoolThroughput-8     \t       2\t 519871186 ns/op\t 3012452 B/op\t   47154 allocs/op\r\nPASS\r\nok  \tgithub.com/panjf2000/ants/v2\t11.937s\r\n```\r\n""",panjf2000,7496278,2021-06-18T09:59:51.000+00:00,2021-06-18T09:59:51.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3682,
863918709,837779470,"""```\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/panjf2000/ants/v2\r\ncpu: AMD EPYC 7K62 48-Core Processor\r\nBenchmarkGoroutines-8             \t       1\t1199162338 ns/op\t512415264 B/op\t 2000288 allocs/op\r\nBenchmarkSemaphore-8              \t       3\t 406725629 ns/op\t80012624 B/op\t 1000126 allocs/op\r\nBenchmarkAntsPool-8               \t       2\t 575347056 ns/op\t19885056 B/op\t 1052832 allocs/op\r\nBenchmarkGoroutinesThroughput-8   \t       3\t 353528828 ns/op\t79976133 B/op\t  999701 allocs/op\r\nBenchmarkSemaphoreThroughput-8    \t       3\t 367018062 ns/op\t79999285 B/op\t  999991 allocs/op\r\nBenchmarkAntsPoolThroughput-8     \t       2\t 519871186 ns/op\t 3012452 B/op\t   47154 allocs/op\r\nPASS\r\nok  \tgithub.com/panjf2000/ants/v2\t11.937s\r\n```""",panjf2000,7496278,2021-06-18T10:00:43.000+00:00,2021-06-18T10:00:43.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3683,
869010474,491601411,"""Fixed in #168 """,panjf2000,7496278,2021-06-26T14:22:08.000+00:00,2021-06-26T14:22:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3689,
870272655,931106727,"""I would suggest `context.Context`.""",panjf2000,7496278,2021-06-29T06:20:52.000+00:00,2021-06-29T06:20:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3690,
873369513,524118492,"""priority queue  实现是完全可以接受的,调度算法本质上都大同小异,自己做降级不就ok了""",ItsFunny,39111451,2021-07-03T08:30:50.000+00:00,2021-07-03T08:30:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3691,
875730336,938708991,"""上下文不足，你说下你打算怎么在这种场景下使用 goroutine pool？""",panjf2000,7496278,2021-07-07T16:04:45.000+00:00,2021-07-07T16:04:45.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3692,
876032855,938708991,"""场景：mqtt服务器，单机支持五十万以上的长连接，除了心跳包，每条连接上的数据传输并不频繁。\r\n像fasthttp一样每来一个conn就扔进goroutine pool，还是使用gnet来做呢？""",DMwangnima,33331974,2021-07-08T00:52:46.000+00:00,2021-07-08T00:52:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3693,
876041015,938708991,"""一个长连接放一个 goroutine，连接一直不销毁，你这样该是多少个 goroutine 还是多少个，没复用，用 goroutine pool 没啥意义，用 gnet 实现吧。""",panjf2000,7496278,2021-07-08T01:13:24.000+00:00,2021-07-08T01:13:24.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3694,
876049295,938708991,"""谢谢大佬解答 想模仿着fasthttp来实现 所以有这样的疑问""",DMwangnima,33331974,2021-07-08T01:34:38.000+00:00,2021-07-08T01:34:38.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3695,
886038095,951582378,"""Sorry, `interface{}` is for generic use cases, and why would it cause large memory allocation?""",panjf2000,7496278,2021-07-24T11:15:05.000+00:00,2021-07-24T11:15:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3701,
887506165,953856676,"""i check my code again... sry, i think thread is not released coz of crashed / failed functions inside.\r\ne.g. worker exits from a panic: runtime error: slice bounds out of range [:18] with capacity 13\r\n""",hiqsociety,51492452,2021-07-27T13:19:36.000+00:00,2021-07-27T13:20:15.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3702,
887701956,953963592,"""wrapping time.Sleep(3*time.Second) between mutex lock and unlock\r\nwith large number of slow sleep, you'll crash with slow mutex and open a lot of threads that does not recycle / killed.\r\n\r\nhow to resolve this?\r\n""",hiqsociety,51492452,2021-07-27T17:37:37.000+00:00,2021-07-27T19:05:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3703,
887762555,953963592,"""should this be added in for \""in case\"" scenarios?\r\nhttps://stackoverflow.com/questions/58008462/will-the-number-of-os-threads-spawned-by-go-process-never-decrease""",hiqsociety,51492452,2021-07-27T19:06:58.000+00:00,2021-07-27T19:06:58.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3704,
888345221,953963592,"""Please show me some example code.""",panjf2000,7496278,2021-07-28T14:15:15.000+00:00,2021-07-28T14:15:15.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3705,
889582725,946771746,"""p.cond.Wait()会解锁的""",dandyhuang,12603054,2021-07-30T02:30:06.000+00:00,2021-07-30T02:30:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3707,
892424101,959089879,"""那你在自己的 goroutine 逻辑里加一个超时逻辑不就行了？""",panjf2000,7496278,2021-08-04T07:14:54.000+00:00,2021-08-04T07:14:54.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3708,
894738623,959089879,"""ok，那我自己写吧，本来想偷个懒。""",Alberthchang,17517153,2021-08-08T03:53:17.000+00:00,2021-08-08T03:53:17.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3709,
899377183,971511276,"""已解惑，一开始没有理解p.cond.Wait() 的实现""",jackerlu,10394162,2021-08-16T09:50:14.000+00:00,2021-08-16T09:50:14.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3710,
900315932,971116711,"""ants 1.x 最后的版本是 1.2.1，这个 ants 1.3 是哪来的？""",panjf2000,7496278,2021-08-17T13:50:11.000+00:00,2021-08-17T13:50:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3711,
900329406,971116711,"""还有，`setCardTime()` 这个方法被调用得多频繁？如果调用频次很多，那每调用一次就会生成 100 个 goroutines，暴涨也是很正常的吧？""",panjf2000,7496278,2021-08-17T14:06:42.000+00:00,2021-08-17T14:06:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3712,
907999180,834309657,"""关于 spawnWorker 的调用时机在Lock外这点有相同的疑惑。\r\n另外无意冒犯，想请教:\r\n如果在固定了 pool 的 size 的前提下，想把一个 task 丢进 pool 里运行，大家一般都会想到预先开启size个gorountine 内部对一个chan进行loop，然后想往 pool 里塞任务的话只要往chan里丢就可以了，而且还直接 select ctx 之类的方法。\r\n那ants选用 cond 锁来自己实现这块逻辑的最直接的好处在哪里呢？""",molon,3739161,2021-08-30T04:06:42.000+00:00,2021-08-30T04:06:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3713,
912347500,987520012,"""![image](https://user-images.githubusercontent.com/7950702/131972901-eaba5211-a6b3-4061-ab12-ba2e90eee937.png)\r\n""",liracle,7950702,2021-09-03T08:09:44.000+00:00,2021-09-03T08:09:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3714,
912384698,987520012,"""你这个图的逻辑是不是有点问题。yes或者no就两个结果，第三条线画出来有点难判断呀。是不是应该就是在yes那个分支后面？如果是的话，这个方法已经立即返回了。return nil之后，感觉我们自己去维护一个waiting list比较好，在框架外部实现自己的业务逻辑。加到ants的整体逻辑里面的话，关闭pool的时候还要考虑如何释放这个waiting list里面的资源。感觉有点魔改了。看作者怎么看到这个问题吧。一点小的个人意见。""",automano,17286982,2021-09-03T09:07:42.000+00:00,2021-09-03T09:07:42.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3715,
912401028,987520012,"""注意提 issue 的规范，不要把正文塞到标题里！标题要简明清晰。""",panjf2000,7496278,2021-09-03T09:32:50.000+00:00,2021-09-03T09:32:50.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3716,
912404057,987520012,"""至于你的需求，你可以直接 `NewPool(-1)` 得到一个无限制的 pool，这样提交任务的时候就不会阻塞了。""",panjf2000,7496278,2021-09-03T09:37:41.000+00:00,2021-09-03T09:37:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3717,
912616111,987520012,"""多谢两位解答，抱歉，没有注意提issue的规范。""",liracle,7950702,2021-09-03T15:18:51.000+00:00,2021-09-03T15:18:51.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3718,
912944936,984782442,"""你这个需求听起来是一个用户侧的场景，pool 本身应该是简单和纯粹的，如果有限速的需求，则可以像你说的在每一个 task函数里自己做一下就行了。""",panjf2000,7496278,2021-09-04T09:52:56.000+00:00,2021-09-04T09:52:56.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3719,
922250939,971116711,"""看了一下感觉是正常情况吧，动态创建一个协程池本身就有最低协程数量吧。""",zeromake,8318747,2021-09-18T09:52:07.000+00:00,2021-09-18T09:52:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3721,
928976572,538994753,"""我觉得第一个问题说的是，如何把线程池任务的结果带回给线程池的调用者，如果你传指针或者引用类型，是不是涉及都了并发操作？""",daydreamjfhu,38855974,2021-09-28T08:33:48.000+00:00,2021-09-28T08:33:48.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3723,
942178102,1024790716,"""Could you open a PR adding a new use case of Shopify to README?""",panjf2000,7496278,2021-10-13T10:56:11.000+00:00,2021-10-13T10:56:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3724,
942287681,1024790716,"""but how can I upload logo image to `https://img.taohuawu.club/gallery/tencent-music-logo.png`？""",lilien1010,3814966,2021-10-13T13:07:40.000+00:00,2021-10-13T13:07:40.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3725,
942304381,1024790716,"""Oh, sorry about that, I think you can go ahead opening a PR with `https://img.taohuawu.club/gallery/shopify-logo.png` and upload `shopify-logo.png` in this issue, I then download the logo image and put it to `img.taohuawu.club/gallery/`.\r\n@lilien1010 """,panjf2000,7496278,2021-10-13T13:24:05.000+00:00,2021-10-13T13:24:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3726,
942307280,1024790716,"""![image](https://user-images.githubusercontent.com/3814966/137141784-9ca1c8f6-1a13-4d34-939d-c8b8b02fbf82.png)\r\n""",lilien1010,3814966,2021-10-13T13:26:57.000+00:00,2021-10-13T13:26:57.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3727,
946295673,1025263959,"""What did you mean by pausing and resuming jobs? I don't think that `ants` should interfere with the internal logic, or you were talking about `ants` intercepting new tasks (by `pool.Pause()`) and undoing it (by `pool.Resume()`)?""",panjf2000,7496278,2021-10-19T01:39:14.000+00:00,2021-11-27T09:19:37.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3729,
947402907,1028877423,"""你这 benchmark 结果怎么看起来左右对不上？""",panjf2000,7496278,2021-10-20T07:29:52.000+00:00,2021-10-20T07:29:52.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3730,
947476084,1028877423,"""是不是数字占位导致的，我重新go test -bench=. -benchmem  这样运行了还是会存在相同的问题""",liu-song,22676124,2021-10-20T09:10:19.000+00:00,2021-10-20T09:10:19.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3731,
947481834,1028877423,"""https://github.com/liu-song/ants/blob/master/internal/spinlock_test.go#L90-L99\r\n为什么 mutex 这个持锁期间不加逻辑？spinlock 就加？""",panjf2000,7496278,2021-10-20T09:17:41.000+00:00,2021-10-20T09:17:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3732,
947485869,1028877423,"""还有新加的两个 case 又是在测什么？一个持锁休眠 10us，另一个又是 1ms，到底是在测什么？\r\n""",panjf2000,7496278,2021-10-20T09:23:03.000+00:00,2021-10-20T09:23:03.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3733,
947506851,1028877423,"""我的错， 我当时是想看下sleep 不同时间模拟一下在有大量goroutine 运行时，使用backoff 和不使用backoff 算法的差异，当时测试不同的sleep 时间，我重新修改下""",liu-song,22676124,2021-10-20T09:48:24.000+00:00,2021-10-20T09:48:24.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3734,
947746511,1028877423,"""修改了一下，重新跑了一遍，GO版本1.17， https://github.com/liu-song/ants/blob/master/internal/spinlock_test.go\r\n![image](https://user-images.githubusercontent.com/22676124/138116729-0c3569ec-6635-4148-8d88-c15179035ff2.png)\r\n之前的却是跑错了，不知道现在时候是否还有问题，性能之间的差异减少很多。\r\n""",liu-song,22676124,2021-10-20T14:51:58.000+00:00,2021-10-20T14:54:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3735,
948218847,1028877423,"""我在机器上跑了下：\r\n```shell\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/panjf2000/ants/v2/internal\r\ncpu: AMD EPYC 7K62 48-Core Processor\r\nBenchmarkMutex-8                                     \t      72\t  18026460 ns/op\t      31 B/op\t       0 allocs/op\r\nBenchmarkOriginSpinLockRunParalleWithFunc-8          \t      79\t  15781543 ns/op\t      93 B/op\t       0 allocs/op\r\nBenchmarkBackOffSpinLockRunParallelWithFunc-8        \t      79\t  15496798 ns/op\t      44 B/op\t       0 allocs/op\r\nBenchmarkOriginSpinLockRunParalleWithGoroutine-8     \t     686\t   1612450 ns/op\t      87 B/op\t       1 allocs/op\r\nBenchmarkBackOffSpinLockRunParallelWithGoroutine-8   \t     852\t   1531252 ns/op\t      84 B/op\t       1 allocs/op\r\nBenchmarkMutexWithGoroutineLock-8                    \t       1\t13126449087 ns/op\t  609976 B/op\t    2971 allocs/op\r\nBenchmarkOriginSpinLockWithGoroutineLock-8           \t       1\t10025546160 ns/op\t  108848 B/op\t    1073 allocs/op\r\nBenchmarkBackOffSpinLockWithGoroutineLock-8          \t       1\t10043466101 ns/op\t  196048 B/op\t    1251 allocs/op\r\nBenchmarkMutexWithGoroutine-8                        \t1000000000\t         0.01192 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkOriginSpinLockWithGoroutine-8               \t1000000000\t         0.01196 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkBackOffSpinLockWithGoroutine-8              \t1000000000\t         0.01027 ns/op\t       0 B/op\t       0 allocs/op\r\nPASS\r\nok  \tgithub.com/panjf2000/ants/v2/internal\t39.964s\r\n```""",panjf2000,7496278,2021-10-21T03:08:02.000+00:00,2021-10-21T03:08:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3736,
977389724,1058613251,"""另外一个问题:假定我设置的池是100个,在执行的协程也是100个 他们任务的耗时大概是5秒, 假如我在100个协程运行的情况下,直接pool.Tune(10),这个时候会影响到在跑的100个协程立马结束吗? 还是会逐渐等待100协程完成任务最终下降到10个协程池容量\r\n\r\n谢谢上面的解答了""",longrbl,19727273,2021-11-24T01:49:36.000+00:00,2021-11-24T01:49:36.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3758,
977498254,1058613251,"""> 另外一个问题:假定我设置的池是100个,在执行的协程也是100个 他们任务的耗时大概是5秒, 假如我在100个协程运行的情况下,直接pool.Tune(10),这个时候会影响到在跑的100个协程立马结束吗? 还是会逐渐等待100协程完成任务最终下降到10个协程池容量\r\n> \r\n> 谢谢上面的解答了\r\n\r\n不会立刻中止正在运行 worker，我前面已经说过了，要等到那些 worker 运行完之后才退出。""",panjf2000,7496278,2021-11-24T03:59:55.000+00:00,2021-11-24T03:59:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3759,
979947016,583444295,"""> @panjf2000 could use this method?\r\n> \r\n> ```go\r\n> for j := 0; j < batchCount; j++ {\r\n> \t\tbj:=j\r\n> \t\troutinePoll.Submit(func() {\r\n> \t\t\tgenBucketBatch(bj)\r\n> \t\t})\r\n>  }\r\n> ```\r\n\r\nThank you so much! This works for me without creating a new pool with function.""",rohmanhm,7524911,2021-11-26T12:34:47.000+00:00,2021-11-26T12:34:47.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3760,
981383903,1060770678,"""`for {\r\n\tif f := w.pool.popWaitingTask(); f != nil {\r\n\t\tf()\r\n\t\tcontinue\r\n\t}\r\n\tbreak\r\n}`\r\n可以加一个task队列，没有空闲worker的时候，把task push进去，worker在每次执行完任务之后，去check有没有等待的任务。有任务就取出来一个执行。队列清空之后才把自己还回去。\r\n也就是没有空闲worker时候，把阻塞等待worker变成添加task到等待队列。\r\n不过对于task不断膨胀的情况，最后都只能进入失败流程。""",Macu1,5506442,2021-11-29T08:12:19.000+00:00,2021-11-29T08:12:19.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3761,
989806928,1074045507,"""Where is the `wg.Add()`？""",panjf2000,7496278,2021-12-09T12:28:06.000+00:00,2021-12-09T12:28:06.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3766,
989807896,1074084207,"""> 在我不需要重置资源的情况下，我是否不用去考虑调用 pool.Release() 释放资源呢？\r\n\r\n没看懂，说详细点。""",panjf2000,7496278,2021-12-09T12:29:27.000+00:00,2021-12-09T12:29:27.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3767,
991048896,1076267066,"""这么用没问题。""",panjf2000,7496278,2021-12-10T15:07:35.000+00:00,2021-12-10T15:07:35.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3768,
992075987,1074084207,"""> > 在我不需要重置资源的情况下，我是否不用去考虑调用 pool.Release() 释放资源呢？\r\n> \r\n> 没看懂，说详细点。\r\n\r\n抱歉。我尽力描述我的问题。\r\npool.Release() 用于释放资源。（使用默认的池时）是否每一次使用 ant.Submit()，都需要在代码中调用 pool.Release（显式）。它们需要像 Mutex 一样，一定要成对出现吗？""",guowei-gong,62499904,2021-12-13T03:24:44.000+00:00,2021-12-13T03:24:44.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3769,
992137414,1074084207,"""`Release()` 是销毁一个 pool，你只应该在不需要使用 pool 的时候才做，如果后面还要使用，就不应该调用它。""",panjf2000,7496278,2021-12-13T06:05:32.000+00:00,2021-12-13T06:05:32.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3770,
993145890,898973379,"""期望可以暴露出来+1""",LainNetWork,20994069,2021-12-14T04:24:05.000+00:00,2021-12-14T04:24:05.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3771,
994322767,1074045507,"""![image](https://user-images.githubusercontent.com/27792650/146131762-bae511fa-2e33-4cf2-ac38-66a2011c93c4.png)\r\n\r\nI open  pool to 100\r\n\r\n\r\nHow does it feel like there's only one\r\nIt feels so slow""",WyntersN,27792650,2021-12-15T06:01:10.000+00:00,2021-12-15T06:01:10.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3772,
994388509,1074045507,"""Use pprof to find out the root cause.""",panjf2000,7496278,2021-12-15T06:55:11.000+00:00,2021-12-15T14:44:41.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3773,
994468342,1074045507,"""潘大哥咱们都是中国人，为何不用中国话""",WyntersN,27792650,2021-12-15T08:00:07.000+00:00,2021-12-15T08:00:07.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3774,
994471018,1074045507,"""![image](https://user-images.githubusercontent.com/27792650/146146838-5028ec6e-6f5a-42ae-96f6-993868fe27e3.png)\r\n 传入1 2 3 4 5 6 顺序\r\n取出的结果还是 1 2 3 4 5 6顺序\r\n每秒都是3次计数 取出结果的时候没有被 打乱""",WyntersN,27792650,2021-12-15T08:04:13.000+00:00,2021-12-15T08:04:13.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3775,
994862116,1080729448,"""I don't think there is a certain answer for your question, you have to test it among real hardware to get the results.""",panjf2000,7496278,2021-12-15T14:48:08.000+00:00,2021-12-15T14:48:08.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3776,
994866248,1074045507,"""你监控下 goroutine 数量""",panjf2000,7496278,2021-12-15T14:51:46.000+00:00,2021-12-15T14:51:46.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3777,
995416864,1080729448,"""Get，appreciate.""",NICEXAI,19580983,2021-12-16T03:57:12.000+00:00,2021-12-16T03:57:12.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3778,
996792066,1083013181,"""没有什么公式，按照实际业务场景设置，可以尽量设置得大一点没关系，`ants` 不会马上按照所设的容量分配内存，是按需扩容的。""",panjf2000,7496278,2021-12-17T15:05:53.000+00:00,2021-12-17T15:05:53.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3779,
997347598,1074045507,"""![image](https://user-images.githubusercontent.com/27792650/146668117-d5e666eb-b6fd-4bf9-a262-84533fb8ba0d.png)\r\n\r\np.Running() // print 7\r\n\r\n\r\n我开了 300个 为啥只有 7个 goroutine\r\n\r\n\r\n\r\nCentOS6.9 x64  go1.17.3 linux/amd64 ants V2""",WyntersN,27792650,2021-12-19T08:09:40.000+00:00,2021-12-19T08:13:55.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3780,
1010039720,1094905000,"""暂时不支持，需要改动源码。""",panjf2000,7496278,2022-01-11T14:52:02.000+00:00,2022-01-11T14:52:02.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3781,
1011733995,1101114607,"""抱歉, 好像看到了 对应的参数配置 \r\nMaxBlockingTasks int""",shoaly,2660914,2022-01-13T03:07:59.000+00:00,2022-01-13T03:07:59.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3783,
1011770356,1078047238,"""1. 如果协程已经启动了，你无法结束它的。\r\n2. 但是你可以把 ctx 传入到这个具体的执行者中，然后执行者中需要订阅 ctx.Done()，通过 select chan 来 return 跳出。那么你需要拆分的 hardwork 为若干份，分阶段订阅多次 ctx.Done() ，来实现提前打断你的 hardwork 协程\r\n3. 最近在踩坑，晚点可以发一个单元测试给你看看""",allanpk716,1176000,2022-01-13T03:55:28.000+00:00,2022-01-13T03:57:11.000+00:00,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_comments,3784,
