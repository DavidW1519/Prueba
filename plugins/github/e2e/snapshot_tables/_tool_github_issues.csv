github_id,repo_id,number,state,title,body,priority,type,status,author_id,author_name,assignee_id,assignee_name,lead_time_minutes,url,closed_at,github_created_at,github_updated_at,severity,component,_raw_data_params,_raw_data_table,_raw_data_id,_raw_data_remark
339004478,134018330,1,closed,测试发现使用池计算时间并没有缩短，只有内存占用变小了。,"![image](https://user-images.githubusercontent.com/3971390/42390612-0f596eca-817f-11e8-975a-bb8091f5dd5a.png)
您好，我把您的代码拉倒本地，运行了测试，但是发现，测试结果和您截图结果是有差距的，只是内存占用变少了，但是计算的时间并没有您测试的那种提升，希望可以请教一下这里的原因是什么呢？",,,,3971390,ppmoon,0,,731,https://github.com/panjf2000/ants/issues/1,2018-07-07T12:58:38.000+08:00,2018-07-07T00:46:59.000+08:00,2018-07-07T12:58:38.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,7,
340102987,134018330,2,closed,函数执行保护,"```
func (w *Worker) run() {
	//atomic.AddInt32(&w.pool.running, 1)
	go func() {
		for f := range w.task {
			if f == nil {
				atomic.AddInt32(&w.pool.running, -1)
				return
			}
			f()//直接执行了
			w.pool.putWorker(w)
		}
	}()
}
```

那么会不会出现f执行错误崩溃的情况？
加个执行保护不知道行不行。。。新手。",,,,3714381,imnewbe,0,,1921,https://github.com/panjf2000/ants/issues/2,2018-07-12T22:04:26.000+08:00,2018-07-11T14:02:56.000+08:00,2018-07-12T22:04:26.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,8,
344278000,134018330,3,closed,workers 使用slice 还是list问题,"看了下代码， Pool是用slice来装workers， 但Pool的操作中，除了purge和release中需要遍历workers， getWorker和putWorker 都是对队尾出队入队的操作， 是否可以考虑用 container/list ? (假设，还没验证)。


另外还有个问题， 在putWokers时有个append操作， 这里是不是可以在NewPool时， 给workers slice 预分配一些空间呢？",,,,16658738,barryz,0,,1390,https://github.com/panjf2000/ants/issues/3,2018-07-26T10:32:41.000+08:00,2018-07-25T11:22:01.000+08:00,2018-07-26T10:32:41.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,9,
346842831,134018330,5,closed,关于 <-p.freeSignal 的疑惑,"Hi,
    我阅读了源码，对 `<-p.freeSignal` 这句代码有疑惑。 这句代码出现在了多个地方，freeSignal 的作用英文注释我是理解的，并且知道在 `putWorker` 中才进行 `p.freeSignal <- sig{}`

对于下面的代码
```
func (p *Pool) getWorker() *Worker {
	var w *Worker
	waiting := false

	p.lock.Lock()
	idleWorkers := p.workers
	n := len(idleWorkers) - 1
	if n < 0 { // 说明 pool中没有worker了
		waiting = p.Running() >= p.Cap()
	} else { // 说明pool中有worker
		<-p.freeSignal      
		w = idleWorkers[n]  
		idleWorkers[n] = nil
		p.workers = idleWorkers[:n]
	}
	p.lock.Unlock()


func (p *Pool) Release() error {
	p.once.Do(func() { // 保证只释放一次
		p.release <- sig{}
		p.lock.Lock()
		idleWorkers := p.workers
		for i, w := range idleWorkers {
			<-p.freeSignal
			w.task <- nil
			idleWorkers[i] = nil
		}
		p.workers = nil
		p.lock.Unlock()
	})
	return nil
}

```

中的 `<-p.freeSignal`， 那不是要等putWorker触发了才会继续进行吗？如果 putWorker不触发，就一直阻塞在那了，即使 idleWorkers 中可能是有worker的

可否解释下这边的逻辑？谢谢",,,,8605102,pathbox,0,,2182,https://github.com/panjf2000/ants/issues/5,2018-08-03T23:32:00.000+08:00,2018-08-02T11:09:57.000+08:00,2018-08-10T12:06:36.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,11,
347255859,134018330,6,closed,死锁bug,"func (p *Pool) getWorker() *Worker  这个函数的 199行 
必须先解锁在加锁， 要不然会产生死锁

	p.lock.Unlock()
		<-p.freeSignal
		p.lock.Lock()",,,,13118848,lovelly,0,,1786,https://github.com/panjf2000/ants/issues/6,2018-08-04T18:18:41.000+08:00,2018-08-03T12:32:28.000+08:00,2018-08-04T18:18:41.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,12,
348630179,134018330,7,closed,清理过期协程报错,"你好，非常感谢提供这么好用的工具包。我在使用ants时，发现报异常。结果见下图
![image](https://user-images.githubusercontent.com/4555057/43823431-98384444-9b21-11e8-880c-7458b931734a.png)
日志是我在periodicallyPurge里加的调试信息
![image](https://user-images.githubusercontent.com/4555057/43823534-e3c624a8-9b21-11e8-96c6-512e3e08db22.png)

### 原因分析

我认为可能原因是没有处理n==0的情况
```
if n > 0 {
	n++
	p.workers = idleWorkers[n:]
}
```


### 测试代码
```
package main

import (
	""github.com/panjf2000/ants""
	""fmt""
	""time""
	""strconv""
)

func main() {

	pool,err := ants.NewPool(100000)

	if err != nil {
		panic(err)
	}

	for i:=0;i<10000;i++{
		pool.Submit(
			func() error {
				time.Sleep(1 * time.Millisecond)
				fmt.Println(strconv.Itoa(i))
				return nil
			})
	}

	for{
		pool.Submit(
			func() error {
				time.Sleep(10 * time.Millisecond)
			return nil
		})
		time.Sleep(1 * time.Millisecond)
	}
}
```",,,,4555057,huiwq1990,0,,2602,https://github.com/panjf2000/ants/issues/7,2018-08-10T12:06:04.000+08:00,2018-08-08T16:43:15.000+08:00,2018-08-10T12:06:04.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,13,
356703393,134018330,10,closed,高并发下设定较小的worker数量问题,会存在cpu飚升的问题吧？,,,,11763614,Moonlight-Zhao,0,,36198,https://github.com/panjf2000/ants/issues/10,2018-09-29T19:45:00.000+08:00,2018-09-04T16:26:55.000+08:00,2018-09-29T19:45:00.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,16,
364361014,134018330,12,closed,潘少，更新下tag吧,鄙人现在在弄dep依赖管理，有用到你写的ants项目，可是你好像忘记打最新的tag了。最新的tag 3.6是指向ed55924这个提交，git上的最新代码是af376f1b这次提交，两次提交都隔了快5个月了，看到的话，麻烦打一个最新的tag吧。（手动可怜）,,,,29452204,edcismybrother,0,,1293,https://github.com/panjf2000/ants/issues/12,2018-09-28T14:05:58.000+08:00,2018-09-27T16:32:25.000+08:00,2019-04-21T16:19:58.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,18,
381941219,134018330,17,closed,关于优雅退出的问题,"关于这个package优雅退出的问题，我看了一下Release的代码：

`
	// Release Closed this pool.
	func (p *PoolWithFunc) Release() error {
		p.once.Do(func() {
			p.release <- sig{}
			p.lock.Lock()
			idleWorkers := p.workers
			for i, w := range idleWorkers {
				w.args <- nil
				idleWorkers[i] = nil
			}
			p.workers = nil
			p.lock.Unlock()
		})
		return nil
	}
`

release中，好像没有去等待那些已经正在工作的worker处理完它们的工作？
仅仅是回收了空闲的worker

那么在收到程序退出的信号时候，release是不能确保正在工作的worker能妥善完成工作

如果想实现比较好退出方式目前好像是：

ReSize(0) 

不知道我理解的对不对？
",,,,7931755,zplzpl,0,,103594,https://github.com/panjf2000/ants/issues/17,2019-01-29T15:24:37.000+08:00,2018-11-18T16:50:31.000+08:00,2019-01-29T15:24:37.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,23,
382039050,134018330,18,closed,go协程的理解,"你好楼主，向您请教一个协程和线程的问题，协程基于go进程调度，线程基于系统内核调度，调度协程的过程是先调度线程后获得资源再去调度协程。""官方解释： GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously。限制cpu数，本质上是什么，限制并行数?，并行数即同时执行数量?，执行单元即线程?，即限制最大并行线程数量?""",,,,13944100,LinuxForYQH,0,,20213,https://github.com/panjf2000/ants/issues/18,2018-12-03T11:53:50.000+08:00,2018-11-19T10:59:53.000+08:00,2018-12-03T11:53:50.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,24,
382574800,134018330,20,closed,是否考虑任务支持回调函数处理失败的逻辑和任务依赖,#,,,,5668717,kklinan,0,,95398,https://github.com/panjf2000/ants/issues/20,2019-01-25T23:34:03.000+08:00,2018-11-20T17:36:02.000+08:00,2019-01-25T23:34:03.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,26,
388907811,134018330,21,closed,Benchmark 下直接使用 Semaphore 似乎更快呢？,"简单跑了一下 benchmark，Semaphore 更快且很简单

```bash
$ go test -bench .
goos: darwin
goarch: amd64
pkg: github.com/panjf2000/ants
BenchmarkGoroutineWithFunc-4   	       1	3445631705 ns/op
BenchmarkSemaphoreWithFunc-4   	       1	1037219073 ns/op
BenchmarkAntsPoolWithFunc-4    	       1	1138053222 ns/op
BenchmarkGoroutine-4           	       2	 731850771 ns/op
BenchmarkSemaphore-4           	       2	 914855967 ns/op
BenchmarkAntsPool-4            	       1	1094379445 ns/op
PASS
ok  	github.com/panjf2000/ants	33.173s
```
那 Ants 在什么情况下有优势呢？",,,,720086,huangjunwen,0,,8392,https://github.com/panjf2000/ants/issues/21,2018-12-14T14:01:07.000+08:00,2018-12-08T18:08:17.000+08:00,2018-12-14T14:01:07.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,27,
401277739,134018330,22,closed,是否考虑 worker 中添加  PanicHandler ？,比方说在创建 Pool 的时候传入一个 PanicHandler，然后在每个 worker 创建的时候 recover 之后传给 PanicHandler  处理。否则池子里如果发生 panic 会直接挂掉整个进程。,,,,8923413,choleraehyq,0,,1174,https://github.com/panjf2000/ants/issues/22,2019-01-22T13:41:34.000+08:00,2019-01-21T18:06:56.000+08:00,2019-01-22T13:41:34.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,28,
402513849,134018330,24,closed,提交任务不阻塞,`Pool.Submit`和`PoolWithFunc.Server`提交任务，如果没有空的worker，会一直阻塞。建议增加不阻塞的接口，当前失败时直接返回错误。,,,,5044825,tenfyzhong,0,,300032,https://github.com/panjf2000/ants/issues/24,2019-08-20T18:56:30.000+08:00,2019-01-24T10:24:13.000+08:00,2019-08-20T18:56:30.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,30,
405951301,134018330,25,closed,use example errors,"./antstest.go:37:14: cannot use syncCalculateSum (type func()) as type ants.f in argument to ants.Submit
./antstest.go:45:35: cannot use func literal (type func(interface {})) as type ants.pf in argument to ants.NewPoolWithFunc
",,,,5244267,jiashiwen,0,,3088,https://github.com/panjf2000/ants/issues/25,2019-02-04T17:11:52.000+08:00,2019-02-02T13:43:38.000+08:00,2019-02-04T17:11:52.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,31,
413968505,134018330,26,closed,running可能大于cap的问题,"running与cap的比较判断与incRuning分开执行的, 可能会出现running大于cap的问题?
`func (p *Pool) retrieveWorker() *Worker {
	var w *Worker

	p.lock.Lock()
	idleWorkers := p.workers
	n := len(idleWorkers) - 1
	if n >= 0 {
		w = idleWorkers[n]
		idleWorkers[n] = nil
		p.workers = idleWorkers[:n]
		p.lock.Unlock()
	} else if p.Running() < p.Cap() {
		p.lock.Unlock()
		if cacheWorker := p.workerCache.Get(); cacheWorker != nil {
			w = cacheWorker.(*Worker)
		} else {
			w = &Worker{
				pool: p,
				task: make(chan func(), workerChanCap),
			}
		}
		w.run()`",,,,10361713,Ainiroad,0,,21872,https://github.com/panjf2000/ants/issues/26,2019-03-12T20:01:57.000+08:00,2019-02-25T15:29:33.000+08:00,2019-03-12T20:01:57.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,32,
419183961,134018330,27,closed,为何goroutine一直上不去，用户量也打不上去,"为何goroutine一直上不去，用户量也打不上去
是我用的有问题吗？

websocket server
https://github.com/im-ai/pushm/blob/master/learn/goroutine/goroutinepoolwebsocket.go

websocket cient
https://github.com/im-ai/pushm/blob/master/learn/goroutine/goroutinepoolwebsocketclient.go
",,,,38367404,liliang8858,0,,37496,https://github.com/panjf2000/ants/issues/27,2019-04-05T22:05:20.000+08:00,2019-03-10T21:08:52.000+08:00,2019-04-05T22:05:20.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,33,
419268851,134018330,28,closed,cap 和 running 比较的问题,"这是我在 Playground 上面的代码 https://play.golang.org/p/D94YUU3FnX6
atomic 只能保证自增自减时的原子操作，在比较过程中，其他线程对变量进行了操作 比较过程并无感知，所以这个比较结果 不是完全正确的，想要实现 比较的数量完全正确，只能在修改和比较两个值的地方加锁
像 #26 说的是对的",,,,29243953,naiba,0,,237002,https://github.com/panjf2000/ants/issues/28,2019-08-23T00:27:37.000+08:00,2019-03-11T10:24:41.000+08:00,2019-08-23T00:27:37.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,34,
424634533,134018330,29,closed,任务传参,"你好，你的项目太酷了👍

https://github.com/panjf2000/ants/blob/master/pool.go#L124 貌似不支持带参数的任务, 请问传参是用闭包的方式吗?
",,,,8509898,prprprus,0,,999,https://github.com/panjf2000/ants/issues/29,2019-03-25T17:32:11.000+08:00,2019-03-25T00:52:21.000+08:00,2019-03-25T17:45:05.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,35,
429972115,134018330,31,closed,Add go.mod,,,,,48135919,tsatke,0,,3474,https://github.com/panjf2000/ants/issues/31,2019-04-08T17:45:31.000+08:00,2019-04-06T07:50:36.000+08:00,2019-10-17T11:12:19.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,37,
433564955,134018330,32,closed,关于版本问题，我发现小版本(0.0.x)这种更新就会不向下兼容？,"如题，我感觉这样不好。

功能版本号不向下兼容能理解

修复问题的版本号也不向下兼容，难以理解。",,,,7931755,zplzpl,0,,7440,https://github.com/panjf2000/ants/issues/32,2019-04-21T15:16:26.000+08:00,2019-04-16T11:16:02.000+08:00,2019-04-21T15:16:26.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,38,
434069015,134018330,33,closed,support semantic versioning.,"建议将发布的tag兼容为semantic versioning，vX.Y.Z。go modules对此支持比较良好。
https://semver.org/
https://research.swtch.com/vgo-import",,,,1284892,jjeffcaii,0,,6090,https://github.com/panjf2000/ants/issues/33,2019-04-21T16:25:20.000+08:00,2019-04-17T10:55:11.000+08:00,2019-04-21T16:25:20.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,39,
435486645,134018330,34,closed,Important announcement about <ants> from author !!!,"**Dear users of `ants`:**
I am apologetically telling you that I have to dump all tags which already presents in `ants` repository.

The reason why I'm doing so is to standardize the version management with `Semantic Versioning`, which will make a formal and clear dependency management in go, for go modules, godep, or glide, etc. So I decide to start over the tag sequence, you could find more details in [Semantic Versioning](https://semver.org/) and [Semantic Import Versioning](https://research.swtch.com/vgo-import), related issue: #32, #33 (very thankful to @jjeffcaii and @zplzpl who provided the suggestions about it).

I ought to apologize for the bothers brought by this change, the arch-criminal who leads to this issue would be my lack of concept about `Semantic Versioning`, I will spend more times learning the knowledge afterwards. 

Once again, sorry for your costs in this change and thanks for your support to `ants`! 

*Have fun!*

**Best regards,
Andy Pan**
",,,,7496278,panjf2000,0,,23484,https://github.com/panjf2000/ants/issues/34,2019-05-07T23:35:08.000+08:00,2019-04-21T16:10:28.000+08:00,2019-05-07T23:35:08.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,40,
461280653,134018330,35,closed,worker exit on panic,"个人认为PanicHandler设计不妥。
1.无PanicHandler时，抛出给外面的不是panic,外层感受不到。
2.无论有没有PanicHandler，都会导致worker退出，最终pool阻塞住全部任务。",,,,38849208,king526,0,,74481,https://github.com/panjf2000/ants/issues/35,2019-08-18T04:33:10.000+08:00,2019-06-27T11:11:49.000+08:00,2019-08-18T04:33:10.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,41,
462631417,134018330,37,closed,请不要再随意变更版本号了。。。,之前用的是 3.9.9，结果今天构建出了问题，一看发现这个版本没了，变成 1.0.0。这种变更完全不考虑现有用户的情况。希望以后不要随意变更了,,,,8923413,choleraehyq,0,,140,https://github.com/panjf2000/ants/issues/37,2019-07-01T20:37:55.000+08:00,2019-07-01T18:17:15.000+08:00,2019-07-02T18:17:31.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,43,
472125082,134018330,38,closed,retrieveWorker与revertWorker之间会导致死锁,"func (p *Pool) retrieveWorker() *Worker {
	var w *Worker

	**p.lock.Lock()**
	idleWorkers := p.workers
	n := len(idleWorkers) - 1
	if n >= 0 {
		w = idleWorkers[n]
		idleWorkers[n] = nil
		p.workers = idleWorkers[:n]
		p.lock.Unlock()
	} else if p.Running() < p.Cap() {
		p.lock.Unlock()
		if cacheWorker := p.workerCache.Get(); cacheWorker != nil {
			w = cacheWorker.(*Worker)
		} else {
			w = &Worker{
				pool: p,
				task: make(chan func(), workerChanCap),
			}
		}
		w.run()
	} else {
		for {
			**p.cond.Wait()** 
			l := len(p.workers) - 1
			if l < 0 {
				continue
			}
			w = p.workers[l]
			p.workers[l] = nil
			p.workers = p.workers[:l]
			break
		}
		**p.lock.Unlock()**
	}
	return w
}

// revertWorker puts a worker back into free pool, recycling the goroutines.
func (p *Pool) revertWorker(worker *Worker) bool {
	if CLOSED == atomic.LoadInt32(&p.release) {
		return false
	}
	worker.recycleTime = time.Now()
	**p.lock.Lock()** // 协程池满了之后获取不到锁
	p.workers = append(p.workers, worker)
	// Notify the invoker stuck in 'retrieveWorker()' of there is an available worker in the worker queue.
	p.cond.Signal()
	**p.lock.Unlock()**
	return true
}
",,,,1290360,wwjiang,0,,67,https://github.com/panjf2000/ants/issues/38,2019-07-24T16:40:01.000+08:00,2019-07-24T15:32:58.000+08:00,2019-07-24T16:40:01.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,44,
483164833,134018330,42,closed,带选项的初始化函数，我觉得用 functional options 更好一点,"以下是示意代码
如果用 functional options，原来的写法是
```
ants.NewPool(10)
```
新的写法，如果不加 option，写法是不变的，因为 options 是作为可变参数传进去的。如果要加 option，只需要改成
```
ants.NewPool(10, ants.WithNonblocking(true))
```
这样。

现在是直接传一个 Option 结构体进去，所有的地方都要改，感觉很不优雅。
具体 functional options 的设计可以看 rob pike 的一篇博客 https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html",,,,8923413,choleraehyq,0,,732,https://github.com/panjf2000/ants/issues/42,2019-08-21T22:32:51.000+08:00,2019-08-21T10:20:08.000+08:00,2019-08-21T22:32:51.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,48,
483736247,134018330,43,closed,1.3.0 是不兼容更新,Pool 里那些暴露出来的字段（PanicHandler 之类的）都没了，这是一个不兼容更新，根据语义化版本的要求要发大版本。,,,,8923413,choleraehyq,0,,652,https://github.com/panjf2000/ants/issues/43,2019-08-22T21:22:10.000+08:00,2019-08-22T10:29:34.000+08:00,2019-08-22T21:22:10.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,49,
484311063,134018330,44,closed,1.1.1 -> 1.2.0 也是不兼容更新,Pool.Release 的返回值没了,,,,8923413,choleraehyq,0,,3068,https://github.com/panjf2000/ants/issues/44,2019-08-25T14:36:14.000+08:00,2019-08-23T11:27:38.000+08:00,2019-08-25T14:36:14.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,50,
484885860,134018330,45,closed,"p.Tune is only for cutting down pool size, but not support enlarge.","In the Tune Method, the scale up the pool size should be supported also. 
So, before do the pool size change, check which one is bigger for the p.Running() and size, the using the bigger one to minus the small one, then assign the result to diff. 
What do you think? 
-------------------------------
func (p *Pool) Tune(size uint) 
...
**### diff := p.Running() - int(size)**
	for i := 0; i < diff; i++ {
		p.retrieveWorker().task <- nil
	}",,,,31562832,laodano1,0,,168,https://github.com/panjf2000/ants/issues/45,2019-08-25T14:20:09.000+08:00,2019-08-25T11:31:11.000+08:00,2019-08-25T14:20:09.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,51,
484923460,134018330,46,closed,About the ExpiryDuration of ants,worker的ExpiryDuration时间怎么设置，一般设置成多少比较合适？,,,,41182093,ymichaelson,0,,2469,https://github.com/panjf2000/ants/issues/46,2019-08-27T13:13:44.000+08:00,2019-08-25T20:04:29.000+08:00,2019-08-27T13:13:44.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,52,
485565755,134018330,47,closed,Nonstandard operation to the Existing tag,我们的项目依赖了 2.0.0-alpha，今天一构建发现 2.0.0-alpha 又没了,,,,8923413,choleraehyq,7496278,panjf2000,86,https://github.com/panjf2000/ants/issues/47,2019-08-27T13:10:32.000+08:00,2019-08-27T11:44:02.000+08:00,2019-08-27T13:10:32.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,53,
491601411,134018330,49,closed,Checksum mismatch for go 1.13,"Expect (go version go1.12.9 darwin/amd64):

```
→ go mod tidy -v
go: downloading github.com/panjf2000/ants v1.2.0
go: extracting github.com/panjf2000/ants v1.2.0
```

Actual (go version go1.13 darwin/amd64)
```
→ go mod tidy -v
verifying github.com/panjf2000/ants@v1.2.0: checksum mismatch
        downloaded: h1:Ufw4aDz9RqH1RVblx2W9L9Uv5vSX5apbX5+peR7LQ5k=
        sum.golang.org: h1:pMQ1/XpSgnWx3ro4y1xr/uA3jXUsTuAaU3Dm0JjwggE=

SECURITY ERROR
This download does NOT match the one reported by the checksum server.
The bits may have been replaced on the origin server, or an attacker may
have intercepted the download attempt.

For more information, see 'go help module-auth'.
```

---

**UPD**: mb this issue will be useful - https://github.com/golang/go/issues/33665

---

**UPD**: how resolve issue step by step (macOS):
- sudo go clean -modcache
- git checkout go.sum
- go mod tidy -v

---

**UPD** for Linux:
- `cd /another/path`
- `go clean -modcache`
- `cd /project/path`
- `go mod tidy`",,,,888650,im-kulikov,7496278,panjf2000,943402,https://github.com/panjf2000/ants/issues/49,2021-06-26T22:22:09.000+08:00,2019-09-10T19:00:06.000+08:00,2021-06-26T22:22:09.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,55,
492083734,134018330,50,closed,worker 在 revertworker 返回 false 退出时没有 decRunning,"**Describe the bug**
A clear and concise description of what the bug is.
retrieveWorker 中，有一个分支是判 p.Running() < p.Cap()，然后 spawnWorker；由于这个地方没锁，可能很多个 goroutine 都进入到了这个地方，超过了 Cap 的数量。

worker 完成工作之后，revertWorker，会发现 Running > Cap ，返回 false，worker 就会退出，退出前没有减 Running，导致 Running 始终大于 Cap，池子卡死。

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error
生产环境高负载下压出来的。

**Expected behavior**
A clear and concise description of what you expected to happen.
导致池子卡住。

**Error messages/Trace logs**
If applicable, add some logs to help explain your problem.

**System info (please complete the following information):**
 - OS: [e.g. linux, macOS]
 - Go Version [e.g. 1.12]

**Additional context**
Add any other context about the problem here.
",,,,8923413,choleraehyq,7496278,panjf2000,1008,https://github.com/panjf2000/ants/issues/50,2019-09-12T09:00:52.000+08:00,2019-09-11T16:12:26.000+08:00,2019-09-12T09:00:52.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,56,
492130196,134018330,52,closed,workerCache 没有初始化,"**Describe the bug**
A clear and concise description of what the bug is.
没有设置 New 函数，这个是忘了还是有什么玄机呢
**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Error messages/Trace logs**
If applicable, add some logs to help explain your problem.

**System info (please complete the following information):**
 - OS: [e.g. linux, macOS]
 - Go Version [e.g. 1.12]

**Additional context**
Add any other context about the problem here.
",,,,8923413,choleraehyq,7496278,panjf2000,200,https://github.com/panjf2000/ants/issues/52,2019-09-11T21:06:46.000+08:00,2019-09-11T17:46:11.000+08:00,2019-09-11T21:06:46.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,58,
509545524,134018330,55,closed,是否可以添加SubmitQueue类似的接口,"现在submit的任务执行顺序可以认为是随机的，但是有应用的情况是处理数据时有顺序关系，用户可以用队列来处理此类任务，但是每个task handler中都增加了队列的代码，感觉还是有点累赘。

如果ants有SumbitQueue(queueName interface{}, task func())error 这样的接口，则使用起来感觉方便很多",,,,47293522,yangjuncode,7496278,panjf2000,560,https://github.com/panjf2000/ants/issues/55,2019-10-20T22:05:46.000+08:00,2019-10-20T12:45:37.000+08:00,2019-10-20T22:05:47.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,61,
513276141,134018330,56,closed,非阻塞在PoolOverload时进入等待队列,"**Is your feature request related to a problem? Please describe.**
submit的函数如果是递归函数，则如果是阻塞模式，在递归深度较大的时候，会因为worker用光，程序直接被阻塞了，如果调整为非阻塞模式，则会在worker用光之后，后面的任务直接返回ErrPoolOverload而被舍弃。我是在遍历目录的时候遇到的这个问题。

**Describe the solution you'd like**
增加一个配置项，非阻塞模式下，可以选择增加一个等待队列，而不是舍弃。

**Describe alternatives you've considered**
增加一个channel，用于task完成后通知等待队列


",,,,16379361,HaoKunT,7496278,panjf2000,176,https://github.com/panjf2000/ants/issues/56,2019-10-28T23:29:24.000+08:00,2019-10-28T20:33:09.000+08:00,2019-10-28T23:29:24.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,62,
515876300,134018330,57,closed,请问 bytedance 的什么项目使用了 ants？,看 readme 里写了 bytedance,,,,8923413,choleraehyq,0,,154,https://github.com/panjf2000/ants/issues/57,2019-11-01T13:13:48.000+08:00,2019-11-01T10:39:33.000+08:00,2019-11-01T13:13:48.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,63,
519634014,134018330,58,closed,业务逻辑 panic 问题,"`package main

import (
	""fmt""
	""net""
	""sync""
	""time""

	""github.com/panjf2000/ants/v2""
)



func doPortScan(i interface{}) {
	
	port := i.(int32)

	_, err := net.DialTimeout(""tcp"", fmt.Sprintf(""192.168.20.1:%d"", port), time.Second*1)
	if err != nil {
		return
	}

	fmt.Printf(""Port  %d is open\n"", port)


}




func main() {
	defer ants.Release()

	runTimes := 65535

	// Use the common pool.
	var wg sync.WaitGroup


	// Use the pool with a method,
	// set 10 to the capacity of goroutine pool and 1 second for expired duration.
	p, _ := ants.NewPoolWithFunc(300, func(i interface{}) {
		doPortScan(i)
		wg.Done()
	})
	defer p.Release()
	// Submit tasks one by one.
	for i := 0; i < runTimes; i++ {
		wg.Add(1)

		_ = p.Invoke(int32(i))
	}
	wg.Wait()
	fmt.Printf(""running goroutines: %d\n"", p.Running())

}
`
崩溃时的现象如下：
`
goroutine 543 [runnable]:
github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run.func1(0xc000255e00)
	/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:65 +0x85
created by github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run
	/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:49 +0x4c

goroutine 544 [runnable]:
syscall.syscall(0x108b820, 0x25, 0xc00048800c, 0x10, 0xffffffffffffffff, 0xffffffffffffffff, 0x24)
	/usr/local/go/src/runtime/sys_darwin.go:63 +0x2e
syscall.connect(0x25, 0xc00048800c, 0x10, 0x0, 0x0)
	/usr/local/go/src/syscall/zsyscall_darwin_amd64.go:91 +0x5c
syscall.Connect(0x25, 0x1158f40, 0xc000488000, 0x111ac80, 0x1)
	/usr/local/go/src/syscall/syscall_unix.go:251 +0x62
net.(*netFD).connect(0xc0000e2180, 0x115a280, 0xc0003ff200, 0x0, 0x0, 0x1158f40, 0xc000488000, 0x0, 0x0, 0x0, ...)
	/usr/local/go/src/net/fd_unix.go:70 +0x7b
net.(*netFD).dial(0xc0000e2180, 0x115a280, 0xc0003ff200, 0x115a7a0, 0x0, 0x115a7a0, 0xc000255e90, 0x0, 0x1, 0xc000061890)
	/usr/local/go/src/net/sock_posix.go:149 +0xff
net.socket(0x115a280, 0xc0003ff200, 0x1133ff4, 0x3, 0x2, 0x1, 0x0, 0x0, 0x115a7a0, 0x0, ...)
	/usr/local/go/src/net/sock_posix.go:70 +0x1c0
net.internetSocket(0x115a280, 0xc0003ff200, 0x1133ff4, 0x3, 0x115a7a0, 0x0, 0x115a7a0, 0xc000255e90, 0x1, 0x0, ...)
	/usr/local/go/src/net/ipsock_posix.go:141 +0x141
net.(*sysDialer).doDialTCP(0xc0000e2100, 0x115a280, 0xc0003ff200, 0x0, 0xc000255e90, 0x110a680, 0x123ab20, 0x0)
	/usr/local/go/src/net/tcpsock_posix.go:65 +0xc2
net.(*sysDialer).dialTCP(0xc0000e2100, 0x115a280, 0xc0003ff200, 0x0, 0xc000255e90, 0xc034fda0d3, 0x121ffc0, 0xc000061ad0)
	/usr/local/go/src/net/tcpsock_posix.go:61 +0xd7
net.(*sysDialer).dialSingle(0xc0000e2100, 0x115a280, 0xc0003ff200, 0x11593c0, 0xc000255e90, 0x0, 0x0, 0x0, 0x0)
	/usr/local/go/src/net/dial.go:578 +0x36e
net.(*sysDialer).dialSerial(0xc0000e2100, 0x115a280, 0xc0003ff200, 0xc0000b38a0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0)
	/usr/local/go/src/net/dial.go:546 +0x221
net.(*Dialer).DialContext(0xc000061e40, 0x115a240, 0xc0000ce008, 0x1133ff4, 0x3, 0xc0000ce6f0, 0x10, 0x0, 0x0, 0x0, ...)
	/usr/local/go/src/net/dial.go:424 +0x666
net.(*Dialer).Dial(...)
	/usr/local/go/src/net/dial.go:347
net.DialTimeout(0x1133ff4, 0x3, 0xc0000ce6f0, 0x10, 0x3b9aca00, 0xc0000ce6f0, 0x10, 0x0, 0x0)
	/usr/local/go/src/net/dial.go:333 +0xb5
main.doPortScan(0x10fe540, 0xc0000ce6d4)
	/Users/mac/go/src/github.com/panjf2000/ants/examples/main.go:42 +0xd8
main.main.func1(0x10fe540, 0xc0000ce6d4)
	/Users/mac/go/src/github.com/panjf2000/ants/examples/main.go:90 +0x3e
github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run.func1(0xc000255e30)
	/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:69 +0xbd
created by github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run
	/Users/mac/go/src/github.com/panjf2000/ants/worker_func.go:49 +0x4c
exit status 2`",,,,36106762,pwnfun,7496278,panjf2000,7144,https://github.com/panjf2000/ants/issues/58,2019-11-13T10:19:02.000+08:00,2019-11-08T11:14:31.000+08:00,2019-11-13T10:19:03.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,64,
524118492,134018330,59,open,优先级队列支持,"**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
优先级调度。比如除了 Submit 之外，提供 SubmitUrge 接口之类的，提供多优先级调度功能

**Describe the solution you'd like**
A clear and concise description of what you want to happen.
最简单的办法，可以做三个队列，最高的是 urgent，最低的是 delayed，中间的就是现在的队列。调度策略可以开成 interface 方便定制，简单的策略可以类似于内核 io 调度的 deadline 调度器。

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.
只能做多个 pool，但是也不好实现多个 pool 之间的优先级调度。

**Additional context**
Add any other context or screenshots about the feature request here.
确实有高优先级调度的需求
",,,,8923413,choleraehyq,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/59,,2019-11-18T11:49:17.000+08:00,2021-07-03T16:30:50.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,65,
524800426,134018330,60,closed,goroutine 不是协程，项目描述不准确。,"**Describe the bug**
A clear and concise description of what the bug is.

目前的项目描述里提到，“ ants 是一个高性能且低损耗的 goroutine 协程池。”，这个说法是不正确的，goroutine 不是协程。

首先，goroutine 不是我们通常说的协作式调度，绝大部分的 go 程序都是没有 runtime.Gosched 的。如果认为 go scheduler 内部的抢占调度目前不完善，那 linux 内核在 2.几 某个版本之前也没有完善的抢占调度，难道 linux 线程也是协程吗。

另外，预期 Go 1.14 就有完全的抢占调度了，更跟协程不搭边了。

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Error messages/Trace logs**
If applicable, add some logs to help explain your problem.

**System info (please complete the following information):**
 - OS: [e.g. linux, macOS]
 - Go Version: [e.g. 1.12]
 - ants version: [e.g. v2.2.2]

**Additional context**
Add any other context about the problem here.
",,,,8923413,choleraehyq,7496278,panjf2000,2763,https://github.com/panjf2000/ants/issues/60,2019-11-21T12:24:33.000+08:00,2019-11-19T14:21:33.000+08:00,2020-04-07T09:27:12.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,66,
524906588,134018330,61,closed,为什么我无法获取到 v2 版本,"go get -u github.com/panjf2000/ants/v2

```
package github.com/panjf2000/ants/v2: cannot find package ""github.com/panjf2000/ants/v2"" in any of:
        /usr/local/go/src/github.com/panjf2000/ants/v2 (from $GOROOT)
        /Users/xxx/Desktop/go/gin/src/github.com/panjf2000/ants/v2 (from $GOPATH)

```",,,,10721527,chinawangyu,7496278,panjf2000,4,https://github.com/panjf2000/ants/issues/61,2019-11-19T18:16:01.000+08:00,2019-11-19T18:11:36.000+08:00,2019-11-19T18:16:02.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,67,
524907361,134018330,62,closed,为什么我无法获取到 v2 版本,"go get -u github.com/panjf2000/ants/v2

```
package github.com/panjf2000/ants/v2: cannot find package ""github.com/panjf2000/ants/v2"" in any of:
        /usr/local/go/src/github.com/panjf2000/ants/v2 (from $GOROOT)
        /Users/xxx/Desktop/go/gin/src/github.com/panjf2000/ants/v2 (from $GOPATH)

```",,,,10721527,chinawangyu,7496278,panjf2000,2535,https://github.com/panjf2000/ants/issues/62,2019-11-21T12:28:17.000+08:00,2019-11-19T18:12:56.000+08:00,2019-11-21T12:28:17.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,68,
526983024,134018330,63,closed,go1.8无法运行benchmark测试,"你好，我的本地环境和生产环境都是go1.8，目前通过go get会报cannot find package ""github.com/panjf2000/ants/v2/internal”错误，而go1.8还不支持go modules。
想问一下这个代码需要做哪些变动才可以运行在go1.8上呢？你们可以提供支持么？
谢谢~ #62 ",,,,15848536,Kuching,0,,1306,https://github.com/panjf2000/ants/issues/63,2019-11-23T10:25:15.000+08:00,2019-11-22T12:39:07.000+08:00,2019-11-23T10:25:15.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,69,
529767734,134018330,64,closed,"Hi, boys","**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
",,,,16028668,jjshi,7496278,panjf2000,288,https://github.com/panjf2000/ants/issues/64,2019-11-28T21:28:37.000+08:00,2019-11-28T16:40:25.000+08:00,2019-11-28T21:28:37.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,70,
529770094,134018330,65,closed,internal.NewSpinLock about runtime.Gosched(),"I see that internal.NewSpinLock() is internal Lock. Why don't use sync.Mutex?
runtime.Gosched() is put current goroutine to global run queue tail.
Hope your response.",,,,16028668,jjshi,7496278,panjf2000,7234,https://github.com/panjf2000/ants/issues/65,2019-12-03T17:19:56.000+08:00,2019-11-28T16:45:36.000+08:00,2020-10-18T22:46:07.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,71,
530708513,134018330,67,closed,增加调试功能,"**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
有时任务发生问题，一直不结束或任务太多， 想知道是哪些任务

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

增加调试功能， 为 任务增加 任务名，加入时间等信息， 然后 Pool 添加 Stats() []TaskInfo
为 Submit 添加一个些可选项，用户添加任务名，加入时间，
Submit(cb func(), opts ...TaskOption)
",,,,1052632,runner-mei,7496278,panjf2000,213,https://github.com/panjf2000/ants/issues/67,2019-12-01T21:59:08.000+08:00,2019-12-01T18:25:29.000+08:00,2019-12-01T21:59:08.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,73,
537859668,134018330,68,closed,worker的task问题,"我初略的看了一下启动的过程，有几个疑问想请教一下
在newpool之后，想要执行任务需要调用pool的submit。在submit里面，有一段代码是w.task <- task.
w是worker的意思，但worker的task chan长度只有1，所以有并发任务来的时候，都在抢占这个w.task。要怎么保证任务的先后顺序的？",,,,11144120,nagasawaja,7496278,panjf2000,119,https://github.com/panjf2000/ants/issues/68,2019-12-14T13:32:54.000+08:00,2019-12-14T11:33:30.000+08:00,2019-12-14T14:05:43.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,74,
538994753,134018330,69,closed,提两个小需求,"1. 在批量提交任务后，获取每个任务对应的返回值.
2. 在批量提交任务时，可以携带一个超时参数，表示这批任务执行时，如果超时，则已执行的任务正常返回执行结果，未执行的任务都提前结束（或也返回执行结果，但是标明是timeout）。",,,,9315278,bglmmz,7496278,panjf2000,1011,https://github.com/panjf2000/ants/issues/69,2019-12-18T11:54:53.000+08:00,2019-12-17T19:03:45.000+08:00,2021-09-28T16:33:48.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,75,
542347075,134018330,70,closed,关于retrieveWorker中一小段代码的疑问,"```go
if n >= 0 {
		w = idleWorkers[n]
		idleWorkers[n] = nil
		p.workers = idleWorkers[:n]
		p.lock.Unlock()
	} else if p.Running() < p.Cap() {
		p.lock.Unlock()
		spawnWorker()
	} else {
		if p.nonblocking {
			p.lock.Unlock()
			return nil
		}
```
 if p.Running() < p.Cap() 判断以后符合条件解锁，再重新创建worker，worker会在run的时候才进行running数的加1会不会有worker在run的时候让出cpu，此时另一个协程执行到p.Running() < p.Cap()判断也符合，从而导致最终的running其实是大于cap的情况呢",,,,35391181,HobbyBear,7496278,panjf2000,909,https://github.com/panjf2000/ants/issues/70,2019-12-26T13:14:15.000+08:00,2019-12-25T22:05:01.000+08:00,2019-12-26T13:14:15.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,76,
543230040,134018330,71,closed,如何限制httpserver的最大协程数,与httpserver集成好像并没能解决内置http包来一个请求开一个goroutine的问题，请问该如何限制内置http包的最大协程数呢？,,,,44720525,xuyang404,7496278,panjf2000,4796,https://github.com/panjf2000/ants/issues/71,2020-01-01T08:19:53.000+08:00,2019-12-29T00:23:21.000+08:00,2020-01-01T08:19:53.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,77,
543871027,134018330,72,closed,安装v1版本问题？,"我用go get -u github.com/panjf2000/ants安装后，为啥在pool.go里还有v2的东西？
""github.com/panjf2000/ants/v2/internal""
",,,,9315278,bglmmz,7496278,panjf2000,2122,https://github.com/panjf2000/ants/issues/72,2020-01-01T08:19:23.000+08:00,2019-12-30T20:56:57.000+08:00,2020-01-01T08:19:23.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,78,
548918163,134018330,73,closed,how to wait for completion,"I need graceful shutdown of my app with ants.PoolWithFunc so i need firstly forbid new tasks, and second wait for completion of already running. How can i do that with ants ?",,,,481307,vtolstov,7496278,panjf2000,184,https://github.com/panjf2000/ants/issues/73,2020-01-14T00:12:11.000+08:00,2020-01-13T21:08:06.000+08:00,2020-01-14T00:12:12.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,79,
550305777,134018330,74,closed,periodicallyPurge可以考虑recover捕获一下panic,"**What is your question about ants?**
Please describe your question meticulously.
虽然看了一下这个函数没可能painc,但是开启goroutine不recover让人心慌。
",,,,31125408,Andrewpqc,7496278,panjf2000,630,https://github.com/panjf2000/ants/issues/74,2020-01-16T11:19:03.000+08:00,2020-01-16T00:48:32.000+08:00,2020-01-17T00:20:18.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,80,
550555088,134018330,75,closed,求教关于 Release 实现的一些疑问,"release 方法的实现为什么要这样释放内存? 

```golang
func (p *PoolWithFunc) Release() {
	p.once.Do(func() {
		atomic.StoreInt32(&p.release, 1)
		p.lock.Lock()
		idleWorkers := p.workers
		for i, w := range idleWorkers {
			w.args <- nil
			idleWorkers[i] = nil
		}
		p.workers = nil
		p.lock.Unlock()
	})
}
```
直接 p.workers = nil 不能做到释放内存的动作吗？
",,,,38727061,chengyayu,7496278,panjf2000,8,https://github.com/panjf2000/ants/issues/75,2020-01-16T11:49:30.000+08:00,2020-01-16T11:41:16.000+08:00,2020-01-16T11:49:30.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,81,
551948830,134018330,76,closed,Use pool as a queue,"**Is your feature request related to a problem? Please describe.**
I have a limited pool (sized pool), but when I reach the capacity of the pool, `Submit()` returns an error (`ErrPoolOverload`) which means the pool is full and no workers available.
Even if i set `Nonblocking` to true in [`Option`].(https://gowalker.org/github.com/panjf2000/ants#Options)
```Go
func main() {
	p, _ := ants.NewPool(2, ants.WithNonblocking(true))

	for i := 0; i < 5; i++ {
		err := p.Submit(func() {
			fmt.Println(""Testing wait for 1 second..."")
			time.Sleep(1 * time.Second)
		})
		if err != nil {
			fmt.Println(""Error: "" + err.Error())
		}
	}

	time.Sleep(500 * time.Second) // Only for test and block main(), something like waitgroup!
}
```
This code returns:
```
Error: too many goroutines blocked on submit or Nonblocking is set
Error: too many goroutines blocked on submit or Nonblocking is set
Error: too many goroutines blocked on submit or Nonblocking is set
Something is here, waiting..
Something is here, waiting..
```

**Describe the solution you'd like**
I think it's better to have something like a (second) queue in ants. tasks submit without any error and complete one-by-one.
In other words, `Submit()` should be non-blocking but it shouldn't return `ErrPoolOverload` error even if capacity is full, and should continue receiving tasks.
I'm not sure if this feature exists in ants or not.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
`go` keyword can do that:
```Go
p, _ := ants.NewPool(2, ants.WithNonblocking(false))

for i := 0; i < 5; i++ {
    go p.Submit(func() {
        fmt.Println(""Testing wait for 1 second..."")
        time.Sleep(1 * time.Second)
    })
}
```
But i think there must be a better way.",,,,50948745,ffb255,7496278,panjf2000,139259,https://github.com/panjf2000/ants/issues/76,2020-04-25T17:39:16.000+08:00,2020-01-20T00:39:17.000+08:00,2020-04-25T17:39:16.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,82,
553711776,134018330,77,closed,如何在ants中接收os.Signal,"我想要在main中监听os.Signal信号，如果有传入ctrl+c的信号，将会退出所有线程。但是在操作中发现键入ctrl+c后，打印不出来“退出”两个字以及任务结果。。麻烦帮忙看看是哪里不对，谢谢

```
package main

import (
	""fmt""
	""github.com/panjf2000/ants/v2""
	""os""
	""os/signal""
	""sync""
	""sync/atomic""
	""syscall""
	""time""
)


var sum int32
var results []int32

func myFunc(i interface{}) {
	n := i.(int32)
	results = append(results, n)
	time.Sleep(10 * time.Millisecond)
	atomic.AddInt32(&sum, n)
	fmt.Printf(""run with %d\n"", n)
}


func main() {
	var wg sync.WaitGroup

	p, _ := ants.NewPoolWithFunc(2, func(i interface{}) {
		myFunc(i)
		wg.Done()

	})

	// Use the common pool.
	defer p.Release()
	// Submit tasks one by one.
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		_ = p.Invoke(int32(i))
	}
	
	//合建chan
	c := make(chan os.Signal)
	//监听指定信号 ctrl+c kill
	signal.Notify(c, os.Interrupt, os.Kill)
	go func() {
		for s := range c {
			switch s {
			case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:
				fmt.Println(""退出"", s)
				ExitFunc()
			default:
				fmt.Println(""other"", s)
			}
		}
	}()
	

	wg.Wait()

	fmt.Printf(""running goroutines: %d\n"", p.Running())
	fmt.Printf(""running sum: %d\n"", sum)
	fmt.Printf(""finish all tasks.\n"")

}

func ExitFunc() {
	fmt.Println(""reslut:"")
	fmt.Println(results)
	fmt.Println(""exit..."")
}
```
",,,,45157320,iiiusky,7496278,panjf2000,1225,https://github.com/panjf2000/ants/issues/77,2020-01-23T22:43:32.000+08:00,2020-01-23T02:18:13.000+08:00,2020-01-23T22:43:33.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,83,
557507246,134018330,78,closed,about revertWorker,"NewPool时，goWorker中的channel大小不需要初始化吗？
workerCache中task channel的大小设置成1/0有什么考虑么？",,,,12018707,blacktoot,7496278,panjf2000,996,https://github.com/panjf2000/ants/issues/78,2020-01-31T14:27:05.000+08:00,2020-01-30T21:50:37.000+08:00,2020-01-31T14:29:28.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,84,
576944665,134018330,80,closed,"当大量协程嵌套时,会出现假死状态","环境:
linux Centos 6.5
golang1.13
现象:
1.创建2个pool:p1,p2
2.从chan不断的拿出消息后在p1创建goroutine
3.p1建立goroutine后,在p2生成100个goroutine
4.ants会永远阻塞,并且会超出协程池本身的限制
![image](https://user-images.githubusercontent.com/16916249/76089201-34294400-5ff4-11ea-8722-bf0763ee0168.png)
",,,,16916249,arch3754,7496278,panjf2000,4227,https://github.com/panjf2000/ants/issues/80,2020-03-09T20:18:09.000+08:00,2020-03-06T21:50:56.000+08:00,2020-03-09T20:18:10.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,86,
583444295,134018330,81,open,how to pass context and other args in pool_func?,"hello, @panjf2000  
`func NewPoolWithFunc(size int, pf func(interface{}), options ...Option)`
in NewPoolWithFunc, pf only have an ingerface{}, but i want to pass at least two args, how to solve tihes?

my run function like :
```
func (s *fileSystemServer) handleOp(
	c *Connection,
	ctx context.Context,
	op interface{}) {
}
```
context is not suggested to put into a struct, how to pass ctx + args as one task to queue?",,,,24663329,kungf,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/81,,2020-03-18T11:49:05.000+08:00,2021-11-26T20:34:47.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,87,
590876739,134018330,82,closed,能否中断未执行完成的任务？,"我创建了一个PoolWithFunc
然后通过一个for循环，用pool.Invoke()来执行任务
我的需求是：我所有的任务有一个统一的deadline，超过就需要让所有任务退出（包括正在执行但是未执行完成，以及还未开始执行的）

请问，用这个ants能实现这个吗？

谢谢！",,,,9315278,bglmmz,7496278,panjf2000,9036,https://github.com/panjf2000/ants/issues/82,2020-04-06T22:23:54.000+08:00,2020-03-31T15:47:29.000+08:00,2020-04-06T22:25:18.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,88,
598490848,134018330,83,closed,为什么不用list作为workerArry 而用切片,"**What is your question about ants?**
Please describe your question meticulously.
为什么不用容器封装worker的容器呢",,,,21356664,zjytra,7496278,panjf2000,85,https://github.com/panjf2000/ants/issues/83,2020-04-12T23:23:14.000+08:00,2020-04-12T21:57:31.000+08:00,2020-04-12T23:23:14.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,89,
598491535,134018330,84,closed,当option.Nonblocking为true,"**What is your question about ants?**
Please describe your question meticulously.
当option.Nonblocking为true提交任务的goroutine要一直循环等到到有空闲工作接收才会向后面执行代码哦",,,,21356664,zjytra,7496278,panjf2000,114,https://github.com/panjf2000/ants/issues/84,2020-04-12T23:55:35.000+08:00,2020-04-12T22:00:40.000+08:00,2020-04-12T23:55:35.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,90,
598516739,134018330,85,closed,pool.Release 不能干掉繁忙的协程哦,"**What is your question about ants?**
Please describe your question meticulously.
可以将task设置为接口,pool释放的时候主动通知task 结束 任务，释放协程",,,,21356664,zjytra,7496278,panjf2000,1130,https://github.com/panjf2000/ants/issues/85,2020-04-13T18:53:23.000+08:00,2020-04-13T00:02:49.000+08:00,2020-04-13T18:53:23.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,91,
599450188,134018330,86,closed,Panic occurred when using nested pools ,"call chain :
```go
pool1:
	antsP, _ := ants.NewPoolWithFunc(len(block.GetTransactions()), func(params interface{}) {
		syncVerify1(params) //handle some verify, this func define another ants pool
		xxxx
	})
	defer antsP.Release()
pool2:
      syncVerify1(params{
            xxxx
           antsP1, _ := ants.NewPoolWithFunc(len(block.GetTransactions()), func(params interface{}) {
		syncVerify2(params)
		xxx
	})
	defer antsP1.Release()//problems happens
      }
```
debug info like this:
```
2020/04/14 17:50:05 worker with func exits from a panic: runtime error: invalid memory address or nil pointer dereference
2020/04/14 17:50:05 worker with func exits from panic: goroutine 55 [running]:
github.com/panjf2000/ants.(*goWorkerWithFunc).run.func1.1(0xc000165b30)
        /data/home/go_workspace/src/trustsql-spv-go/vendor/github.com/panjf2000/ants/worker_func.go:59 +0x140
panic(0xf859e0, 0x18950d0)
        /usr/local/go/src/runtime/panic.go:679 +0x1b2
github.com/panjf2000/ants.(*PoolWithFunc).Release(0x0)
        /data/home/go_workspace/src/trustsql-spv-go/vendor/github.com/panjf2000/ants/pool_func.go:221 +0x22
trustsql-spv-go/validator.Validator.AsyncVerifyBlock(0x0, 0x1, 0xc000196090, 0x25, 0xc00016e4f0, 0xf, 0x1, 0x1, 0x0, 0x0, ...)
        /data/home/go_workspace/src/trustsql-spv-go/validator/validatator.go:113 +0x3b3
trustsql-spv-go/storage.(*BlocksDaoImpl).AsyncStoreBlocks.func1(0xfbef60, 0xc0001dc6e0)
        /data/home/go_workspace/src/trustsql-spv-go/storage/block_dao_impl.go:163 +0x239
trustsql-spv-go/storage.(*BlocksDaoImpl).AsyncStoreBlocks.func2(0xfbef60, 0xc0001dc6e0)
        /data/home/go_workspace/src/trustsql-spv-go/storage/block_dao_impl.go:171 +0x42
github.com/panjf2000/ants.(*goWorkerWithFunc).run.func1(0xc000165b30)
        /data/home/go_workspace/src/trustsql-spv-go/vendor/github.com/panjf2000/ants/worker_func.go:71 +0xbd
created by github.com/panjf2000/ants.(*goWorkerWithFunc).run
        /data/home/go_workspace/src/trustsql-spv-go/vendor/github.com/panjf2000/ants/worker_func.go:49 +0x4c
```",,,,5850861,henkgo,7496278,panjf2000,5488,https://github.com/panjf2000/ants/issues/86,2020-04-18T13:33:38.000+08:00,2020-04-14T18:05:32.000+08:00,2020-04-18T13:33:38.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,92,
607208427,134018330,88,closed,v2.PoolWithFunc has no field or method Serve,"I encounter some build problems, hinting ""myPool.Serve undefined (type *v2.PoolWithFunc has no field or method Serve)""

```
import (
	""fmt""
	""strconv""
	""time""
	""github.com/panjf2000/ants/v2""
)


var tunnel = make(chan string, 1)
func main() {

	//push something to tunnel

	myPool, _ := ants.NewPoolWithFunc(3, Myfunc)
	defer myPool.Release()

	for {
		select {
		case a := <-tunnel:
			go myPool.Serve(a)
		}
	}
}

```
",,,,8937150,huangp0600,7496278,panjf2000,9,https://github.com/panjf2000/ants/issues/88,2020-04-27T11:50:35.000+08:00,2020-04-27T11:41:29.000+08:00,2020-04-27T17:09:25.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,94,
613752194,134018330,90,closed,支持 unlimited 池子大小,"**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
考虑一个情况，当池子运行的函数本身，又需要调用这个池子投放新的任务时，是有死锁的可能的。从使用层面上这个问题很难避免，但是如果池子本身不限制大小，就能避免死锁。

**Describe the solution you'd like**
A clear and concise description of what you want to happen.
支持不限制池子大小的功能。

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.
这很难，需要使用者小心谨慎地使用池子，保证没有同一个池子的嵌套。

**Additional context**
Add any other context or screenshots about the feature request here.
限制并发数的功能完全可以在上层实现，所以没什么损失。
",,,,8923413,choleraehyq,7496278,panjf2000,2146,https://github.com/panjf2000/ants/issues/90,2020-05-08T23:32:48.000+08:00,2020-05-07T11:46:20.000+08:00,2020-05-27T22:14:17.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,96,
624852492,134018330,92,closed,希望能够支持一个小特性,"1.  PoolWithFunc希望能够支持任务池的名称；这样一个server存在多个任务池，方便定位问题；
2. PoolWithFunc中的Invoke方法返回error，希望能区分是非阻塞队列任务池满的error msg，还是阻塞队列都满的error msg错误区分，目前笼统地称为：ErrPoolOverload, 这个不太方便定位问题。",,,,20457624,1046102779,7496278,panjf2000,7128,https://github.com/panjf2000/ants/issues/92,2020-05-31T19:29:10.000+08:00,2020-05-26T20:40:35.000+08:00,2020-05-31T19:29:10.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,98,
624854806,134018330,93,closed,使用过程中遇到的一个比较棘手的问题,我在使用过程中，如果一个serve部署在异构环境中，可能我设置的任务池大小，就不太适用，要么资源打满，要么资源利用率相对比较低，能根据当前cpu和内存使用情况自动动态的调整任务池大小不？,,,,20457624,1046102779,7496278,panjf2000,7124,https://github.com/panjf2000/ants/issues/93,2020-05-31T19:29:23.000+08:00,2020-05-26T20:44:27.000+08:00,2022-01-14T23:57:03.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,99,
629156928,134018330,95,open,Ants + fasthttp,"Hello,

I am using Ants with fasthttp. Is it possible that this both packages are not compatible? 
My Program fetchs 15000 rows from a MysqlDB and request the HTML code for parse 2 strings out of it. 

My memory usage is crazy 1,9g with only 434 open socket files = 434 connections (maximum was around 2800):
`15921 jonny     20   0 3093,3m   1,9g   6,9m S   7,3  25,1  11:59.63 goCheckResults`

root@jdebian:~$ ls -l /proc/15921/fd | wc -l
`434`

**in main():**
```go
client = &fasthttp.Client{
	ReadTimeout:         time.Duration(60) * time.Second,
	MaxIdleConnDuration: time.Duration(600) * time.Second,
	Dial: func(addr string) (net.Conn, error) {
		return fasthttp.DialTimeout(addr, time.Duration(60) * time.Second)
	},
	TLSConfig: &tls.Config{InsecureSkipVerify: true},
}
var wg sync.WaitGroup
p, _ := ants.NewPoolWithFunc(25, func(i interface{}) {
	processRow(i)
	wg.Done()
})
defer p.Release()

i := 0
for results.Next() {
	var current Job

	err = results.Scan(&current....)

	wg.Add(1)
	_ = p.Invoke(&current)
	i++
}
wg.Wait()
```

The function processRow calls 
```go
row := i.(*Job)

req := fasthttp.AcquireRequest()
defer fasthttp.ReleaseRequest(req)

req.SetRequestURI(row.url)
req.Header.SetMethod(""GET"")
req.Header.Add(""User-Agent"", userAgent)

//println(req.Header.String())

resp := fasthttp.AcquireResponse()
defer fasthttp.ReleaseResponse(resp)

//if err := client.Do(req, resp); err != nil {
if err := client.DoTimeout(req, resp, time.Duration(60) * time.Second); err != nil {
	return """", err
}

bodyBytes := resp.Body()
html := string(bodyBytes)

// parse using regex
// db.Exec (....) <- mysql query to update database
```

It is crazy how much memory usage this small program has.",,,,57217666,T200proX7,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/95,,2020-06-02T20:18:17.000+08:00,2020-06-06T04:22:07.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,100,
630445612,134018330,96,closed,可以对某个groutine进行操作吗？（比如手动终止某个groutine）,,,,,59554835,resct,7496278,panjf2000,556,https://github.com/panjf2000/ants/issues/96,2020-06-04T18:59:16.000+08:00,2020-06-04T09:42:38.000+08:00,2020-06-04T21:36:33.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,101,
638116396,134018330,97,closed,SECURITY ERROR: checksum mismatch,"**Description**
Mismatched checksum

**To Reproduce**
Run `go get https://github.com/panjf2000/ants`

Or
1. Import `""github.com/panjf2000/ants""`
1. Run `go mod vendor`

**Expected behavior**
Successful installation of ants as a vendor/dependency

**Error messages/Trace logs**
go get github.com/panjf2000/ants: github.com/panjf2000/ants@v1.2.0: verifying module: checksum mismatch
        downloaded: h1:Ufw4aDz9RqH1RVblx2W9L9Uv5vSX5apbX5+peR7LQ5k=
        sum.golang.org: h1:pMQ1/XpSgnWx3ro4y1xr/uA3jXUsTuAaU3Dm0JjwggE=


**System info (please complete the following information):**
 - OS: 4.15.0-23-generic #25-Ubuntu
 - Go Version: go1.14 linux/amd64
 - ants version: v1.2.0

**Additional context**
SECURITY ERROR
This download does NOT match the one reported by the checksum server.
The bits may have been replaced on the origin server, or an attacker may
have intercepted the download attempt.
",,,,7106251,navid-kalaei,7496278,panjf2000,135,https://github.com/panjf2000/ants/issues/97,2020-06-13T18:01:44.000+08:00,2020-06-13T15:45:49.000+08:00,2020-06-13T18:01:44.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,102,
638596333,134018330,98,closed,pool.Tune does not take effect if the pool is preallocated,"Hello,

May I know the reason behind the p.options.PreAlloc check? 
https://github.com/panjf2000/ants/blob/master/pool.go#L173
`if capacity := p.Cap(); capacity == -1 || size <= 0 || size == capacity || p.options.PreAlloc {
	return
}`

Why can't we tune the pool if it is preallocated?

Thanks.
",,,,6374063,giangvu,7496278,panjf2000,8767,https://github.com/panjf2000/ants/issues/98,2020-06-21T17:05:37.000+08:00,2020-06-15T14:58:03.000+08:00,2020-06-21T17:05:37.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,103,
656493889,134018330,99,closed,goroutines num 一直上涨,"本地压测的话,压测的时候,goroutines 会上涨,但是压测结束后,会恢复.

go version 1.14.2
使用的 ants 版本是 v2.10(换了高版本v2.40 也有这个问题)

使用pprof `/debug/pprof/goroutine` 好多这样的文本
```
goroutine 25824 [chan receive, 21 minutes]:
github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run.func1(0xc0011fce70)
	/www/gopath1.14.2/pkg/mod/github.com/panjf2000/ants/v2@v2.1.0/worker_func.go:65 +0x74
created by github.com/panjf2000/ants/v2.(*goWorkerWithFunc).run
	/www/gopath1.14.2/pkg/mod/github.com/panjf2000/ants/v2@v2.1.0/worker_func.go:49 +0x4c
```
核心的使用代码,每一个请求都会调用 DataQuery 这个函数.
```golang
func DataQuery(mobile, id, name string) DataQuerySkeleton {
	startTime := 123456789
	defer ants.Release()
	var wg sync.WaitGroup
	pUser, _ := ants.NewPoolWithFunc(50, func(para interface{}) {
		fun1(para)
		wg.Done()
	})
	defer pUser.Release()
	queryInputValue := map[string]string{
		TypeMobile: mobile,
		TypeId:    id,
		TypeName: name,
	}
	var inputUser = make(chan *GoroutineUserInputParaType, 3)

	for k, v := range queryInputValue {
		wg.Add(1)
		inPara := &GoroutineUserInputParaType{
			UinfoType: k,
			UinfoPara: v,
			StartTime: 123456789,
		}
		inputUser <- inPara
		pUser.Invoke(inputUser)
	}
	wg.Wait()
	close(inputUser)

	findInfo, minRegisterTime := func3(inputUser)
	totalUserNum := len(findInfo)
	queryInfo := DataQuerySkeleton{}

	if totalUserNum == 0 {
		return queryInfo
	}
	findOrdersStartTime := 423456789
	findUserUsedTime := findOrdersStartTime - startTime

	var inputOrder = make(chan *GoroutineOrderInputParaType, totalUserNum)

	pOrder, _ := ants.NewPoolWithFunc(50, func(para interface{}) {
		fun2(para)
		wg.Done()
	})
	defer pOrder.Release()
	for _, oneUser := range findInfo {
		wg.Add(1)
		inPara := &GoroutineOrderInputParaType{
			UinfoType: oneUser.Type,
			UinfoId:   oneUser.Uinfo.Id,
			StartTime: tools.GetUnixMillis(),
		}
		inputOrder <- inPara
		pOrder.Invoke(inputOrder)
	}
	wg.Wait()
	close(inputOrder)

    ......
	return queryInfo
}
```
",,,,2841874,weichangdong,7496278,panjf2000,42,https://github.com/panjf2000/ants/issues/99,2020-07-14T18:50:32.000+08:00,2020-07-14T18:08:22.000+08:00,2020-07-14T18:50:32.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,104,
662892614,134018330,101,closed,参数动态化,执行的func是否可以添加参数动态  例如  ...interface{},,,,20257788,tsxylhs,7496278,panjf2000,4351,https://github.com/panjf2000/ants/issues/101,2020-07-24T19:42:48.000+08:00,2020-07-21T19:11:31.000+08:00,2020-07-24T19:42:56.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,106,
1101114607,134018330,207,closed,"想问一下, 有没有办法固定pool中协程的数量","**是否支持固定协程池的容量**
Please describe your question meticulously.

有的时候不想要给对方增加太多的并发, 比如我有1000个工作需要通过 5个协程来跑.... 刚刚用文档中的例子, 直接1000个协程就怼完了, 担心把server那边怼爆了",,,,2660914,shoaly,7496278,panjf2000,1,https://github.com/panjf2000/ants/issues/207,2022-01-13T11:07:59.000+08:00,2022-01-13T11:06:39.000+08:00,2022-01-13T11:07:59.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,108,
1103820475,134018330,208,closed,请问当ants在执行CPU密集型任务时，调度时能否不打断任务？,如果都是`CPU密集型任务`，让任务`无中断`地一直运行是最好的，而Go在1.14引入了`信号抢占机制`，每调用10ms就会打断一次计算，然后进行上下文重加载，再继续执行。在`ants`中，调度`CPU密集型`任务时，能否完全不打断任务？,,,,38336731,dragon-zhang,7496278,panjf2000,10868,https://github.com/panjf2000/ants/issues/208,2022-01-22T12:58:36.000+08:00,2022-01-14T23:50:07.000+08:00,2022-01-22T22:39:51.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,109,
1108986026,134018330,209,closed,请问能否获取每个goroutines的返回值,"请问能否获取每个goroutines的返回值，我想每次并发使用100个端口，哪个端口空闲了就使用哪个端口，如何才能保证不同时使用到相同的端口
",,,,31299839,dream0407,7496278,panjf2000,69062,https://github.com/panjf2000/ants/issues/209,2022-03-09T15:11:22.000+08:00,2022-01-20T16:08:49.000+08:00,2022-03-09T15:11:22.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,110,
1127816236,134018330,212,closed,`purgePeriodically` function is left running for a while after `pool.Release` is called,"**Describe the bug**
When the `Pool.Release()` function is called, it can leave the `purgePeriodically` function running until its heartbeat `time.Ticker` triggers, at which point the condition on whether the pool is closed is checked by the `purgePeriodically` for loop. 

The issue is that one cannot assume the goroutines associated with an ant pool are completely cleaned up until the `purgePeriodically` function is completed - and as such, tools like goleak (https://github.com/uber-go/goleak) will report a leaked goroutine in tests. 

**To Reproduce**
Steps to reproduce the behavior:
1. Clone https://github.com/loopholelabs/frisbee
2. Check out the `rpc-async` branch
3. Run `go test ./...`
4. See error

**Expected behavior**
The `purgePeriodically` goroutine is closed when the `Release` function returns.

**Error messages/Trace logs**
```bash
goleak: Errors on successful test run: found unexpected goroutines:
[Goroutine 4 in state chan receive, with github.com/panjf2000/ants/v2.(*Pool).purgePeriodically on top of the stack:
goroutine 4 [chan receive]:
github.com/panjf2000/ants/v2.(*Pool).purgePeriodically(0x14000140000)
        /Users/shivanshvij/go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.7/pool.go:69 +0x80
created by github.com/panjf2000/ants/v2.NewPool
        /Users/shivanshvij/go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.7/pool.go:137 +0x380
]
FAIL    github.com/loopholelabs/frisbee 10.624s
```

**System info (please complete the following information):**
 - OS: macOS
 - Go Version: 1.17.6
 - ants version: 2.4.7

**Additional context**
Add any other context about the problem here.
",,,,27162109,ShivanshVij,7496278,panjf2000,39493,https://github.com/panjf2000/ants/issues/212,2022-03-08T16:30:19.000+08:00,2022-02-09T06:16:27.000+08:00,2022-03-08T16:30:19.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,113,
1142268611,134018330,213,open,goWorkerWithFunc:recycleTime is not thread safe,"**Describe the bug**
goWorkerWithFunc:recycleTime is not thread safe, it may purge the non-idle goroutine accidently since purgePeriodically read the wrong recycleTime

**To Reproduce**
it is hard to reproduce in sample code
",,,,24819147,arrony135,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/213,,2022-02-18T11:18:10.000+08:00,2022-03-08T15:12:22.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,114,
1174810786,134018330,214,open,any difference between this and https://github.com/bytedance/gopkg/tree/develop/util/gopool,any difference between this and https://github.com/bytedance/gopkg/tree/develop/util/gopool?,,,,51492452,hiqsociety,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/214,,2022-03-21T10:35:20.000+08:00,2022-03-21T10:35:21.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,115,
1174907155,134018330,215,open,is the latest 1.18 go routine faster than this?,"is the latest 1.18 go routine faster than this?

just curious coz it seems faster etc now",,,,51492452,hiqsociety,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/215,,2022-03-21T13:25:35.000+08:00,2022-03-23T06:39:56.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,116,
1196996550,134018330,217,closed,ants 和 waitgroup一起使用时出现 negative waitGroup counter问题,"**大致的问题**
ants 包和waitgroup一起使用时,出现negative waitGroup导致panic，是个偶先的问题，目前尝试中没有复现问题

**调用栈信息**
```
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1()
        /opt/tiger/compile_path/pkg/mod/github.com/panjf2000/ants/v2@v2.4.8/worker.go:58 +0x10c
panic({0xfcd760, 0x12e6080})
        /usr/local/go/src/runtime/panic.go:1038 +0x215
sync.(*WaitGroup).Add(0x1, 0xc0047b52b8)
        /usr/local/go/src/sync/waitgroup.go:74 +0x105
sync.(*WaitGroup).Done(0xc04451f700)
        /usr/local/go/src/sync/waitgroup.go:99 +0x25
main.F.func1()
        /opt/tiger/compile_path/src/A/p.go:85 +0x278
github.com/panjf2000/ants/v2.(*goWorker).run.func1()
        /opt/tiger/compile_path/pkg/mod/github.com/panjf2000/ants/v2@v2.4.8/worker.go:70 +0x97
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /opt/tiger/compile_path/pkg/mod/github.com/panjf2000/ants/v2@v2.4.8/worker.go:48 +0x68
```

**问题代码**

```Go
package main

import (
	""fmt""
	""github.com/panjf2000/ants/v2""
	""sync""
)

func main() {
	res := make([]string, 20)
	for i := 0; i < 20; i++ {
		res[i] = ""a""
	}
	ids := make([]string, 0)
	tmp := make([]string, 0)
	var w sync.WaitGroup
	var mu sync.Mutex
	for i, r := range res {
		ids = append(ids, r)
		if len(ids) == 2 || i == len(res)-1 {
			tt := ids
			if err := ants.Submit(func() {
				defer w.Done()

				mu.Lock()
				defer mu.Unlock()
				tmp = append(tmp, tt...)
			});err != nil {
				fmt.Printf(""err occur %v\n"", err.Error())
			} else {
				w.Add(1)
				fmt.Printf(""add 1\n"")
			}
			ids = make([]string, 0)
		}
	}
	w.Wait()
	fmt.Println(""finish"")
}

```

**预期表现**
预期是任务提交成功后，就通过waitGroup的add加一,否则不执行，但任务出现多次done的情况，不清楚原因
",,,,38785315,huangketsudou,7496278,panjf2000,42148,https://github.com/panjf2000/ants/issues/217,2022-05-07T22:45:35.000+08:00,2022-04-08T16:17:13.000+08:00,2022-05-07T22:45:35.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,117,
1201065478,134018330,218,closed,What happens to Routine when it has finished? ,"Just wondering what happens to a routine that is invoked within an ants pool after it finishes ? 

Let say i set up an ants pool of size 10, and I've invoked 10 routines, so there should be 10 routines running within the pool.
If 1 routine has finished, is it now 9 routines running? Or are we still left with 10 routine but with 1 inactive ? 

I've setup my application to handle PubSub messages concurrently with each message handled by a function invoked in a worker pool (so 10 messages = 10 Message handler in ants pool). However I want to make sure that the ant pool frees up resources when 1 of the handler finishes. ",,,,77963837,FeurJak,7496278,panjf2000,46,https://github.com/panjf2000/ants/issues/218,2022-04-12T13:50:28.000+08:00,2022-04-12T13:03:29.000+08:00,2022-04-12T13:50:29.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,118,
1206125988,134018330,219,closed,公开压测代码,"可以公开压测的代码？
",,,,21958683,lockeliu,7496278,panjf2000,26691,https://github.com/panjf2000/ants/issues/219,2022-05-05T11:25:43.000+08:00,2022-04-16T22:33:56.000+08:00,2022-05-05T11:25:43.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,119,
1210377843,134018330,220,closed,Handling a worker / task that has failed,Is there an option to re-invoke worker if it has failed / crashed? Not too sure what WithPanicHandler() does. ,,,,77963837,FeurJak,7496278,panjf2000,23657,https://github.com/panjf2000/ants/issues/220,2022-05-07T19:29:32.000+08:00,2022-04-21T09:11:58.000+08:00,2022-05-07T19:29:32.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,120,
1215362122,134018330,222,closed,想知道是你们是怎么做压测的，光看速度的话，我试了一下，还不如原生的,"```
package main

import (
	""fmt""
	""github.com/panjf2000/ants/v2""
	""sync""
	""time""
)

var wg sync.WaitGroup

func main() {
	f := func() {
		wg.Done()
	}
	runTimes := 10000000
	defer ants.Release()
	start := time.Now()
	fmt.Println(start.Format(""2006-01-02 15:04:05""))
	wg.Add(runTimes)
	for i := 0; i < runTimes; i++ {
		//ants.Submit(f) // 4.5秒左右
		go f() //1.6秒左右
	}
	wg.Wait()
	fmt.Println(time.Now().Format(""2006-01-02 15:04:05""))
	e := time.Since(start)
	fmt.Println(e.String())
}
```",,,,30883503,yxiupei,7496278,panjf2000,12914,https://github.com/panjf2000/ants/issues/222,2022-05-05T11:25:13.000+08:00,2022-04-26T12:10:53.000+08:00,2022-05-05T11:25:13.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,121,
1239397157,134018330,223,closed,goroutine pool 对性能的影响的疑问,在go GMP模型中，数据结构G本身会被go scheduler复用，从内存和性能方面考虑，是不是和goroutine pool中对goroutine的复用效果是一样的呢,,,,39076288,hugh-404,0,,0,https://github.com/panjf2000/ants/issues/223,2022-05-18T12:00:54.000+08:00,2022-05-18T12:00:11.000+08:00,2022-05-18T12:00:54.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,122,
1243368453,134018330,225,open,purgePeriodically 导致阻塞,"最新版的 v2.5.0 release后 仍然 purgePeriodically 循环 导致程序阻塞 ，是我用的不对吗
Type: delay
Time: May 21, 2022 at 12:01am (CST)
Duration: 20.02s, Total samples = 40s (199.80%)
Entering interactive mode (type ""help"" for commands, ""o"" for options)
(pprof) traces
Type: delay
Time: May 21, 2022 at 12:01am (CST)
Duration: 20.02s, Total samples = 40s (199.80%)
-----------+-------------------------------------------------------
       20s   runtime.selectgo
             github.com/panjf2000/ants/v2.(*Pool).purgePeriodically
",,,,43371021,zqlpaopao,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/225,,2022-05-21T00:14:22.000+08:00,2022-05-27T19:11:23.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,123,
1244030382,134018330,226,closed,期望能有 TuneMaxBlockingTasks(size int) 动态调整功能,"**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

```go
package main

import (
	""github.com/panjf2000/ants/v2""
)

var (
	// 模拟配置文件
	// 允许同时处理 10 个任务, 最大再有 80 个任务排队, 若队满就 ErrPoolOverload
	capSize  = 10
	maxTasks = 80
)

func main() {
	p, _ := ants.NewPool(capSize, ants.WithMaxBlockingTasks(maxTasks))
	defer p.Release()
	// ...

	// 现在配置变化, 期望动态变更
	capSize = 20
	maxTasks = 150

	p.Tune(capSize)
	// TODO
	p.TuneMaxBlockingTasks(maxTasks)
}
```

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

```go
p.TuneMaxBlockingTasks(maxTasks)
```

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

目前似乎只能以新的 maxTasks 参数新建 pool 来替换. 但要料理旧 pool 未完成的任务.
若有现成方案请指点一下. 谢谢.

**Additional context**
Add any other context or screenshots about the feature request here.
",,,,4979407,fufuok,7496278,panjf2000,1086,https://github.com/panjf2000/ants/issues/226,2022-05-22T18:46:11.000+08:00,2022-05-22T00:39:29.000+08:00,2022-05-22T18:46:11.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,124,
1253913230,134018330,227,open,Performance differences between go1.13 and 1.14 and later versions,"In the same hardware environment, I found similar results to the author's conclusion for go1.13 in my tests, but for 1.14 onwards, ants no longer has a time consumption advantage, only a memory usage advantage. Is it because version 1.14 implements signal-based scheduling?
Attached are the test results, 3 million times, default pool size

1.13
go test -run=""TestNoPool"" -v
=== RUN   TestNoPool
--- PASS: TestNoPool (2.64s)
    ants_test.go:47: memory usage:1530 MB
PASS
ok      testGo/ant      2.759s

go test -run=""TestAntsPool"" -v
=== RUN   TestAntsPool
--- PASS: TestAntsPool (1.55s)
    ants_test.go:71: pool, capacity:2147483647
    ants_test.go:72: pool, running workers number:29722
    ants_test.go:73: pool, free workers number:2147453925
    ants_test.go:78: memory usage:73 MB
PASS
ok      testGo/ant      1.549s


1.14
go test -run=""TestNoPool"" -v
=== RUN   TestNoPool
    TestNoPool: ants_test.go:47: memory usage:289 MB
--- PASS: TestNoPool (0.78s)
PASS
ok      testGo/ant      0.783s

go test -run=""TestAntsPool"" -v
=== RUN   TestAntsPool
    TestAntsPool: ants_test.go:71: pool, capacity:2147483647
    TestAntsPool: ants_test.go:72: pool, running workers number:27475
    TestAntsPool: ants_test.go:73: pool, free workers number:2147456172
    TestAntsPool: ants_test.go:78: memory usage:71 MB
--- PASS: TestAntsPool (1.38s)
PASS
ok      testGo/ant      1.385s

",,,,29474400,LiaoPuJian,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/227,,2022-05-31T21:58:47.000+08:00,2022-05-31T21:58:48.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,125,
1257847610,134018330,228,closed,golang 1.17.x 版本测试通过了吗？,golang 1.17.x 版本能正常使用 ants 吗？是否已经经过测试了。,,,,47515663,ZhMaio,7496278,panjf2000,9689,https://github.com/panjf2000/ants/issues/228,2022-06-09T09:42:11.000+08:00,2022-06-02T16:13:04.000+08:00,2022-06-09T09:42:11.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,126,
1262980710,134018330,229,open,求问pool中running()方法返回的数字的含义,"我的代码中有一个生产者，两个消费者。他们分属三个池子。
生产者。读文件，解析对象，根据业务逻辑分别提交给消费者1和消费者2。协程池大小=16.
消费者1。cpu计算。协程池大小=64
消费者2。GPU计算。协程池大小=64

使用如下方法监听协程池正在运行数量:
`
go func() {
		for {
			time.Sleep(time.Duration(1000) * time.Millisecond)
			fmt.Println(
				""RealCallPool:"" + strconv.Itoa(RealCallPool.Running()) + ""-"" + strconv.Itoa(RealCallPool.Waiting()) +
					""\tRd2PileupOnGpuPool:"" + strconv.Itoa(Rd2PileupOnGpuPool.Running()) + ""-"" + strconv.Itoa(Rd2PileupOnGpuPool.Waiting()) +
					""\tRd2pileupOnGoPool:"" + strconv.Itoa(Rd2pileupOnGoPool.Running()) + ""-"" + strconv.Itoa(Rd2PileupOnGpuPool.Waiting()))
		}
	}()
`

输出的内容:
生产者协程池 ：running=16，waiting=1；稳定不变
消费者1/2，running = 30-64 动态稳定，waiting=0

我的疑问：
在上述运行状态中，cpu利用率只有30-40核。请问running()和waiting()方法返回的数字的含义。",,,,48267340,imDpeng,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/229,,2022-06-07T17:11:46.000+08:00,2022-06-08T19:46:06.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,127,
1264107782,134018330,230,open,How do I get the results of my tasks,"Hello:)
when i use “_ = p.Invoke(task)” , I want to do something while the task is being completed, how do it?

",,,,14806824,iGen1us,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/230,,2022-06-08T10:35:14.000+08:00,2022-06-08T19:43:42.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,128,
671575307,134018330,102,closed,求解：空闲worker回收后，为什么会重新放回sync.Pool中呢,"作者你好，在阅读源码的时候，遇到了一个问题：
一个goWorker在处理完chan中的task后，会把自身重新放回空闲的workArray中，但同时也放到了workerCache（sync.Pool）中，看了下fasthttp的实现，也做了同样的处理。在代码中我标出了这两处的位置。

```go
func (w *goWorker) run() {
	w.pool.incRunning()
	go func() {
		defer func() {
			w.pool.decRunning()
			w.pool.workerCache.Put(w) // 这里放到了cache中
			if p := recover(); p != nil {
				if ph := w.pool.options.PanicHandler; ph != nil {
					ph(p)
				} else {
					w.pool.options.Logger.Printf(""worker exits from a panic: %v\n"", p)
					var buf [4096]byte
					n := runtime.Stack(buf[:], false)
					w.pool.options.Logger.Printf(""worker exits from panic: %s\n"", string(buf[:n]))
				}
			}
		}()

		for f := range w.task {
			if f == nil {
				return
			}
			f()
			if ok := w.pool.revertWorker(w); !ok {  // 这里把空闲worker放回了workArray中
				return
			}
		}
	}()
}
```

由于goWorker是引用，所以同一个goWorker会同时存在于workerArray和sync.Pool中，会不会出现一种情况，从sync.Pool中Get的worker其实在还在有效期中，最终导致goroutine pool中运行的worker数量是”假“的，因为有两个worker是同一个

这种情况可能需要测试，并行测试较难复现我说的场景，如果您对于这块有比较好的解答，感谢~

",,,,10286120,xieao,7496278,panjf2000,1380,https://github.com/panjf2000/ants/issues/102,2020-08-03T15:22:04.000+08:00,2020-08-02T16:21:16.000+08:00,2020-08-03T15:22:04.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,129,
675830456,134018330,104,closed,"我有个疑问,http本身就是基于goroutine实现吗？ 集成http server 有什么好处，大神们回答下呗","我有个疑问,http本身就是基于goroutine实现吗？ 集成http server 有什么好处，大神们回答下呗",,,,24741439,Xuzan9396,7496278,panjf2000,350,https://github.com/panjf2000/ants/issues/104,2020-08-10T16:37:13.000+08:00,2020-08-10T10:46:29.000+08:00,2020-08-10T16:37:13.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,131,
675845276,134018330,105,closed,"疑问？我用NewPoolWithFunc 创建了10个协程去处理，每个goroutine耗时需要1分钟左右,看下我的代码是不是可以这么处理","#### 疑问？我用NewPoolWithFunc 创建了10个协程去处理，每个goroutine耗时需要1分钟左右，有一种情况，就是我的goroutine 里面可能有超时任务，不释放，我这边想处理2分钟还没结束，就结束掉这个gotoutine， 我这边代码是不是可以这么优化
```
	options := ants.Options{}
	options.ExpiryDuration = 2 * time.Minute  // 两分钟没处理完结束，释放
	p, _ := ants.NewPoolWithFunc(10, func(i interface{}) {
		// 一分钟任务
		return 
	},ants.WithOptions(options))
	p.Release()
```",,,,24741439,Xuzan9396,7496278,panjf2000,285,https://github.com/panjf2000/ants/issues/105,2020-08-10T16:33:18.000+08:00,2020-08-10T11:47:40.000+08:00,2020-08-11T09:19:29.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,132,
683789291,134018330,106,closed,怎么样实现先把任务提交再限制池的并发,,,,,61406754,dukv2001,7496278,panjf2000,3814,https://github.com/panjf2000/ants/issues/106,2020-08-24T19:15:41.000+08:00,2020-08-22T03:40:47.000+08:00,2020-08-24T19:15:41.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,133,
692140116,134018330,109,closed,较新版本golang是否还需要ants以及类似的pool实现来替代go？,"```sh
# go version go1.13.1

BenchmarkGoroutines-8  3   352026800 ns/op	   14885 B/op	      39 allocs/op
BenchmarkAntsPool-8    2   581543800 ns/op	16137376 B/op	 1001286 allocs/op
```

1. 如果上游业务本身并发度较高，直接同步执行task就可以，不需要协程pool
2. 不管上游业务本身并发度是高还是低，如果想要异步task，由于较新版本的go性能和gc都表现的很不错、比pool各方面还算好些，pool与go的主要区别就是协程数量控制，go+rate limit即可，不太需要pool
",,,,3296206,cokeboL,7496278,panjf2000,6553,https://github.com/panjf2000/ants/issues/109,2020-09-08T14:26:02.000+08:00,2020-09-04T01:12:14.000+08:00,2020-09-08T14:26:02.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,135,
700343813,134018330,110,closed,WithMaxBlockingTasks doesn't seem to work as the docs indicate,"**Describe the bug**
`WithMaxBlockingTasks` doesn't seem to do what I think it should be doing based on the docs.

**To Reproduce**

I expect this to actually error:
```
p, _ := ants.NewPool(1, ants.WithMaxBlockingTasks(1))
var wg sync.WaitGroup
for i := 0; i < 5; i++ {
  err := p.Submit(func() {
   wg.Add(1)
   time.Sleep(time.Second)
   wg.Done()
  })
  if err != nil {
     // I expect this to have an error if i >= 2
  }
}
wg.Wait()
p.Release()
```

**Expected behavior**
I expect err to return `ants.ErrPoolOverload` when i >= 2.

**Error messages/Trace logs**
No error, it processes everything 1 at a time.

**System info (please complete the following information):**
 - OS: macOS
 - Go Version: 1.15.1
 - ants version: v2.4.2

",,,,2372558,polds,7496278,panjf2000,1378,https://github.com/panjf2000/ants/issues/110,2020-09-14T02:10:09.000+08:00,2020-09-13T03:11:24.000+08:00,2020-09-14T15:27:28.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,136,
719788673,134018330,112,closed,想问下本项目在解锁时不用defer语句的原因,我阅读了本项目的代码，发现有许多需要解锁的地方没有在defer中进行unlock，而是采取了比较麻烦的——在所有的函数退出点手动unlock。想问下，我们是出于defer的性能问题而放弃了这一写法吗？如果是，在go1.13之后的版本中，defer语句有了比较明显的性能优化，如果是基于1.13之后的版本来开发这一工具，我们的开发者会倾向于选择defer语句中unlock还是手动unlock？,,,,25627418,FingalVon,7496278,panjf2000,2404,https://github.com/panjf2000/ants/issues/112,2020-10-15T01:56:28.000+08:00,2020-10-13T09:51:40.000+08:00,2020-10-15T01:56:28.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,138,
719993557,134018330,113,closed,[BUG] Memory leak,"The following is my code causing a memory leak in `ants@v2.4.2`
```
package main

import (
	""fmt""
	""net/http""
	_ ""net/http/pprof""
	""sync""
	""time""

	""github.com/panjf2000/ants/v2""
)

func main() {
	/**
	pprof
	http://127.0.0.1:6060/debug/pprof/
	*/
	go func() {
		_ = http.ListenAndServe(""localhost:6060"", nil)
	}()

	for k := 0; k < 4; k++ {
		for i := 0; i < 400; i++ {
			go DoTask()
			time.Sleep(time.Millisecond * 10)
		}
		time.Sleep(time.Second * 2)
	}
	fmt.Println(""Done"")

}

func DoTask() {
	pool, _ := ants.NewPool(2, ants.WithExpiryDuration(time.Second*2))

	wg := sync.WaitGroup{}

	{
		wg.Add(1)
		err := pool.Submit(func() {
			defer wg.Done()
			time.Sleep(time.Millisecond * 10)
		})
		if err != nil {
			fmt.Println(err)
		}
	}

	{
		wg.Add(1)
		err := pool.Submit(func() {
			defer wg.Done()
			time.Sleep(time.Millisecond * 10)
		})
		if err != nil {
			fmt.Println(err)
		}
	}

	wg.Wait()
	pool.Release()
}

```

### Timeline
```
------------------------------------------------------------------------------------------
CPU0 revertWorker            -> state closed -> Lock -> reset -> Unlock
------------------------------------------------------------------------------------------
CPU1 Release     -> state ok ->                                         -> Lock -> insert
------------------------------------------------------------------------------------------
```

### Consider the following:
1. `Pool.revertWorker` starts to execute (`Pool.state` is not `CLOSED`), but `Pool.revertWorker` -> `Pool.lock.Lock` has not yet been called.
2. `Pool.Release` starts to execute (`Pool.state` is `CLOSED`) and `Pool.Release` -> `Pool.lock.Lock` has been called.
3. `Pool.purgePeriodically` would break out of a loop next time.
4. `Pool.Release` -> `p.workers.reset` (clean up all workers in `workerStack.items`).
5. `Pool.revertWorker` -> `p.workers.insert`(add a worker to `workerStack.items`), but this worker would never receive any task, also leading to `goWorker.run` leaks.

However, there may be a race condition between 1 and 2.


### Note:
I tried to solve that, it seemed to work.
```
 // revertWorker puts a worker back into free pool, recycling the goroutines.
 func (p *Pool) revertWorker(worker *goWorker) bool {
-       if capacity := p.Cap(); (capacity > 0 && p.Running() > capacity) || atomic.LoadInt32(&p.state) == CLOSED {
+       if capacity := p.Cap(); capacity > 0 && p.Running() > capacity {
                return false
        }
        worker.recycleTime = time.Now()
        p.lock.Lock()

+       if atomic.LoadInt32(&p.state) == CLOSED {
+               p.lock.Unlock()
+               return false
+       }
```

# In Chinese
我们发现`Pool.revertWorker`跟`Pool.Release`存在竞态问题，会导致`goroutine`泄露。

### Timeline
```
------------------------------------------------------------------------------------------
CPU0 revertWorker            -> state closed -> Lock -> reset -> Unlock
------------------------------------------------------------------------------------------
CPU1 Release     -> state ok ->                                         -> Lock -> insert
------------------------------------------------------------------------------------------
```

如果`Release`先运行（当前池子状态未关闭往下走等锁），然后`revertWorker`也开始运行了。只要后者比前者先拿到锁`Pool.lock`，就会导致这个worker泄露。
`Release`只会给当时存在池子中的`worker`发`nil`，而这个`worker`肯定没有在池子中；然后`purgePeriodically`也会因为池子关闭而退出循环，后面`worker`过期就没人管了。除此之外好像也没有其他方法可以让泄露的`worker`退出了。

### Note:
小弟斗胆给大佬您提交一个issue，说的不对的地方还请多多指正，蟹蟹！
想跟您更加深入的讨论一下这个库，方便加下您的微信吗？小弟邮箱cainiao666999@gmail.com，可以的话我来加您😃。",,,,29589055,Mutated1994,7496278,panjf2000,2595,https://github.com/panjf2000/ants/issues/113,2020-10-15T11:35:56.000+08:00,2020-10-13T16:20:56.000+08:00,2020-10-15T11:35:56.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,139,
722994544,134018330,115,closed,[QUESTION] Excuse me,"Bro, when will you consider adding a new tag？",,,,29589055,Mutated1994,7496278,panjf2000,22,https://github.com/panjf2000/ants/issues/115,2020-10-16T16:14:51.000+08:00,2020-10-16T15:52:14.000+08:00,2020-10-16T16:14:51.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,141,
724008505,134018330,116,closed,想请教一下，把互斥锁改成自旋锁的目的是什么呢,"**What is your question about ants?**
Please describe your question meticulously.
如题，大概猜测是因为锁保护的代码时间非常短，使用自旋锁能够比互斥锁性能更优？",,,,7411249,imxyb,7496278,panjf2000,71,https://github.com/panjf2000/ants/issues/116,2020-10-18T22:46:48.000+08:00,2020-10-18T21:35:14.000+08:00,2020-10-19T00:03:27.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,142,
728597070,134018330,118,open,Does this means we can perform soft-realtime goroutine using this feature like erlang?,"possible to use ants as a soft-realtime go func() like erlang?

sorry i hv yet to explore this code in detail but i'm exploring options to make goroutines handle more connections like erlang.",,,,51514008,gitmko0,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/118,,2020-10-24T07:26:54.000+08:00,2020-10-24T07:26:54.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,144,
729205618,134018330,119,closed,worker exits from a panic: reflect: call of reflect.Value.Len on ptr Value,**worker exits from a panic: reflect: call of reflect.Value.Len on ptr Value**,,,,48704159,gdlxSong,7496278,panjf2000,10713,https://github.com/panjf2000/ants/issues/119,2020-11-02T22:02:26.000+08:00,2020-10-26T11:28:28.000+08:00,2020-11-02T22:02:26.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,145,
730161470,134018330,120,closed,提交了大量BlockingTasks，当pool.注销时，回收内存比较慢,我想知道，怎么自定义回收内存的时间,,,,7267234,jiangjiali,7496278,panjf2000,1599,https://github.com/panjf2000/ants/issues/120,2020-10-28T17:20:39.000+08:00,2020-10-27T14:41:08.000+08:00,2020-10-30T17:41:28.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,146,
731239827,134018330,121,closed,有考虑支持动态伸缩池子大小吗？,,,,,6133860,jianzhiyao,7496278,panjf2000,24,https://github.com/panjf2000/ants/issues/121,2020-10-28T17:18:39.000+08:00,2020-10-28T16:54:25.000+08:00,2020-10-28T17:18:39.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,147,
736200176,134018330,122,closed,Some questions about pool.Tune(),"i use the ants as the pool to control goroutines, and pool.Tune() can  tune pool capacity in runtime, so it is necessary to realize automatic expansion and contraction of pool? Looking forward to your answer, thank you ！
使用了ants作为pool管控goroutine， pool中也提供了一个Tune()方法可以在运行期间调整大小，那么还有必要去实现pool的自动扩缩容吗？期待你的解答，谢谢！",,,,42341553,PPeacHH,7496278,panjf2000,7884,https://github.com/panjf2000/ants/issues/122,2020-11-10T10:45:34.000+08:00,2020-11-04T23:20:51.000+08:00,2020-11-10T10:45:34.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,148,
737043014,134018330,123,closed,the ants goroutine pool performance ,"**Why the perf result on my local when using ants goroutines pool doesn't like the benchmark pictures?**
I have cloned the latest code on the master branch and tried to run this command _go test -bench=. -run=none -benchmem=true_ but I got the result quite different from your benchmark pictures, the time of each test loop when using ants pool takes longer.

Here is the result on my machine:
![image](https://user-images.githubusercontent.com/23579202/98261210-cb490000-1fb6-11eb-95fb-ef28d2227234.png)

In the bench tests, I see you're using the ant pool with size 200000 to handle 1000000 tasks, so the result on my machine is what I expected because the size of the ants pool smaller than the number of tasks, so it will save the hardware resources for us but can not be faster than spawning 1000000 goroutines for that job. 

please correct me. 

Here is the detail of my environment when running the test:
_go version go1.15 darwin/amd64_
`
    Hardware Overview:

      Processor Name: 6-Core Intel Core i7
      Processor Speed: 2.6 GHz`
OS: macOS catalina",,,,23579202,jedrp,7496278,panjf2000,12162,https://github.com/panjf2000/ants/issues/123,2020-11-14T10:23:44.000+08:00,2020-11-05T23:41:29.000+08:00,2020-11-22T15:19:49.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,149,
737434903,134018330,124,closed,可以使用全局变量 保存 NewPool么？,,,,,14883130,foreverZSJ,7496278,panjf2000,9164,https://github.com/panjf2000/ants/issues/124,2020-11-12T20:34:23.000+08:00,2020-11-06T11:49:31.000+08:00,2020-11-12T20:34:41.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,150,
738170151,134018330,125,open,About the memory consumption of pool,"How much memory per goroutine pool size? Can you please put this on main page?
p, _ := ants.NewPool(50000) <- basically goroutine use 2kb / 4kb per go routine

From benchmark, it's 50k pool
https://github.com/panjf2000/ants/#-performance-summary
total 10M ants instance is 38mb which means each item size is 760bytes with 50000 items.

is 760bytes the limit for each pool item?

last question:
pool.Tune(100000) <- May I ask what's the ""optimum size"" for this? what's a good suggestion / advise on setting size? also on what occasion will u suggest tuning this size? please put the number of bytes each pool is on front page as mentioned so we can calculate and adjust better with your input.",,,,51514008,gitmko0,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/125,,2020-11-07T12:40:04.000+08:00,2020-11-07T12:48:39.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,151,
738173237,134018330,126,open,About the performace when using ants in websocket ,"Will websocket be written with ants be more performant than using solutions such as gobwas or fastws

With reference to go routines being used in websocket here
https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/
and also here:
https://github.com/dgrr/fastws/

I havent tried yet but do you think ants with websocket will be faster and more performant than them for high number of connections? e.g. 1M to 10M connections using ants for websocket.",,,,51514008,gitmko0,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/126,,2020-11-07T13:02:02.000+08:00,2021-01-11T09:50:12.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,152,
738174165,134018330,127,open,I just realised your server spec must be very very good,"For 10M tasks using only 1.3gb, can you put your server spec into front page for your benchmark?
It seems to be very very good.",,,,51514008,gitmko0,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/127,,2020-11-07T13:08:00.000+08:00,2020-11-07T13:08:00.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,153,
741209727,134018330,128,closed,整个项目的核心， 我的理解对不对！,"
![image](https://user-images.githubusercontent.com/24741439/98886138-674e9c00-24ce-11eb-9303-48ae82158104.png)

截图所示
## 第一部分是复用 goruntine worker池子， 防止频繁创建，gc 不必要的损耗
## 第二部分是在复用池子的基础上，控制池子的大小
不知道我理解的对不对， 最新对这块性能方面优化挺感兴趣的",,,,24741439,Xuzan9396,7496278,panjf2000,2889,https://github.com/panjf2000/ants/issues/128,2020-11-14T10:17:22.000+08:00,2020-11-12T10:08:14.000+08:00,2020-11-18T16:15:24.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,154,
755047477,134018330,129,closed,"如果任务卡主了,怎么关闭这个任务","有没有什么办法主动关闭协程
",,,,30611869,lwydyby,7496278,panjf2000,4041,https://github.com/panjf2000/ants/issues/129,2020-12-05T11:33:10.000+08:00,2020-12-02T16:11:16.000+08:00,2020-12-05T11:33:17.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,155,
772339531,134018330,130,closed,关于返回值,我想知道，我怎样才能获取每个协程的返回值，需要我单独构建一个管道么？另外，我应当如何控制超时？,,,,17517153,Alberthchang,7496278,panjf2000,799,https://github.com/panjf2000/ants/issues/130,2020-12-22T14:43:23.000+08:00,2020-12-22T01:23:50.000+08:00,2020-12-22T14:43:23.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,156,
802177721,134018330,132,closed,need more examples,"Is there any repo using ants as an example? 
ants is an amazing package , though i feel it needs more documentation and examples",,,,70520127,savixazz,7496278,panjf2000,154068,https://github.com/panjf2000/ants/issues/132,2021-05-23T21:34:56.000+08:00,2021-02-05T21:46:12.000+08:00,2021-05-23T21:34:57.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,158,
807765048,134018330,133,closed,Any difference between using without modules and v2?,I'm using without modules and it works fine. Wondering if there are any benefits to use the v2 version with modules,,,,51492452,hiqsociety,7496278,panjf2000,57727,https://github.com/panjf2000/ants/issues/133,2021-03-26T01:11:15.000+08:00,2021-02-13T23:03:51.000+08:00,2021-03-26T01:11:15.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,159,
818082145,134018330,134,closed,用vendor怎么下载v2版本？？？,老项目用的vendor，暂时用不了gomod，但是现在库里一个包依赖的是v2版本，怎么下载v2的到vendor里呢？,,,,25148685,hhyvs111,7496278,panjf2000,4541,https://github.com/panjf2000/ants/issues/134,2021-03-03T14:20:51.000+08:00,2021-02-28T10:39:49.000+08:00,2021-03-03T14:20:51.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,160,
818372401,134018330,135,closed,"If ants' goroutine crash, will the whole software crash?","If ants' goroutine crash, will the whole software crash?

If so, how can we make it so that the software will still runs even if crash like erlang processes?",,,,51492452,hiqsociety,7496278,panjf2000,933,https://github.com/panjf2000/ants/issues/135,2021-03-02T00:44:24.000+08:00,2021-03-01T09:10:30.000+08:00,2021-03-02T00:44:24.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,161,
821650908,134018330,137,closed,"Since we can pool.Tune(), how can we return the current capacity to check if it's worth tuning up or down?","Since we can pool.Tune(), how can we return the current capacity to check if it's worth tuning up or down?

possible to do a Capacity()? Does it hv this function already?",,,,51492452,hiqsociety,7496278,panjf2000,1,https://github.com/panjf2000/ants/issues/137,2021-03-04T09:04:21.000+08:00,2021-03-04T09:03:06.000+08:00,2021-03-04T09:04:21.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,163,
823817947,134018330,138,closed,请教下怎么判断每个worker的任务是否执行完毕呢？,"作者你好，在`README`中，预先知道了需要执行的task个数，利用`sync.WaitGroup`去等待所有的task执行完毕

想请教下，在预先不知道task个数的情况下，怎么去知道所有的Task都执行完了呢？，伪代码如下:

```golang

type Args struct {
    ID       int
    Name string
}

func Task(args interface{}){
    param := args.(Args)
    fmt.Printf(""param: %#v\n"", param)
}

func main() {
    defer ants.Release()
    
    p, _ = ants.NewPoolWithFunc(10, Task)
    
    defer p.Release()

    for _, model := range queryResult {    
        args := Args {
             Name: model.Name,
             ID:       model.ID,
        }
        p.Invoke(args)
    }
    //等待所有的Task执行完毕后再结束 ？
}
```
",,,,18528873,mayouzi,7496278,panjf2000,4479,https://github.com/panjf2000/ants/issues/138,2021-03-10T14:05:31.000+08:00,2021-03-07T11:26:03.000+08:00,2021-03-10T14:05:31.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,164,
824927472,134018330,140,closed,Sitting idle using ants eats up to 5% cpu progressively from time to time,"Sitting idle using ants eats up to 5% cpu just sitting idle from time to time.

possible to disable this eating cpu? if idle should not be eating cpu time.",,,,51492452,hiqsociety,7496278,panjf2000,28376,https://github.com/panjf2000/ants/issues/140,2021-03-28T21:29:40.000+08:00,2021-03-09T04:32:45.000+08:00,2021-03-28T21:29:40.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,166,
830099075,134018330,141,closed,retrieveWorker may wait forever,"1. retrieveWorker will wait when there is no any available work.
2. Then, call Pool.Release(), the state of pool will be changed to CLOSED.
3. All works which are running finish their work, then revertWorker return false, since the state is CLOSED.
4. The tick in purgePeriodically() function will arrive, then break from the for loop, since the state is CLOSED.

So, nobody will send the signals to the guys which are waiting in retrieveWorker function.",,,,17548688,math345,7496278,panjf2000,8697,https://github.com/panjf2000/ants/issues/141,2021-03-18T22:01:18.000+08:00,2021-03-12T21:04:12.000+08:00,2021-03-18T22:01:18.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,167,
830908542,134018330,142,closed,Why not “p.Running()<capacity”？,"https://github.com/panjf2000/ants/blob/fd8d670fd09489e6ea7693c0a382ba85d2694f16/pool.go#L238

When the worker being executed is less than the capacity, it is already possible not to block, so why wait for all the execution to be completed before you can spawnWorker().
Why not “p.Running()<capacity”？
I am a newbie and would like to get answers，thanks.

当正在执行的worker小于容量的时候，就已经可以不用阻塞了，为什么要等待全部执行完了才可以进行spawnWorker()",,,,48661001,sirodeneko,0,,5676,https://github.com/panjf2000/ants/issues/142,2021-03-17T20:54:56.000+08:00,2021-03-13T22:17:59.000+08:00,2021-03-18T09:30:05.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,168,
834309657,134018330,143,open,关于 [Issue 142][Why not “p.Running()<capacity”] 的问题,"
由于 [Issue 142 Why not “p.Running()<capacity”](https://github.com/panjf2000/ants/issues/142) 已经 Closed ，所以我新提交了一个 Issue 。

这个问题，我想过。我觉得目前的做法不是很优雅。我之前对这段代码进行了一些推敲，我把我的理解整理如下。

为什么要加下面这段代码呢？而且 p.lock.Unlock() 后再调用 spawnWorker()，running 个数失去了保护，这个次数就有可能超过了设定的最大值 capacity。

```
		if p.Running() == 0 {
			p.lock.Unlock()
			spawnWorker()
			return
		}
```

好吧，我们先忽略上面这个小问题。再来看下面这段代码，为什么不能在 w == nil 时，直接 spawnWorker() 个新的 worker?  因为有可能是收到广播信号，此时不能保证 p.Running() <= capacity 。

```
		w = p.workers.detach()
		if w == nil {
			goto Reentry
		}
```

但是，我觉得可以通过修改成下面的代码解决掉这个问题

```
		w = p.workers.detach()
		if w == nil {
			if p.Running() < capacity {
				spawnWorker()
				p.lock.Unlock()
				return
			}
			goto Reentry
		}
```

由于作者没有采用类似这样的写法，导致需要增加 `if p.Running() == 0` 这段代码处理广播信号。

再来看广播信号，广播信号是在定时回收时，满足下面的条件触发的。

```
		// There might be a situation that all workers have been cleaned up(no any worker is running)
		// while some invokers still get stuck in ""p.cond.Wait()"",
		// then it ought to wakes all those invokers.
		if p.Running() == 0 {
			p.cond.Broadcast()
		}
```

为什么需要这段代码？原因在于需要考虑这么一种情况，当 retrieveWorker() 发现 runing() 个数超过了容量，因此在 p.cond.Wait() 中。之后 runing() 的所有 worker f() 都发生了 panic，按当前的代码逻辑，是无法正常归还到工作池中的，revertWorker 不会被调用，也就是 revertWorker 不会发出 Signal 通知。因此，如果我们检测到没有1个worker running，就 Broadcast 信号。

```
for f := range w.task {
	
	if f == nil {
		return
	}
	
	// 需要考虑 f() panic 的情况，此时不会归还到工作池中
	f()
	
	if ok := w.pool.revertWorker(w); !ok {
		return
	}
}
```

因此广播信号的加入，确实增加了复杂度。能不能在work run() 中包装调用 f() ，处理 panic ?",,,,17548688,math345,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/143,,2021-03-18T09:36:19.000+08:00,2021-08-30T12:06:42.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,169,
837779470,134018330,144,closed,"Out-of-date README, misleading terminology and stale description on high performance ","Thanks for your great job on the project. 

I have some questions:
1. out-of-date image and code
 The image [10M tasks](https://github.com/panjf2000/ants#10m-tasks) is a misused or stale image. The bench function it called is not the same as [1M tasks](https://github.com/panjf2000/ants#1m-tasks) and [100k tasks](https://github.com/panjf2000/ants#100k-tasks). It is partly the same as the pic [benchmarks-with-poolwithfunc](https://github.com/panjf2000/ants#benchmarks-with-poolwithfunc) above.
 And I didn't see the bench function it called ,naming ""BenchmarkGoroutineWithFunc"",""BenchmarkAntsPoolWithFunc"", exists in the source code. Maybe it has already been removed from the src, or changed to ""^TestAntsPoolWithFunc...""

2. About throughput and latency
 In [here](https://github.com/panjf2000/ants#throughput-it-is-suitable-for-scenarios-where-tasks-are-submitted-asynchronously-without-waiting-for-the-final-results), you describe the result as a kind of throughput,but maybe it should be more like a one-way latency (you just commit the job,and never wait it to be done)
 Throughput should be calculated like  [here](https://github.com/panjf2000/ants/blob/master/ants_benchmark_test.go#L64) , using wg.Wait() to get the total elapsed time t, and divide it to the number of goroutines committed, e.g."" t / #goroutine ""
 That's a clear question when facing pipeline.
 The Image [performance-summary](https://github.com/panjf2000/ants#-performance-summary) uses ""Goroutine throughput benchmark"" as its title, but using memory and latency as its y-label, which is confusing. Maybe ""throughput"" should be removed

3. About the performance,I tried to run the bench for more than 3 times, and got the following results.
The results seem to be very different from the bench in your [README](https://github.com/panjf2000/ants#benchmarks-with-pool)

About my machine&env:
```
Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz

go version go1.16.2 windows/amd64
```

3.1 Using Test
The only quoted variable `n` has been set to ` n        = 10000000 `, e.g. 10M
It seems that TestAntsPool runs slower than TestNoPool, though the memory saved is obviously huge.

```sh
PS D:\go-work\src\github.com\panjf2000\ants> go test -run=NoPool -v
=== RUN   TestNoPool
    ants_test.go:210: memory usage:789 MB
--- PASS: TestNoPool (5.04s)
PASS
ok      github.com/panjf2000/ants/v2    5.154s

PS D:\go-work\src\github.com\panjf2000\ants> go test -run=""AntsPool$"" -v
=== RUN   TestAntsPool
    ants_test.go:225: pool, capacity:2147483647
    ants_test.go:226: pool, running workers number:19360
    ants_test.go:227: pool, free workers number:2147464287
    ants_test.go:232: memory usage:184 MB
--- PASS: TestAntsPool (7.41s)
PASS
ok      github.com/panjf2000/ants/v2    7.528s
```

3.2 Using Benchmark
I first set the param to 1M tasks and 50k pool capacity,just like what you set in [README](https://github.com/panjf2000/ants#-benchmarks)
Here the performance is significantly higher than ""without pool""
```sh
Running tool: D:\GO\bin\go.exe test -benchmem -run=^$ -bench ^(BenchmarkGoroutines)$ github.com/panjf2000/ants/v2

goos: windows
goarch: amd64
pkg: github.com/panjf2000/ants/v2
cpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz
BenchmarkGoroutines-8   	       1	10773745800 ns/op	509732352 B/op	 1996637 allocs/op
PASS
ok  	github.com/panjf2000/ants/v2	11.616s

Running tool: D:\GO\bin\go.exe test -benchmem -run=^$ -bench ^(BenchmarkAntsPool)$ github.com/panjf2000/ants/v2

goos: windows
goarch: amd64
pkg: github.com/panjf2000/ants/v2
cpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz
BenchmarkAntsPool-8   	       2	 712292750 ns/op	21032456 B/op	 1063341 allocs/op
PASS
ok  	github.com/panjf2000/ants/v2	2.363s
```
It is weird for me to see the different result, given the src code is nearly the same.

4. Is it OK to use a [only sleep function](https://github.com/panjf2000/ants/blob/master/ants_benchmark_test.go#L39) acting as worker?
Maybe changing the demoFunc to a CPU-bound func like the following, or a related compromise.
```go
// func demoFunc() {
// 	time.Sleep(time.Duration(BenchParam) * time.Millisecond)
// }
func demoFunc() {
	begin := time.Now()
	i := 0
	for {
		i++
		end := time.Now()
		if end.UnixNano()-begin.UnixNano() > int64(time.Millisecond)*BenchParam {
			return
		}
	}
}
```

5. However, in this [issue](https://github.com/panjf2000/ants/issues/123), you admit that the performance isn't higher than the plain goroutine anymore. Please UPDATE THE README!

If I have any error,correct me plz. That's my pleasure to see such an awesome project in saving memory alloction, avoiding unlimited goroutine constructions.


",,,,49816514,wymli,7496278,panjf2000,142139,https://github.com/panjf2000/ants/issues/144,2021-06-29T15:33:58.000+08:00,2021-03-22T22:34:21.000+08:00,2021-06-29T15:33:58.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,170,
838523489,134018330,145,closed,协程性能,"目前我用ants作为协程池处理并发请求, 发现协程的延迟有80~100us,  和我直接用go func的延迟差别不大. 
由于我的请求本身延迟大概500-600us, 协程的延迟比较影响性能
请问有什么可以改善的吗
",,,,75625523,cham-pin,7496278,panjf2000,87682,https://github.com/panjf2000/ants/issues/145,2021-05-23T14:50:35.000+08:00,2021-03-23T17:28:13.000+08:00,2021-05-23T14:50:35.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,171,
840918413,134018330,146,closed,所有 workers 发生 panic 导致那些正在等待可用 worker 的调用方阻塞住,"**Describe the bug**
极端情况下，协程的执行速度为`ExpiryDuration`的时长

**To Reproduce**
Steps to reproduce the behavior:
1. 创建一个`size`为1，`ExpiryDuration`为10s的协程池
2. 创建一个每次必panic的函数`panicFunc`
3. 向协程池添加5次`panicFunc`任务，并且后续不会再添加新的任务
4. 结果每`10s`(也就是设定的`ExpiryDuration`的时长)才会打印一次panic堆栈

代码如下：
```go
package main

import (
	""fmt""
	""sync""
	""time""

	""github.com/panjf2000/ants/v2""
)

func main() {
	runTimes := 5
	var wg sync.WaitGroup
	pool, _ := ants.NewPool(1, ants.WithExpiryDuration(10 * time.Second))
	panicFunc := func() {
		time.Sleep(10 * time.Millisecond)
		wg.Done()
		panic(""test panic"")
	}
	for i := 0; i < runTimes; i++ {
		wg.Add(1)
		_ = pool.Submit(panicFunc)
	}
	wg.Wait()
	fmt.Printf(""running goroutines: %d\n"", pool.Running())
}

```
**Expected behavior**
5次`panic`应该堆栈很快就打印完

**Error messages/Trace logs**
```cmd
2021/03/25 21:10:15 worker exits from a panic: test panic
2021/03/25 21:10:15 worker exits from panic: goroutine 8 [running]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1(0xc000072180)
        /Users/admin/dev/ginlearn/ants/worker.go:58 +0x161
panic(0x10b2d60, 0x10f3fa0)
        /usr/local/opt/go@1.13/libexec/src/runtime/panic.go:679 +0x1b2
main.main.func1()
        /Users/admin/dev/ginlearn/ants/examples/test_panic/main.go:18 +0x67
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc000072180)
        /Users/admin/dev/ginlearn/ants/worker.go:68 +0xa5
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /Users/admin/dev/ginlearn/ants/worker.go:48 +0x4c

2021/03/25 21:10:25 worker exits from a panic: test panic
2021/03/25 21:10:25 worker exits from panic: goroutine 18 [running]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1(0xc0000c8000)
        /Users/admin/dev/ginlearn/ants/worker.go:58 +0x161
panic(0x10b2d60, 0x10f3fa0)
        /usr/local/opt/go@1.13/libexec/src/runtime/panic.go:679 +0x1b2
main.main.func1()
        /Users/admin/dev/ginlearn/ants/examples/test_panic/main.go:18 +0x67
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc0000c8000)
        /Users/admin/dev/ginlearn/ants/worker.go:68 +0xa5
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /Users/admin/dev/ginlearn/ants/worker.go:48 +0x4c

2021/03/25 21:10:35 worker exits from a panic: test panic
2021/03/25 21:10:35 worker exits from panic: goroutine 33 [running]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1(0xc0000e6000)
        /Users/admin/dev/ginlearn/ants/worker.go:58 +0x161
panic(0x10b2d60, 0x10f3fa0)
        /usr/local/opt/go@1.13/libexec/src/runtime/panic.go:679 +0x1b2
main.main.func1()
        /Users/admin/dev/ginlearn/ants/examples/test_panic/main.go:18 +0x67
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc0000e6000)
        /Users/admin/dev/ginlearn/ants/worker.go:68 +0xa5
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /Users/admin/dev/ginlearn/ants/worker.go:48 +0x4c

2021/03/25 21:10:45 worker exits from a panic: test panic
2021/03/25 21:10:45 worker exits from panic: goroutine 49 [running]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1(0xc000072180)
        /Users/admin/dev/ginlearn/ants/worker.go:58 +0x161
panic(0x10b2d60, 0x10f3fa0)
        /usr/local/opt/go@1.13/libexec/src/runtime/panic.go:679 +0x1b2
main.main.func1()
        /Users/admin/dev/ginlearn/ants/examples/test_panic/main.go:18 +0x67
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc000072180)
        /Users/admin/dev/ginlearn/ants/worker.go:68 +0xa5
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /Users/admin/dev/ginlearn/ants/worker.go:48 +0x4c

2021/03/25 21:10:55 worker exits from a panic: test panic
2021/03/25 21:10:55 worker exits from panic: goroutine 51 [running]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1(0xc0000e6000)
        /Users/admin/dev/ginlearn/ants/worker.go:58 +0x161
panic(0x10b2d60, 0x10f3fa0)
        /usr/local/opt/go@1.13/libexec/src/runtime/panic.go:679 +0x1b2
main.main.func1()
        /Users/admin/dev/ginlearn/ants/examples/test_panic/main.go:18 +0x67
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc0000e6000)
        /Users/admin/dev/ginlearn/ants/worker.go:68 +0xa5
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /Users/admin/dev/ginlearn/ants/worker.go:48 +0x4c

running goroutines: 0

```
**System info (please complete the following information):**
 - OS:  macOS 11.2.3
 - Go Version: go1.13.15 darwin/amd64
 - ants version: v2.4.3

**Additional context**
感觉这种情况很极端，生产环境中几乎不会存在，不知有没有修复的必要。",,,,38038921,shangxiaomi,7496278,panjf2000,4400,https://github.com/panjf2000/ants/issues/146,2021-03-28T22:38:11.000+08:00,2021-03-25T21:17:49.000+08:00,2021-03-28T22:39:24.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,172,
841138037,134018330,147,closed,Crash with bbolt db.Batch after running for some time,"long running program crash here

        putDB := func() {
                db.Batch(func(tx *bbolt.Tx) error {
                 

                
                })
        }


ants.Submit(putDB) <-- pseudocode




goroutine 1225 [chan receive]:
bbolt.(*DB).Batch(0xc0001a6800, 0xc000096200, 0xc0005d6a80, 0xc0007b37a8)





        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.3/worker.go:68 +0x94
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.3/worker.go:48 +0x4c

goroutine 1295 [chan receive]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc0006230e0)
        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.3/worker.go:64 +0x75
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.3/worker.go:48 +0x4c

goroutine 1296 [chan receive]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1(0xc000623110)
        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.3/worker.go:64 +0x75
created by github.com/panjf2000/ants/v2.(*goWorker).run
        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.3/worker.go:48 +0x4c

rax    0x0
rbx    0x7f578b4f9700
rcx    0x7f57c60ef18b
rdx    0x0
rdi    0x2
rsi    0x7f578b4f8a10
rbp    0x7f57c6264588
rsp    0x7f578b4f8a10
r8     0x0
r9     0x7f578b4f8a10
r10    0x8
r11    0x246
r12    0x7f57c62b35fa
r13    0x1a7
r14    0x7f57c62b3530
r15    0x2978710
rip    0x7f57c60ef18b
rflags 0x246
cs     0x33
fs     0x0
gs     0x0",,,,51492452,hiqsociety,7496278,panjf2000,4169,https://github.com/panjf2000/ants/issues/147,2021-03-28T22:40:00.000+08:00,2021-03-26T01:10:12.000+08:00,2021-03-28T22:40:00.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,173,
844010065,134018330,148,closed,A proper way of using `sync.Cond`,"Hello, there! I'd like to say this package shows great work!

According to the doc comments in [go pkg](https://golang.org/pkg/sync/#Cond), I doubt whether this is a proper way of using conditional variable, since I see no `p.cond.L.Lock()` before calling `p.cond.Wait()`. I haven't make any test, but won't be a problem there?

https://github.com/panjf2000/ants/blob/dbcb6a104f23b1a6a7521796b30515230353283e/pool.go#L244",,,,37577088,fangxlmr,0,,3,https://github.com/panjf2000/ants/issues/148,2021-03-30T10:51:39.000+08:00,2021-03-30T10:48:12.000+08:00,2021-03-30T10:56:23.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,174,
851256703,134018330,150,closed,Why delete tag v1.3.0?,"**What is your question about ants?**
Please describe your question meticulously.

Why delete tag v1.3.0?",,,,4394982,deliangyang,7496278,panjf2000,2895,https://github.com/panjf2000/ants/issues/150,2021-04-08T18:08:10.000+08:00,2021-04-06T17:52:27.000+08:00,2021-04-08T18:08:10.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,176,
857977427,134018330,151,closed,how do u pass value like goroutine?,"e.g.

for i:=0; i<10000; i++ {
go func(abc uint64) {

}(i)
}

how do u do the same with ants?",,,,51492452,hiqsociety,7496278,panjf2000,6,https://github.com/panjf2000/ants/issues/151,2021-04-14T22:57:13.000+08:00,2021-04-14T22:51:13.000+08:00,2021-04-14T22:57:13.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,177,
863400810,134018330,152,closed,Doubt about Pool.Free() / 关于 Pool.Free() 的一些疑惑,"I need to know whether the goroutine pool is ""full""(blocked in `Pool.Submit()`), and I found this function `Pool.Free()`, but I'm really confused about its behavior. 
```
// Free returns the available goroutines to work.
func (p *Pool) Free() int {
	return p.Cap() - p.Running()
}
```
as you commented, it returns the avaliable goroutines, but when you created a pool with a size of -1, you will get a negative  number. So only when `Pool.Free()` returns exactly zero, can I know that the pool is ""full"", right?


我想通过知道 goroutine 池是否已经满了（提交任务 `Pool.Submit()` 时阻塞），我找到了这个函数 `Pool.Free()`，但我对其行为有一些疑问。
```
// Free returns the available goroutines to work.
func (p *Pool) Free() int {
	return p.Cap() - p.Running()
}
```
正如你所评论的，它返回可用的goroutine，但是当你创建一个大小为 -1 的池时，你将得到一个负数。所以只有当 `Pool.Free()` 正好返回 0 时，我才能知道池已满，对吗？
",,,,34428640,ycydsxy,7496278,panjf2000,8482,https://github.com/panjf2000/ants/issues/152,2021-04-27T08:17:09.000+08:00,2021-04-21T10:55:09.000+08:00,2021-04-27T08:17:09.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,178,
864353725,134018330,153,closed,Nested ants function gives error for long running fast for loops?,"Getting error of 

2021/04/21 22:28:03 worker exits from a panic: runtime error: invalid memory address or nil pointer dereference
2021/04/21 22:28:03 worker exits from panic: goroutine 23634 [running]:
github.com/panjf2000/ants/v2.(*goWorker).run.func1.1(0xc004b7ae70)
        /go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.4/worker.go:58 +0x17c
panic(0x68dc60, 0x9d0eb0)
        /usr/lib/go-1.16/src/runtime/panic.go:965 +0x1b9


if nested multi layer. is this a problem?",,,,51492452,hiqsociety,7496278,panjf2000,45140,https://github.com/panjf2000/ants/issues/153,2021-05-23T14:50:27.000+08:00,2021-04-22T06:29:50.000+08:00,2021-05-23T14:50:27.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,179,
869939645,134018330,154,closed,retrieveWorker时候p.Running()边界问题,"```go
spawnWorker := func() {
		w = p.workerCache.Get().(*goWorker)
		w.run()
	}

	p.lock.Lock()

	w = p.workers.detach()
	if w != nil {
		p.lock.Unlock()
	} else if capacity := p.Cap(); capacity == -1 || capacity > p.Running() {
		p.lock.Unlock()
		spawnWorker()
```
p.Running取出后判断小于capacity，解锁，再增加一个worker，是否存在边界问题？
在incrRunning()前，有其他协程也取到了同样的p.Running()，是否存在最后协程数超过capacity?
",,,,78064625,LinghuChongHaha,7496278,panjf2000,17244,https://github.com/panjf2000/ants/issues/154,2021-05-10T20:42:43.000+08:00,2021-04-28T21:18:29.000+08:00,2021-05-10T20:42:43.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,180,
890078421,134018330,155,closed,考虑将loopQueue的实现替换为栈,我在使用ant的过程发现一个这样的case，当qps出现陡增时，会新增很多worker到队列中，而当流量降下来后，这些worker因为还在循环工作，且过期时间设置偏大，导致worker的goroutine一直达不到过期条件，不能被回收，此后goroutine数量一直处于高位，利用率下降。这固然有过期时间设置不合理的原因，但在设计上也存在一定缺陷，如果使用栈，worker的detach和insert都在栈顶，则能显著提高单个goroutine的利用率，栈底用不到的worker也能更及时的被回收，retrieveExpiry函数从栈底开始遍历，同样满足栈底首个元素不过期，则整个栈的元素不过期。,,,,25758101,spadan,0,,9928,https://github.com/panjf2000/ants/issues/155,2021-05-19T18:42:32.000+08:00,2021-05-12T21:13:58.000+08:00,2021-05-19T18:42:32.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,181,
892678963,134018330,156,closed,retrieveExpiry中expiryTime问题,"为什么是expiryTime := time.Now().Add(-duration)，而不是expiryTime := time.Now().Add(duration)？
按照现在的实现，revertWorker设置worker.recycleTime = time.Now()，那么expiryTime肯定大于worker.recycleTime，导致worker用了一次必定被回收。引入expiryTime不就是为了多重复利用几次吗？ 有点不明白，望解答",,,,30179199,chenbyby,7496278,panjf2000,4113,https://github.com/panjf2000/ants/issues/156,2021-05-19T18:42:01.000+08:00,2021-05-16T22:08:19.000+08:00,2021-05-19T18:42:01.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,182,
898973379,134018330,157,closed,期望暴露个 blockingNum 的统计数量,"目前有：
`p.Running()`
`p.Free()`
`p.Cap()`

在并不想放开并发数的场景下，高峰时，
`p.Free()` 可能较长时间为 `0`，
此时很希望知道排队任务长度，即 `blockingNum` 数量或剩余排队数量 `options.MaxBlockingTasks` - `blockingNum`。",,,,4979407,fufuok,7496278,panjf2000,502897,https://github.com/panjf2000/ants/issues/157,2022-05-07T22:45:12.000+08:00,2021-05-23T17:07:25.000+08:00,2022-05-07T22:45:12.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,183,
907118378,134018330,159,closed,关于panjf2000 / ants v2.0.0版本修复的问题,"你好，我在v2.0.0看到如下描述
![image](https://user-images.githubusercontent.com/53163548/120149656-9df6c480-c21c-11eb-8631-9128417da5a3.png)
但是对比v1.2.0和v2.0.0的代码，我没看懂是如何解决这个问题的，或者这个问题是什么情况下会出现？
可否给我讲解一下？
",,,,53163548,guoxinyu-shopee,7496278,panjf2000,5,https://github.com/panjf2000/ants/issues/159,2021-05-31T14:35:13.000+08:00,2021-05-31T14:29:42.000+08:00,2021-05-31T14:44:53.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,185,
907293042,134018330,163,open,偶发情况下revertWorker内time.Now()占用CPU较高,hi，你好，pprof性能分析时， 偶尔会出现revertWorker内time.Now()占用CPU较高的情况，想请教一下，如果把获取当前时间换成另一种性能更好但可能有误差（误差5ms）的方法，会对整体有较大影响吗？我自己的理解，默认1s过期的情况下，可能会导致有些worker的回收时间延迟1s，但是不太清楚这个对ants整体的影响,,,,22535169,chiselX,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/163,,2021-05-31T17:29:31.000+08:00,2021-05-31T23:06:00.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,186,
907817424,134018330,164,closed,使用sync.Map，有时会发生fatal error: concurrent map writes的问题,你好，我这边需要用goroutine对单个map进行操作，为了不产生concurrent map writes的问题，使用sync.Map，不通过您的框架，单纯使用goroutine貌似是OK的，但是使用了这个框架，有时候会报fatal error: concurrent map writes这个问题,,,,7382698,usst830514,7496278,panjf2000,10,https://github.com/panjf2000/ants/issues/164,2021-06-01T10:52:29.000+08:00,2021-06-01T10:42:10.000+08:00,2021-06-01T10:52:29.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,187,
913065024,134018330,165,closed,TestNonblockingSubmitWithFunc 随机成功或失败,"**Describe the bug**
当运行TestNonblockingSubmitWithFunc时，偶尔成功，偶尔失败：
![image](https://user-images.githubusercontent.com/30179199/120957174-c3894e00-c787-11eb-9f08-e08af4afa86b.png)
当多次运行该测试函数，出现如下结果：
![image](https://user-images.githubusercontent.com/30179199/120957214-dc91ff00-c787-11eb-84cf-5e4f15d91e5d.png)

**Error messages/Trace logs**
=== RUN   TestNonblockingSubmitWithFunc
    TestNonblockingSubmitWithFunc: ants_test.go:417: 
        	Error Trace:	ants_test.go:417
        	Error:      	An error is expected but got nil.
        	Test:       	TestNonblockingSubmitWithFunc
        	Messages:   	nonblocking submit when pool is full should get an ErrPoolOverload
--- FAIL: TestNonblockingSubmitWithFunc (0.00s)
FAIL

**System info (please complete the following information):**
 - OS: macOS,2.3 GHz 八核Intel Core i9,16 GB 2667 MHz DDR4
 - Go Version: 1.14.4
 - ants version: latest

当p.Invoke(nil)改为p.Invoke(Param)，不会出现该问题",,,,30179199,chenbyby,7496278,panjf2000,74128,https://github.com/panjf2000/ants/issues/165,2021-07-28T23:32:18.000+08:00,2021-06-07T12:03:24.000+08:00,2021-07-28T23:32:18.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,188,
918864340,134018330,166,closed,最新的基准测试跑过了么，比不过原生的,"**What is your question about ants?**

BenchmarkAntsPool-12是BenchmarkGoroutines-12的两倍多，是我的机器不对么？还是后面代码写着写着就跑偏了？

```sh
goos: darwin
goarch: amd64
pkg: github.com/panjf2000/ants/v2
cpu: Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
BenchmarkGoroutines-12              	       3	 411810402 ns/op	80012933 B/op	 1000135 allocs/op
BenchmarkSemaphore-12               	       2	 637331376 ns/op	80197720 B/op	 1002060 allocs/op
BenchmarkAntsPool-12                	       1	1023957685 ns/op	20676048 B/op	 1063831 allocs/op
BenchmarkGoroutinesThroughput-12    	       3	 403223552 ns/op	82825797 B/op	 1008366 allocs/op
BenchmarkSemaphoreThroughput-12     	       2	 627645680 ns/op	80062776 B/op	 1000637 allocs/op
BenchmarkAntsPoolThroughput-12      	       2	 936248712 ns/op	 1887088 B/op	   29047 allocs/op
PASS
ok  	github.com/panjf2000/ants/v2	80.746s
```
",,,,1940588,bingoohuang,7496278,panjf2000,62,https://github.com/panjf2000/ants/issues/166,2021-06-12T00:05:34.000+08:00,2021-06-11T23:03:09.000+08:00,2021-06-18T17:59:51.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,189,
930705346,134018330,168,open,Announcement: please replace ants v1.2.0 with v1.2.1,"## Dear users of `ants`

This is a notice about an issue of `ants` in GO modules, the v1.2.0 has been re-tagged with a new commit, which causes the **checksum mismatch** with Go modules and you may encounter this problem sometime, see #49 for details.

To cut a long story short, the quick fix for this issue is to replace the version of v1.2.0 with v1.2.1 in your `go.mod`, then you'll be free from the tiresome **checksum mismatch** problem.

I'm sorry for the inconvenience caused to you.",,,,7496278,panjf2000,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/168,,2021-06-26T22:21:38.000+08:00,2021-06-26T22:21:38.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,191,
931106727,134018330,169,closed,Cancel all task when has any task return error,"**How to cancel all tasks when has any task return error?**
I have two pools: pool1 and pool2. The result of tasks on pool1 to send tasks for pool2. When having any task error, how to cancel all tasks running in pool1 and pool2?
",,,,38505126,ducpx,7496278,panjf2000,11887,https://github.com/panjf2000/ants/issues/169,2021-07-06T16:41:36.000+08:00,2021-06-28T10:33:47.000+08:00,2021-07-06T16:41:36.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,192,
932236472,134018330,170,closed,purgePeriodically  for cycle do nothing？,"**What is your question about ants?**
https://github.com/panjf2000/ants/blob/master/pool_func.go#L81
why do nothing？
Do you need to add this line of code ？
expiredWorkers = append(expiredWorkers, idleWorkers[i])
",,,,49196656,leeliliang,7496278,panjf2000,8,https://github.com/panjf2000/ants/issues/170,2021-06-29T13:56:24.000+08:00,2021-06-29T13:47:51.000+08:00,2021-06-29T13:56:25.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,193,
938708991,134018330,171,closed,关于ants使用场景的疑问,针对大规模长连接（利用心跳机制，几乎不断），使用ants是否能带来性能提升呢？,,,,33331974,DMwangnima,7496278,panjf2000,940,https://github.com/panjf2000/ants/issues/171,2021-07-08T09:34:38.000+08:00,2021-07-07T17:54:18.000+08:00,2021-07-08T09:34:38.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,194,
946771746,134018330,173,closed,对于 retrieveWorker 方法中阻塞队列的疑惑,"您好，我比较疑惑 pool.go 里 retrieveWorker 方法中的这段代码，这里由于加了锁 p.lock.Lock()，而且只有在 p.cond.Wait() 之后才会解锁，所以应该永远只有一个goroutine在 Wait() 中阻塞等待，而其他goroutine都被挡在了 p.lock.Lock() 外面等待解锁。那么这样的话，我感觉任务提交的阻塞队列就失去了意义，对 p.blockingNum 的计数也没有意义了。不知道我的想法是否正确。
`
	p.lock.Lock()

	w = p.workers.detach()
	if w != nil { // first try to fetch the worker from the queue
		p.lock.Unlock()
	} else if capacity := p.Cap(); capacity == -1 || capacity > p.Running() {
		// if the worker queue is empty and we don't run out of the pool capacity,
		// then just spawn a new worker goroutine.
		p.lock.Unlock()
		spawnWorker()
	} else { // otherwise, we'll have to keep them blocked and wait for at least one worker to be put back into pool.
		if p.options.Nonblocking {
			p.lock.Unlock()
			return
		}
	retry:
		if p.options.MaxBlockingTasks != 0 && p.blockingNum >= p.options.MaxBlockingTasks {
			p.lock.Unlock()
			return
		}
		p.blockingNum++
		p.cond.Wait() // block and wait for an available worker
		p.blockingNum--
		var nw int
		if nw = p.Running(); nw == 0 { // awakened by the scavenger
			p.lock.Unlock()
			if !p.IsClosed() {
				spawnWorker()
			}
			return
		}
		if w = p.workers.detach(); w == nil {
			if nw < capacity {
				p.lock.Unlock()
				spawnWorker()
				return
			}
			goto retry
		}

		p.lock.Unlock()
`",,,,34757591,isAlbertYu,7496278,panjf2000,123,https://github.com/panjf2000/ants/issues/173,2021-07-17T18:55:18.000+08:00,2021-07-17T16:52:14.000+08:00,2021-07-30T10:30:06.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,196,
951582378,134018330,175,open,doing so to call invoke does a lot of memory allocations.,"doing so to call invoke does a lot of memory allocations.

possible to replace {}Interface with [][]byte or something similar?
coz the allocation generated by using panjf is rather unbearable in high use case.

                var val [][]byte
                val = append(val,[]byte{0})
                val = append(val,[]byte{uint8(k)})
                val = append(val,[]byte{uint8(v)})
                val = append(val,[]byte{uint8(c)})
                val = append(val,kX) 
                val = append(val,b)
                pdbrpool.Invoke(&val)
",,,,87639173,superdolt,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/175,,2021-07-23T21:29:37.000+08:00,2021-07-24T19:15:17.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,198,
953856676,134018330,177,closed,"func with lots of mutex lock and unlock, when heavily called, will eat up linux threads","func with lots of mutex lock and unlock, when heavily called, will eat up linux threads and crash.

though i increased the debug.set max threads with runtime/debug, can this be resolved? 

threads doesnt seem to be released / free up too.",,,,51492452,hiqsociety,7496278,panjf2000,20,https://github.com/panjf2000/ants/issues/177,2021-07-27T21:19:36.000+08:00,2021-07-27T20:58:53.000+08:00,2021-07-27T21:20:15.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,200,
953963592,134018330,178,closed,"try heavily overload panjf with lots of locks and unlock, then u can see lock slow, semaphore issues and crash","try heavily overload panjf with lots of locks and unlock, then u can see lock slow, semaphore issues and crash

goroutine 6 [chan receive]:
github.com/panjf2000/ants/v2.(*Pool).purgePeriodically(0xc000112460)
        /root/go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.6/pool.go:69 +0x109
created by github.com/panjf2000/ants/v2.NewPool
        /root/go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.6/pool.go:137 +0x232

goroutine 7 [chan receive]:
github.com/panjf2000/ants/v2.(*Pool).purgePeriodically(0xc0001124d0)
        /root/go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.6/pool.go:69 +0x109
created by github.com/panjf2000/ants/v2.NewPool
        /root/go/pkg/mod/github.com/panjf2000/ants/v2@v2.4.6/pool.go:137 +0x232

goroutine 21 [runnable]:
sync.runtime_SemacquireMutex(0x15f56f4, 0x0, 0x1)
        /usr/local/go/src/runtime/sema.go:71 +0x47
sync.(*Mutex).lockSlow(0x15f56f0)
        /usr/local/go/src/sync/mutex.go:138 +0x105
sync.(*Mutex).Lock(...)
        /usr/local/go/src/sync/mutex.go:81
",,,,51492452,hiqsociety,7496278,panjf2000,340551,https://github.com/panjf2000/ants/issues/178,2022-03-21T10:39:49.000+08:00,2021-07-27T22:48:30.000+08:00,2022-03-21T10:39:49.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,201,
959089879,134018330,179,closed,是否可以限制单一goroutine的执行时间,"请问关于ants，是否有接口可以限制单一goroutine执行时间的，比如我一次性下发20000个任务，但是我池子开了100个，那如果所有的都阻塞了，是否可以设置单一goroutine在阻塞20s以后自动结束当前任务，接收新的任务？
",,,,17517153,Alberthchang,7496278,panjf2000,6655,https://github.com/panjf2000/ants/issues/179,2021-08-08T11:53:20.000+08:00,2021-08-03T20:57:43.000+08:00,2021-08-08T11:53:20.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,202,
971116711,134018330,180,closed,在协程里频繁创建协程池有异常，貌似有协程泄露的问题,"![image](https://user-images.githubusercontent.com/19659483/129477453-879a175b-fe83-4ef1-966a-1d5e58a9be2b.png)
这边的do方法， 外层可以理解是个for循环， 会一直执行， 每次执行到setCardTime的时候， 都会执行如下
![image](https://user-images.githubusercontent.com/19659483/129477515-663f0e4e-a9be-4c6e-9167-80a79c0240a7.png)
经过反复测试， 就是这个函数， 如果把它注释掉， 协程数量和内存都正常，不会飙升， 一打开就异常 

w.dataCenter.CarList是个list数组， 本次测试大概是1k数量
go版本1.15
ants版本1.3

我把图片中的协程池方法单独拿出来
![image](https://user-images.githubusercontent.com/19659483/129477621-800ddab2-b292-441a-9360-4d7aef6aa0cc.png)
然后调用的时候
![image](https://user-images.githubusercontent.com/19659483/129477630-0c4232d1-c4c8-415d-bd46-fcfa514c87b9.png)
就一切正常，协程和内存都很稳定， 不知道这是否是个bug， 但是我这边肯定是有这个问题，这是线上问题， 定位一天了才定位到这个
![image](https://user-images.githubusercontent.com/19659483/129477738-b167ff68-2d94-48b1-a9b3-59aa4b76d632.png)
这是我们线上的内存监控， 毛刺都是有问题的版本， pprof监控也是， 最低协程数都在缓慢增长

![image](https://user-images.githubusercontent.com/19659483/129477761-9e47d668-346d-4868-b0de-af607aa386e8.png)

然后上面这个图， 是我改动之后的内存正常情况",,,,19659483,ohmygd,7496278,panjf2000,149601,https://github.com/panjf2000/ants/issues/180,2021-11-27T17:17:03.000+08:00,2021-08-15T19:55:35.000+08:00,2021-11-27T17:17:03.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,203,
971511276,134018330,181,closed,不太明白maxBlockingTasks的作用,"retrieveWorker 函数里面有下面这段代码：
if p.maxBlockingTasks != 0 && p.blockingNum >= p.maxBlockingTasks { 
	p.lock.Unlock()
	return nil
}
p.blockingNum++
p.cond.Wait()
p.blockingNum--

这里面我的理解是p.blockingNum应该不会超过2吧，因为retrieveWorker 里面有p.lock.Lock()加锁，同一时刻p.blockingNum不会有并发操作，当p.cond.Wait()这里被唤醒后，又执行了p.blockingNum-- 操作，一加一减，最后p.blockingNum又回归为0，所以不太明白maxBlockingTasks的实现是不是有达到作者本意，也不知道是不是我的分析有误，还望潘帅有空帮忙解答一番，谢谢！
",,,,10394162,jackerlu,7496278,panjf2000,57,https://github.com/panjf2000/ants/issues/181,2021-08-16T17:49:22.000+08:00,2021-08-16T16:51:30.000+08:00,2021-08-16T17:50:14.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,204,
984782442,134018330,182,closed,限制每秒钟最大执行数量,"**Is your feature request related to a problem? Please describe.**
I want use this lib to request a list of URL (restapi). But it limit request speed. If I didn't comply, It will throw a error.
我想要请求一个URL列表（他们都是restapi），但是接口是有限速的，超过限速接口就会返回错误。

**Describe the solution you'd like**
So I want a speedLimit option to limit go routine run  number every second.
Maybe use channel and time.ticker to support it.
所以我希望有一个每秒最大task运行数或者最小运行时间的参数，应该可以通过使用channel或time.ticker来实现。

**Describe alternatives you've considered**
If this lib cannot support it, Maybe I'll add a time.ticker channel reciever at the head of worker function.
如果库无法提供这个参数或者不应该提供此参数的话，那么我应该会在worker函数的开头增加上time.ticker chennel的接收器来完成限制
",,,,3294100,likyh,7496278,panjf2000,4514,https://github.com/panjf2000/ants/issues/182,2021-09-04T18:21:31.000+08:00,2021-09-01T15:06:47.000+08:00,2021-09-04T18:21:31.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,205,
987520012,134018330,183,closed,提供非阻塞的 Submit() 方法,"**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
期望pool有个提交任务的方法，该提交任务方法是非阻塞的，而且任务永久不会被丢弃，当超过了capacity后，pool内部维护一个队列或者数组存储该任务。

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
",,,,7950702,liracle,7496278,panjf2000,92,https://github.com/panjf2000/ants/issues/183,2021-09-03T17:37:41.000+08:00,2021-09-03T16:05:01.000+08:00,2021-09-03T23:18:52.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,206,
1022229785,134018330,187,closed,.,。,,,,23187595,zt102545,7496278,panjf2000,13,https://github.com/panjf2000/ants/issues/187,2021-10-11T12:14:26.000+08:00,2021-10-11T12:01:01.000+08:00,2021-10-11T12:21:40.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,210,
1024790716,134018330,188,closed,"Shopify,Inc is using this project on production, maybe we ad a logo on user case.",,,,,3814966,lilien1010,7496278,panjf2000,514,https://github.com/panjf2000/ants/issues/188,2021-10-13T21:42:42.000+08:00,2021-10-13T13:07:52.000+08:00,2021-10-13T21:42:42.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,211,
1025263959,134018330,190,open,Pause API is needed in some scenario,"in our case, we need a `pool.Pause()` to  pause all jobs, and  use `pool.Resume()` to restart the jobs.",,,,3814966,lilien1010,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/190,,2021-10-13T21:37:28.000+08:00,2022-03-23T06:43:23.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,213,
1028877423,134018330,191,closed,自旋锁的性能对比测试,"![1634552555(1)](https://user-images.githubusercontent.com/22676124/137714133-c424b7b5-de1a-41af-bc1d-ee633edba695.png)



测试案例代码 
https://github.com/liu-song/ants/blob/master/internal/spinlock_test.go
 ",,,,22676124,liu-song,7496278,panjf2000,57847,https://github.com/panjf2000/ants/issues/191,2021-11-27T21:45:03.000+08:00,2021-10-18T17:37:35.000+08:00,2021-11-27T21:45:03.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,214,
1047896477,134018330,194,open,How do I call database insert operation using ants,"I have a for loop, which inserts data into the 2 different tables. How can I use ants in this case.

```go

for _, row := range rows {
 user := User{}
 user.Name = row.Name
 user.Email = row.Email
 err := dm.Insert(&user)
 if err != nil {
  panic(err)
 }
 address := Address{}
 address.Address1 = row.Address1
 address.Address2 = row.Address2
 address.PinCode = row.PinCode
 address.City = row.City
 err := dm.Insert(&address)
 if err != nil {
  panic(err)
 }
}
```
",,,,16970687,kiranupadhyak,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/194,,2021-11-09T04:38:11.000+08:00,2022-03-10T15:27:10.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,217,
1054484973,134018330,195,closed,pool should be Independence,"every goWork have Pool reference，it is very hard to understand.
maybe have a struct map will better 
thx ",,,,45867365,venusDo,7496278,panjf2000,1858,https://github.com/panjf2000/ants/issues/195,2021-11-17T21:07:32.000+08:00,2021-11-16T14:08:34.000+08:00,2021-11-17T21:07:32.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,218,
1058613251,134018330,196,closed,频繁通过pool.Tune方法来实现动态增加/减少协程的数量,"大概的代码逻辑，在一个定时器内进行了通道任务的数量的统计，通过这个通道的任务数量在一定的时间，来通过pool.Tune方法调整协程池的数量， 但是经过一段时间后，通过poll.*里面提供的方法去统计当前有，多少协程和空闲协程，会出现一定的负数，

pool.Tune(100)//通道任务有200个，开启100个协程处理

pool.Tune(500)//通道任务大于1000个，调整协程数量为500

pool.Tune(10)// 通道任务小于100，就把任务调整为10协程
以此类推来实现 协程的动态调整，
假如直接从500下调到10 会有什么不可以预估的问题吗？
（后续贴代码）",,,,19727273,longrbl,7496278,panjf2000,11186,https://github.com/panjf2000/ants/issues/196,2021-11-27T17:17:15.000+08:00,2021-11-19T22:50:48.000+08:00,2021-11-27T17:17:15.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,219,
1060770678,134018330,197,closed,在传给Submit的task函数中调用Submit可能导致block,"**Describe the bug**

在传给Submit的task函数中调用Submit可能导致block

下面是一段示例代码：

```
package main

import (
	""fmt""
	""time""

	""github.com/panjf2000/ants/v2""
)

func main() {

	p, _ := ants.NewPool(100)

	for {
		p.Submit(func() {
			for i := 0; i < 3; i++ {
				p.Submit(func() {
					fmt.Println(time.Now().Unix())
				})
			}
		})
	}
}
```

在ubuntu 20.04 amd64平台，使用go 1.17版本运行上述程序，会导致程序锁住。

**To Reproduce**

在linux上运行上述程序。

**Expected behavior**

没有锁住，一直执行下去。

**Error messages/Trace logs**



**System info (please complete the following information):**
 - OS: linux
 - Go Version: 1.17
 - ants version: 2.4.6

**Additional context**

我不确认在Submit提交的task函数中再次调用Submit是否是ok的？找了ants文档，没看到写不允许在Submit中调用Submit。

另外初步分析了一下，Submit的task会被分配给pool中的worker。如果某个worker1执行task1，而task1又调用Submit task2，但task2恰好又被分给worker1，这样就锁住了。基于这个分析，我们可以很容易复现：

```
package main

import (
	""fmt""
	""time""

	""github.com/panjf2000/ants/v2""
)

func main() {
	p, _ := ants.NewPool(1)

	err := p.Submit(func() {
		fmt.Println(""func in first submit..."")
		err := p.Submit(func() {
			fmt.Println(""submit in submit ..."")
			fmt.Println(time.Now().Unix())
			fmt.Println(""submit in submit ok"")
		})

		if err != nil {
			fmt.Println(""func in first submit err:"", err)
			return
		}
		fmt.Println(""func in first submit ok"")
	})

	if err != nil {
		fmt.Println(""first submit error:"", err)
	}

	time.Sleep(5 * time.Second)
}
```

我们仅在pool中放置一个worker。这样就会导致block。

",,,,419088,bigwhite,7496278,panjf2000,821,https://github.com/panjf2000/ants/issues/197,2021-11-23T23:57:13.000+08:00,2021-11-23T10:15:39.000+08:00,2021-11-29T16:12:19.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,220,
1074045507,134018330,199,open,worker with func exits from a panic: sync: negative WaitGroup counter,"**What is your question about ants?**
Please describe your question meticulously.
![image](https://user-images.githubusercontent.com/27792650/145157017-30598557-3105-4558-905e-d7fd11e73fb8.png)

### **ERROR**

![image](https://user-images.githubusercontent.com/27792650/145156779-48c197a9-4dc8-4ea2-84db-35c03efe1990.png)




CentOS6.9 x64      go version go1.17.3 linux/amd64

",,,,27792650,WyntersN,7496278,panjf2000,0,https://github.com/panjf2000/ants/issues/199,,2021-12-08T14:05:37.000+08:00,2021-12-19T16:13:55.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,222,
1074084207,134018330,200,closed,请问使用默认 AntsPool 需要手动释放资源吗？,"hi，我刚上手这个组件，这是一个新手的问题。

在我使用 ants.Submit(func() {}) 进行工作时，未手动初始化一个 pool，ants 会创建一个默认池。

在我不需要重置资源的情况下，我是否不用去考虑调用 pool.Release() 释放资源呢？或者说在什么情况下我需要释放 pool ？或许是在项目重新部署时？
",,,,62499904,guowei-gong,7496278,panjf2000,216466,https://github.com/panjf2000/ants/issues/200,2022-05-07T22:57:13.000+08:00,2021-12-08T15:10:39.000+08:00,2022-05-07T22:57:13.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,223,
1076267066,134018330,201,closed,你好，请问可以开个循环处理队列一直不关闭吗？会不会占用很高内存或者cpu,"**What is your question about ants?**

可以开个循环处理队列一直不关闭吗？会不会占用很高内存或者cpu

Please describe your question meticulously.

伪代码：

```
p, _ := ants.NewPoolWithFunc(pos, taskFunc, ants.WithNonblocking(true))
defer p.Release()
for {
...
value, ok := q.Get()
p.Invoke(value)
...
}
```
谢谢",,,,43238749,shikingram,7496278,panjf2000,2096,https://github.com/panjf2000/ants/issues/201,2021-12-11T20:09:21.000+08:00,2021-12-10T09:12:49.000+08:00,2021-12-11T20:09:21.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,224,
1078047238,134018330,202,closed,关闭Pool时出现异常行为,"情景：两个goroutine在模拟生产者向Pool发送任务，任务需要执行一定时间，一段时间后需要关闭服务端，期望相关goroutine能正常退出
问题：其中一个goroutine无法退出
测试代码：
```go
func TestStop(t *testing.T) {
	var wg sync.WaitGroup
	p, _ := NewPoolWithFunc(1, func(i interface{}) {
		fmt.Println(""do task"", i)
		time.Sleep(2 * time.Second)
	})
	wg.Add(2)
	go func() {
		fmt.Println(""start aaa"")
		defer func() {
			wg.Done()
			fmt.Println(""stop aaa"")
		}()
		for i := 0; i < 30; i++ {
			p.Invoke(i)
		}
	}()

	go func() {
		fmt.Println(""start bbb"")
		defer func() {
			wg.Done()
			fmt.Println(""stop bbb"")
		}()
		for i := 100; i < 130; i++ {
			p.Invoke(i)
		}
	}()

	time.Sleep(5 * time.Second)
	p.Release()
	wg.Wait()
}
```
ants version: v2.4.7 SHA-1: 1e897421860606afc3d1304cafe5cd187cee13e9
go version: 1.17.2",,,,43245434,zhu121,7496278,panjf2000,82217,https://github.com/panjf2000/ants/issues/202,2022-02-08T13:53:49.000+08:00,2021-12-13T11:36:28.000+08:00,2022-02-08T13:53:49.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,225,
1080729448,134018330,203,closed,What is the appropriate number of goroutine pools for different hardware resources?," For example, what is the number of goroutine pools for a 4-core 8G device?
",,,,19580983,NICEXAI,7496278,panjf2000,1738,https://github.com/panjf2000/ants/issues/203,2021-12-16T21:29:49.000+08:00,2021-12-15T16:31:33.000+08:00,2021-12-16T21:29:49.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,226,
1083013181,134018330,204,closed,如何设置协程池初始协程的大小的呢？有没有计算公式？,"**What is your question about ants?**
Please describe your question meticulously.
如何设置协程池初始协程的大小的呢？有没有计算公式？当前的机器环境4核8G",,,,12879248,18310983239,7496278,panjf2000,117996,https://github.com/panjf2000/ants/issues/204,2022-03-09T15:13:26.000+08:00,2021-12-17T16:36:44.000+08:00,2022-03-09T15:13:26.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,227,
1094905000,134018330,205,closed,当使用Tune(size int)放大容量时，之前blocking的任务并不会立即执行,"当使用Tune(size int)放大容量时，之前blocking的任务并不会立即执行
经过测试，正在运行的一个任务结束后才会按照当前被Tune后的真实cap去执行任务

这里想问一下除了我在外坚挺cap变化后再提交新任务这种方法外，还有没有别的方法可以让我在放大容量后立即执行blocking的任务
",,,,12636470,nzx824,7496278,panjf2000,56848,https://github.com/panjf2000/ants/issues/205,2022-02-14T21:51:40.000+08:00,2022-01-06T10:23:30.000+08:00,2022-02-14T21:51:41.000+08:00,,,"{""Owner"":""panjf2000"",""Repo"":""ants""}",_raw_github_api_issues,228,
